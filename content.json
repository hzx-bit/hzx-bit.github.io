{"meta":{"title":"hzx's blog","subtitle":"","description":"","author":"huangzhixin","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2024-09-15T09:45:48.795Z","updated":"2024-09-15T09:45:48.795Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2024-09-15T09:40:25.000Z","updated":"2024-09-15T09:40:25.154Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-09-15T09:46:14.266Z","updated":"2024-09-15T09:46:14.266Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-09-15T09:45:11.683Z","updated":"2024-09-15T09:45:11.683Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"企业门户管理系统","slug":"企业门户管理系统","date":"2025-03-25T06:31:35.000Z","updated":"2025-04-08T09:48:37.977Z","comments":true,"path":"2025/03/25/企业门户管理系统/","permalink":"http://example.com/2025/03/25/%E4%BC%81%E4%B8%9A%E9%97%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"前端配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//vite.config.jsimport path from &#x27;path&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import Vue from &#x27;@vitejs/plugin-vue&#x27;import Icons from &#x27;unplugin-icons/vite&#x27;import IconsResolver from &#x27;unplugin-icons/resolver&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;import vueDevTools from &#x27;vite-plugin-vue-devtools&#x27;const pathSrc = path.resolve(__dirname, &#x27;src&#x27;);//src文件夹路径export default defineConfig(&#123; resolve: &#123; alias: &#123; &#x27;@&#x27;: pathSrc,//配置src别名路径 &#125;, &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;]//别名路径解析 &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;]//不编译node_modules &#125;, plugins: [ Vue(), vueDevTools(), AutoImport(&#123; // 自动导入 Vue 相关函数，如：ref, reactive, toRef 等 imports: [&#x27;vue&#x27;], // 自动导入 Element Plus 相关函数，如：ElMessage, ElMessageBox... (带样式) resolvers: [ ElementPlusResolver(), // 自动导入图标组件 IconsResolver(&#123; prefix: &#x27;Icon&#x27;, &#125;), ], vueTemplate: true, dts: path.resolve(pathSrc, &#x27;typings&#x27;, &#x27;auto-imports.d.ts&#x27;), &#125;), Components(&#123; resolvers: [ // 自动注册图标组件 IconsResolver(&#123; enabledCollections: [&#x27;ep&#x27;], &#125;), // 自动导入 Element Plus 组件 ElementPlusResolver(), ], dts: path.resolve(pathSrc, &#x27;typings&#x27;, &#x27;components.d.ts&#x27;), &#125;), Icons(&#123; autoInstall: true, &#125;), ], server:&#123;//配置代理服务器 proxy:&#123; &#x27;/adminapi&#x27;:&#123; target:&#x27;http://localhost:3000/&#x27;, changeOrigin:true, &#125; &#125; &#125;&#125;) 图片上传后产生url展示1URL.createObjectURL(uploadFile.raw) 企业门户网站管理系统后端配置环境下载express生成器1npm i express-generator -g 创建express项目123express servercd ./servernpm i 启动项目修改package.json实现热重载123&quot;scripts&quot;: &#123;&quot;start&quot;: &quot;nodemon ./bin/www&quot;&#125;, 目录结构","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"},{"name":"node.js","slug":"node-js","permalink":"http://example.com/tags/node-js/"}]},{"title":"计算机网络","slug":"计算机网络","date":"2025-02-13T06:49:08.000Z","updated":"2025-04-13T03:23:24.096Z","comments":true,"path":"2025/02/13/计算机网络/","permalink":"http://example.com/2025/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"OSI参考模型从下往上分别是物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。其中 物理层在通信信道中传输原始比特流。 数据链路层进行物理寻址，并且将原始比特流转化为逻辑链路。 网络层进行路由选择和分组转发。 传输层建立端到端的数据链接。 会话层在用户间建立和管理会话， 表示层进行数据格式转化和数据加密。 应用层为应用程序提供服务。 TCP&#x2F;IP网络模型链路层：负责封装和解封装IP报文，发送和接受ARP&#x2F;RARP报文等。网络层：负责路由以及把分组报文发送给目标网络或主机。传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。 HTTP请求&#x2F;响应的步骤 用户在浏览器地址栏输入URL,URL由协议、域名、端口号、文件路径组成，没有文件路径的时候，就会访问根目录下的默认文件，例如index.html 浏览器检查本地缓存是否有该域名对应的IP地址。如果缓存中没有，浏览器会通过递归方式请求本地DNS服务器、本地DNS服务器通过迭代方式请求根域名服务器、顶级域名服务器、权威域名服务器等，最终将IP地址返回给客户端，这个过程中浏览器、操作系统、各级DNS服务器都会先查看本地缓存，没有记录再去查询 浏览器通过IP地址和端口号与服务器建立TCP连接。也就是”三次握手“过程，如果是HTTPS协议，还会进行TLS&#x2F;SSL握手，确保通信安全。 浏览器向服务器发送HTTP请求，请求头中包含浏览器信息、支持的编码格式、Cookie等。服务器接收到请求后，根据路径和参数处理请求，生成响应内容。 服务器将响应数据和HTTP状态码返回给浏览器。响应头中包含内容类型、缓存策略等信息。 览器接收到响应后，开始解析HTML文件。解析过程中，浏览器会加载HTML中的CSS、JavaScript、图片等资源。浏览器构建DOM树、CSSOM树，合并生成渲染树，最后进行布局和绘制，将页面显示在屏幕上。 当所有资源加载完毕，页面完全渲染后，浏览器触发load事件，页面加载完成。 TCP连接关闭（四次挥手） 在浏览器中输入URL到显示页面涉及到哪些协议？浏览器要将URL解析为IP地址，解析域名就要用到DNS协议， DNS服务器是基于UDP的，因此会用到UDP协议。 得到IP地址后，浏览器就要与服务器建立一个http连接。因此要用到http协议。 http生成一个get请求报文，将该报文传给TCP层处理，所以还会用到TCP协议。 然后会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。 当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)， 以太网协议需要直到目的IP地址的物理地址，有需要ARP协议。 HTTP 的 5 种方法GET—获取资源POST—传输资源PUT—更新资源DELETE—删除资源HEAD—获取报文首部 POST请求和GET请求 GET传递的参数在url后拼接，不安全。POST传递的参数在request body中，更安全。 GET对数据进行查询，POST主要对数据进行增删改！ GET在浏览器回退时是无害的，而POST会再次提交请求 GET请求会被浏览器主动缓存，POST不会，要手动设置 GET请求长度有限制，POST没有 HTTP报文的组成成分请求报文{ 请求行、请求头、空行、请求体 } 响应报文{ 状态行、响应头、空行、响应体 } Request Header:GET &#x2F;sample.Jsp HTTP&#x2F;1.1 &#x2F;&#x2F;请求行：{http方法、页面地址、http协议、http版本}Host: www.uuid.online/ &#x2F;&#x2F;请求的目标域名和端口号Origin: http://localhost:8081/ &#x2F;&#x2F;请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）Referer: https://localhost:8081/link?query=xxxxx &#x2F;&#x2F;请求资源的完整URIUser-Agent: Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;67.0.3396.99 Safari&#x2F;537.36 &#x2F;&#x2F;浏览器信息Cookie: BAIDUID&#x3D;FA89F036:FG&#x3D;1; BD_HOME&#x3D;1; sugstore&#x3D;0 &#x2F;&#x2F;当前域名下的CookieAccept: text&#x2F;html,image&#x2F;apng &#x2F;&#x2F;代表客户端希望接受的数据类型是html或者是png图片类型Accept-Encoding: gzip, deflate &#x2F;&#x2F;代表客户端能支持gzip和deflate格式的压缩Accept-Language: zh-CN,zh;q&#x3D;0.9 &#x2F;&#x2F;代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)Connection: keep-alive &#x2F;&#x2F;告诉服务器，客户端需要的tcp连接是一个长连接 Response Header:HTTP&#x2F;1.1 200 OK &#x2F;&#x2F; 响应状态行：{http协议、http版本 响应码 状态}Date: Mon, 30 Jul 2018 02:50:55 GMT &#x2F;&#x2F;服务端发送资源时的服务器时间Expires: Wed, 31 Dec 1969 23:59:59 GMT &#x2F;&#x2F;比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页Cache-Control: no-cache &#x2F;&#x2F; 现在最多使用的控制缓存的方式，会和服务器进行缓存验证etag: “fb8ba2f80b1d324bb997cbe188f28187-ssl-df” &#x2F;&#x2F; 一般是Nginx静态服务器发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”Last-Modified: Fri, 27 Jul 2018 11:04:55 GMT &#x2F;&#x2F;是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容Content-Type: text&#x2F;html; charset&#x3D;utf-8 &#x2F;&#x2F;如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码Content-Encoding: gzip &#x2F;&#x2F;告诉客户端，应该采用gzip对资源进行解码Connection: keep-alive &#x2F;&#x2F;告诉客户端服务器的tcp连接也是一个长连接 http 和 https 的区别？• http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。• https 协议需要 ca 证书，费用较高。• http 协议的端口为 80，https 的端口为 443。• http 的连接很简单，是无状态的。 三次握手 一开始，客户端和服务端都处于CLOSED状态。先是服务端主动监听某个端口(HTTP默认端口号80,HTTPS默认端口号是443),处于LISTEN状态 然后客户端主动发起连接SYN,之后处于SYN-SENT状态。 服务端收到发起的连接，返回SYN,并且ACK客户端的SYN,之后处于SYN-RCVD状态 容户端收到服务端发送的SYN和ACK之后，发送对SYN确认的ACK,之后处于ESTABLISHED状态。 服务端收到ACK的ACK之后，处于ESTABLISHED状态 TCP 四次挥手 客户端进程发出连接释放报文，进入FIN-WAIT-1状态，并且停止发送数据。服务器收到连接释放报文，发出确认报文, 此时，服务端就进入了CLOSE-WAIT状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。 客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，此时，服务器就进入了LAST-ACK状态，等待客户端的确认。 客户端收到服务器的连接释放报文后，必须发出确认,此时，客户端就进入了TIME-WAIT状态。注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。可以看到，服务器结束TCP连接的时间要比客户端早一些。 Cookie、sessionStorage、localStorage 的区别相同点：存储在客户端不同点： sessionStorage和localStorage的存储比cookie大得多 cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除 cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地 HTTP状态码及常见状态码HTTP状态码• 1xx：指示信息类，表示请求已接受，继续处理• 2xx：指示成功类，表示请求已成功接受• 3xx：指示重定向，表示要完成请求必须进行更近一步的操作• 4xx：指示客户端错误，请求有语法错误或请求无法实现• 5xx：指示服务器错误，服务器未能实现合法的请求 常见状态码• 200 OK：客户端请求成功• 301 Moved Permanently：所请求的页面已经永久重定向至新的URL• 302 Found：所请求的页面已经临时重定向至新的URL• 304 Not Modified 未修改• 403 Forbidden：对请求页面的访问被禁止• 404 Not Found：请求资源不存在• 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用• 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常 HTTP 请求跨域问题跨域的原理跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的。跨域访问是被各大浏览器所默认禁止的。同源策略,是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，都被当作是不同的域。跨域原理，即是通过各种方式，避开浏览器的安全限制。 同源策略的作用①无法用js读取非同源的Cookie、LocalStorage 和 IndexDB这个主要是为了防止恶意网站通过js获取用户其他网站的cookie等用户信息。 ②无法用js获取非同源的DOM防止恶意网站通过iframe获取页面dom，从而窃取页面的信息。 ③无法用js发送非同源的AJAX请求获取数据防止恶意的请求攻击服务器窃取数据信息。 注意： 同源策略仅存在于浏览器端，服务器端不存在同源策略 即使跨域了，Ajax请求也可以正常发出，但浏览器会进行校验，不会将响应数据交给开发者 &lt;link&gt; script&gt; &lt;img&gt;等标签发出的请求也可能发生跨域，但是浏览器对标签跨域不做限制 比方说通过内容分发网络引用jQuery ### 跨域资源共享 **原理：**CORS由一系列HTTP响应头组成，这些响应头决定浏览器是否阻止前端JS代码跨域获取资源。浏览器的同源安全策略（协议、ip地址、端口号必须相同）默认会阻止网页”跨域“获取资源。但是如果接口服务器配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制。 | CORS响应头部 | 描述 | | ------------------------------------------------------------ | -------------------------------- | | res.setHeader('Access-Control-Allow-Origin','*') | 设置允许访问该资源的外域URL | | res.setHeader('Access-Control-Allow-Headers','X-Custom-Header') | 对额外的请求头进行声明 | | res.setHeader('Access-Control-Allow-Methods','*') | 设置实际请求所允许使用的HTTP方法 | ### 预检请求 只要符合以下任何条件之一，都需要进行预检请求： 1. 请求方式为GET、POST、HEAD之外的请求Method类型 2. 请求头中包含自定义头部字段 3. 向服务器发送了application/json格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求，所以这一次的OPTION请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并携带真实数据。 ### JSONP接口 浏览器通过``标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP JSONP不属于真正的Ajax请求，没有使用XMLHttpRequest这个对象。JSONP仅支持GET请求，不支持POST、PUT、DELETE请求。需要后台配合，将返回结果包装成callback(res)的形式。 JSONP接口要声明在CORS接口之前","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"围城","slug":"围城","date":"2025-02-08T05:11:43.000Z","updated":"2025-02-08T07:10:55.852Z","comments":true,"path":"2025/02/08/围城/","permalink":"http://example.com/2025/02/08/%E5%9B%B4%E5%9F%8E/","excerpt":"","text":"女人原是天生的政治动物。虚虚实实，以退为进，这些政治手腕，女人生下来全有。……女人不必学政治，而现在的政治家要成功，都得学女人。政治舞台上的戏剧全是反串。 蛋已经下了，就不要去问母鸡是怎么下的。 经过长期苦旅而彼此不讨厌的人,才可以结交作朋友。朋友如此，伴侣就更需要这样了! 老实说，不管你跟谁结婚，结婚以后，你总发现你娶的不是原来的人，换了另外一个。早知道这样，结婚以前那种追求、恋爱等等，全可以剩掉。谈恋爱的时候，双方本相全收敛起来，到结婚还没有彼此认清，倒是老式婚姻干脆，索性结婚以前，谁也不认得谁。 爱情多半是不成功的，要么苦于终成眷属的厌倦，要么苦于未能终成眷属的悲哀。 结婚仿佛被围困的城堡，城外的人想冲出去，城里的人想逃出来。 要人知道自己有个秘密，而不让人知道是个什么秘密，等他们问，要他们猜，这是人性的虚荣。 假使订婚戒指是落入圈套的象征，钮扣也是扣住不放的预兆。 这一张文凭仿佛有亚当夏娃下身那片树叶的功用，可以遮羞包丑；小小一张方纸能把一个人的空疏愚笨寡陋都掩盖起来。 自己人之间，什么臭架子、坏脾气都行；笑容愈亲密，礼貌愈周到，彼此的猜忌或怨恨愈深。……在吵架的时候，先开口的未必占上风，后闭口才算胜利。 女人有女人的聪明，轻盈活泼得跟她的举动一样。比了这种聪明，才学不过是沉淀渣滓。说女人有才学，就仿佛赞美一朵花，说它在天平上称起来有白菜番薯的斤两。真聪明的女人决不用功要做成才女，她只巧妙的偷懒。 真正想一个人，记挂着他，希望跟他接近，这少得很。人事太忙了，也许我们全神贯注，无间断地怀念一个人。我们一生对于最亲爱的人的想念，加起来恐怕不到一点钟，此外不过是念头在他身上瞥过，想到而已。 天下只有两种人。比如一串葡萄到手，一种人挑最好的先吃，另一种人把最好的留到最后吃。照例第一种人应该乐观，因为他每吃一颗都是吃剩的葡萄里最好的;第二种人应该悲观，因为他每吃一颗都是吃剩的葡萄里最坏的。不过事实却适得其反，缘故是第二种人还有希望，第一种人只有回忆。 只有懂幸福的人才懂得进退一样精彩 流言这东西，比流感蔓延的速度更快，比流星所蕴含的能量更巨大，比流氓更具有恶意，比流产更能让人心力憔悴。 天下就没有偶然，那不过是化了妆的、戴了面具的必然。 对于丑人，细看是一种残忍——除非他是坏人，你要惩罚他。 上帝会懊悔没在人身上添一条能摇的狗尾巴，因此减低了不知多少表情的效果。 泛黄的照片失了真，承诺像刀伤了人。 结婚仿佛金漆的鸟笼，笼子外面的鸟想住进去，笼内的鸟想飞出去，所以结而离，离而结，没有了局 不受教育的人，因为不识字，上人的当，受教育的人，因为识了字，上印刷品的当。 我们对采摘不到的葡萄，不但想象它酸，也很可能想象它是分外地甜。 苏文纨跟新楣的长期认识并不会日积月累得成为恋爱，好比冬季每天的气候罢，你没法把今天的温度加在昨天的上面，好等明天积成个和暖的春日。 结婚无需太伟大的爱情，彼此不讨厌已经够结婚资本了。 事实上，一个人的缺点正像猴子的尾巴，猴子蹲在地上的时候，尾巴是看不见的，直到他向树上爬，就把后部供大众瞻仰，可是这红臀长尾巴本来就有，并非地位爬高了的新标识。 同行最不宜结婚，因为彼此是行家，谁也哄不倒谁，丈夫不会莫测高深地崇拜太太，太太也不会盲目地崇拜丈夫，婚姻的基础就不牢靠。 西洋赶驴子的人，每逢驴子不肯走，鞭子没有用，就把一串胡萝卜挂在驴子眼睛之前、唇吻之上。这笨驴子以为走前一步，萝卜就能到嘴，于是一步再一步继续向前，嘴愈要咬，脚愈要赶，不知不觉中又走了一站。那时候它是否吃得到这串萝卜，得看驴夫的高兴。一切机关里，上司驾驭下属，全用这种技巧。 我们在社会上一切说话全像戏院子的入场券，一边印着“过期作废”，可是那一边又不注明什么日期，随我们的便可以提早或延迟。 我发现拍马屁跟恋爱一样，不容许有第三者冷眼旁观。咱们以后恭维人起来，得小心旁边没有其他的人。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"}],"tags":[{"name":"《围城》","slug":"《围城》","permalink":"http://example.com/tags/%E3%80%8A%E5%9B%B4%E5%9F%8E%E3%80%8B/"}]},{"title":"leetcode","slug":"leetcode","date":"2025-01-03T09:24:22.000Z","updated":"2025-04-20T06:19:53.527Z","comments":true,"path":"2025/01/03/leetcode/","permalink":"http://example.com/2025/01/03/leetcode/","excerpt":"","text":"leetcode刷题笔记202. 快乐数 - 力扣（LeetCode） 123456789//错误代码var getHappy = function(n)&#123; let ans = 0; while(n)&#123; ans+= (n%10) ** 2; n/=10; &#125; return ans;&#125; 错误原因 在 JavaScript 中，使用&#x2F;运算符进行除法运算时（如n &#x2F;&#x3D; 10这个操作），如果n原本是整数类型，这样的除法操作会将结果转换为浮点数类型。例如，当n初始值为19，第一次执行n &#x2F;&#x3D; 10后，n会变成1.9，而后续在getHappy函数里期望对每一位数字进行处理（通过n % 10获取个位数字等操作），浮点数的取余等操作的行为和预期处理整数时不一致，并且不符合题目本意（通常是按整数的每一位来处理）。要解决这个问题，应该使用Math.floor（向下取整）或者Math.trunc（去除小数部分）等方法来确保n在分割每一位数字的过程中依然保持整数类型，修改后的getHappy函数如下： 12345678var getHappy = function(n)&#123; let ans = 0; while(n)&#123; ans+= (n%10) ** 2; n = Math.trunc(n/10); &#125; return ans;&#125; 15. 三数之和 - 力扣（LeetCode） 12345//错误代码var threeSum = function(nums) &#123; nums.sort(); //...&#125;; 错误原因 Array.sort()默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序，所以这样写会导致整数无法按大小排序。正确代码如下 1234var threeSum = function(nums) &#123; nums.sort((a,b)=&gt;a-b); //...&#125;; 541. 反转字符串 II - 力扣（LeetCode） 123456789//错误代码var reverse = function(s,from,to)&#123; while(from&lt;to)&#123; let temp = s[from]; s[from] = s[to]; s[t0] = temp; from++,to--; &#125;&#125; 错误原因 JavaScript中字符串为按值传递，作为参数传递时无法改变值。应改为传递数组，正确代码如下 123456789101112131415var reverse = function(arr,from,to)&#123; while(from&lt;to)&#123; let temp = arr[from]; arr[from] = arr[to]; arr[to] = temp; from++,to--; &#125;&#125;var reverseStr = function(s, k) &#123; const arr = Array.from(s); for(let i=0;i&lt;arr.length;i+=2*k)&#123; reverse(arr,i,Math.min(arr.length-1,i+k-1)); &#125; return arr.join(&#x27;&#x27;);&#125;; 28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode） KMP算法模板 12345678910111213141516var strStr = function(haystack, needle) &#123; const m=haystack.length,n=needle.length; if(n===0) return 0; const next= new Array(n).fill(0); for(let i=1,j=0;i&lt;n;i++)&#123; while(j&gt;0&amp;&amp;needle[i]!==needle[j]) j=next[j-1]; if(needle[i]===needle[j]) j++; next[i]=j; &#125; for(let i=0,j=0;i&lt;m;i++)&#123; while(j&gt;0&amp;&amp;haystack[i]!==needle[j]) j=next[j-1]; if(haystack[i]===needle[j]) j++; if(j===n) return i-n+1; &#125; return -1;&#125;; 239. 滑动窗口最大值 - 力扣（LeetCode） 数组模拟栈：const stack &#x3D; []; 入栈：stack.push(x); 出栈：stack.pop(); 查看栈顶：stack.at(-1); 判断栈非空：stack.length 数组模拟队列：const queue &#x3D; [] 入队：queue.push(x) 出队：queue.shift() 查看队首：queue[0] 查看队尾：queue.at(-1) 判断队非空：queue.length 123456789101112131415var maxSlidingWindow = function(nums, k) &#123; let ans = []; let queue = []; for(let i=0;i&lt;k-1;i++)&#123; while(queue.length&amp;&amp;nums[queue.at(-1)]&lt;nums[i]) queue.pop(); queue.push(i); &#125; for(let i=k-1;i&lt;nums.length;i++)&#123; while(queue.length&amp;&amp;nums[queue.at(-1)]&lt;nums[i]) queue.pop(); queue.push(i); while(queue[0]&lt;=i-k) queue.shift(); ans.push(nums[queue[0]]); &#125; return ans;&#125;; 77. 组合 - 力扣（LeetCode） 123456789101112131415161718//错误代码const ans = [];const path = [];var backtracking = function(n,k,startIndex)&#123; if(path.length===k)&#123; ans.push(path); return; &#125; for(let i=startIndex;i&lt;=n-k+path.length+1;i++)&#123; path.push(i); backtracking(n,k,i+1); path.pop(); &#125;&#125;;var combine = function(n, k) &#123; backtracking(n,k,1); return ans;&#125;; 错误原因 ans和path需要初始化 需将path的副本加入ans 12345678910111213141516171819let ans = [];let path = [];var backtracking = function(n,k,startIndex)&#123; if(path.length===k)&#123; ans.push(path.concat()); return; &#125; for(let i=startIndex;i&lt;=n-k+path.length+1;i++)&#123; path.push(i); backtracking(n,k,i+1); path.pop(); &#125;&#125;;var combine = function(n, k) &#123; ans = []; path = []; backtracking(n,k,1); return ans;&#125;; 189. 轮转数组 - 力扣（LeetCode） 1234567891011121314//错误代码var rotate = function(nums, k) &#123; const reverse = function(nums,from,to)&#123; while(from&lt;to)&#123; let temp = nums[from]; nums[from] = nums [to]; nums[to] = temp; from++,to--; &#125; &#125; reverse(nums,0,nums.length-k-1); reverse(nums,nums.length-k,nums.length-1); reverse(nums,0,nums.length-1);&#125;; 错误原因 ​ 元素左移、右移，传入翻转长度不能小于0或大于数组长度 1234567891011121314var rotate = function(nums, k) &#123; k%=nums.length; const reverse = function(nums,from,to)&#123; while(from&lt;to)&#123; let temp = nums[from]; nums[from] = nums [to]; nums[to] = temp; from++,to--; &#125; &#125; reverse(nums,0,nums.length-k-1); reverse(nums,nums.length-k,nums.length-1); reverse(nums,0,nums.length-1);&#125;; 121. 买卖股票的最佳时机 - 力扣（LeetCode） 123456789//错误代码var maxProfit = function(prices) &#123; let preMin = 0,ans = 0; for(let price of prices)&#123; if(price &gt; preMin) ans = Math.max(ans,price-preMin); else preMin = price; &#125; return ans;&#125;; 错误原因 ​ 设置preMin为0会导致股票一定有price的收益，正确做法应该是设置成Number.MAX_SAFE_INTEGER 12345678var maxProfit = function(prices) &#123; let preMin = Number.MAX_SAFE_INTEGER,ans = 0; for(let price of prices)&#123; if(price &gt; preMin) ans = Math.max(ans,price-preMin); else preMin = price; &#125; return ans;&#125;; 6. Z 字形变换 - 力扣（LeetCode） 123456789101112131415//错误代码var convert = function(s, numRows) &#123; let ans = &quot;&quot;; let temp = new Array(numRows).fill([]); let index=0,flag =-1; for(let ch of s)&#123; if(index===0||index === numRows-1) flag = -flag; temp[index].push(ch); index+=flag; &#125; for(let i=0;i&lt;numRows;i++)&#123; ans+=temp[i].join(&#x27;&#x27;); &#125; return ans;&#125;; 错误原因 ​ new Array(numRows).fill([]) 这种方式会导致 temp 数组中的所有元素都引用同一个空数组，而不是每个元素都是独立的空数组。 ​ 同时，当rows&#x3D;&#x3D;&#x3D;1是需要特殊处理 123456789101112131415var convert = function(s, numRows) &#123; if(numRows===1) return s; let ans = &quot;&quot;; let temp = new Array(numRows).fill().map(()=&gt;[]); let index=0,flag =-1; for(let ch of s)&#123; if(index===0||index === numRows-1) flag = -flag; temp[index].push(ch); index+=flag; &#125; for(let i=0;i&lt;numRows;i++)&#123; ans+=temp[i].join(&#x27;&#x27;); &#125; return ans;&#125;; 84. 柱状图中最大的矩形 - 力扣（LeetCode） 123456789101112131415161718192021222324252627//错误代码var largestRectangleArea = function(heights) &#123; const n = heights.length; const leftLowerIndex = new Array(n).fill(0); const rightLowerIndex = new Array(n).fill(n-1); let ans = 0; let stack = []; for(let i=0;i&lt;n;i++)&#123; while(stack.length&gt;0&amp;&amp;heights[stack.at(-1)]&gt;heights[i])&#123; const index = stack.pop(); rightLowerIndex[index]=i; &#125; stack.push(i); &#125; stack = []; for(let i=n-1;i&gt;=0;i--)&#123; while(stack.length&gt;0&amp;&amp;heights[stack.at(-1)]&gt;heights[i])&#123; const index = stack.pop(); leftLowerIndex[index]=i; &#125; stack.push(i); &#125; for(let i=0;i&lt;n;i++)&#123; ans = Math.max(ans,heights[i]*(rightLowerIndex[i]-leftLowerIndex[i]-1)); &#125; return ans;&#125;; 错误原因： 左边更低高度索引初值应设为-1；右边更低高度索引初值应设为n; 123456789101112131415161718192021222324252627//正确代码var largestRectangleArea = function(heights) &#123; const n = heights.length; const leftLowerIndex = new Array(n).fill(-1); const rightLowerIndex = new Array(n).fill(n); let ans = 0; let stack = []; for(let i=0;i&lt;n;i++)&#123; while(stack.length&gt;0&amp;&amp;heights[stack.at(-1)]&gt;heights[i])&#123; const index = stack.pop(); rightLowerIndex[index]=i; &#125; stack.push(i); &#125; stack = []; for(let i=n-1;i&gt;=0;i--)&#123; while(stack.length&gt;0&amp;&amp;heights[stack.at(-1)]&gt;heights[i])&#123; const index = stack.pop(); leftLowerIndex[index]=i; &#125; stack.push(i); &#125; for(let i=0;i&lt;n;i++)&#123; ans = Math.max(ans,heights[i]*(rightLowerIndex[i]-leftLowerIndex[i]-1)); &#125; return ans;&#125;; 343. 整数拆分 - 力扣（LeetCode） 考虑数值过小的边界情况，取整取余 123456789//正确代码var integerBreak = function(n) &#123; if(n&lt;=3) return n-1; if(n%3===1)&#123; return 3**(Math.floor(n/3)-1)*4; &#125;else&#123; return 3**(Math.floor(n/3))*2**Math.floor((n%3)/2); &#125;&#125;; 96. 不同的二叉搜索树 - 力扣（LeetCode） 123456789//计算组合数var numTrees = function(n) &#123; let ans = 1,fz = 2*n,count = n-1,fm=n; while(count--)&#123; ans*=fz--; while(ans%fm===0) ans/=fm--; &#125; return ans;&#125;; 494. 目标和 - 力扣（LeetCode） 123456789101112131415var findTargetSumWays = function(nums, target) &#123; let sum = 0; for(let num of nums) sum+=num; if(sum+target&lt;0||(sum+target)%2===1) return 0; const m=nums.length,n=(sum+target)&gt;&gt;1; const dp = new Array(m+1).fill().map(()=&gt;new Array(n+1).fill(0)); dp[0][0]=1; for(let i=1;i&lt;=m;i++)&#123; for(let j=0;j&lt;=n;j++)&#123; dp[i][j]+=dp[i-1][j]; if(nums[i-1]&lt;=j) dp[i][j]+=dp[i-1][j-nums[i-1]]; &#125; &#125; return dp[m][n];&#125;;","categories":[],"tags":[]},{"title":"es6","slug":"es6","date":"2024-12-20T07:02:49.000Z","updated":"2025-04-10T14:38:23.261Z","comments":true,"path":"2024/12/20/es6/","permalink":"http://example.com/2024/12/20/es6/","excerpt":"","text":"ES6新特性let 变量不能重复声明 产生块级作用域 不存在变量提升 不影响作用域链 const 声明常量，要赋初始值，不能重复声明 产生块级作用域 对数组或对象元素的修改，不算对常量的修改 不存在变量提升 不影响作用域链 作用域 局部作用域 函数作用域：函数内部声明的变量只能在函数内部访问 块作用域：使用{}包裹的代码块内部声明的变量外部有可能无法访问 let和const产生块作用域 var不会产生块作用域 全局作用域：&lt;script&gt;标签和js文件的最外层，声明的变量在其他任何作用域都能访问 window对象动态添加的属性也是全局的 函数中未使用任何关键字声明的变量也是全局的 作用域链：优先查找当前，依次查找父级作用域 变量和函数提升代码执行前，所有var声明的变量被提升到当前作用域的最前面。只提升声明，不提升赋值。 代码执行前，所有函数声明被提升到当前作用域的最前面。 解构赋值123456789101112//数组解构赋值const F4 = [&#x27;小沈阳&#x27;,&#x27;刘能&#x27;,&#x27;赵四&#x27;,&#x27;宋小宝&#x27;];const [xiao,liu,zhao,song]= F4;//对象解构赋值const obj = &#123; name:&#x27;hzx&#x27;, age:18, sayHello: function()&#123; console.log(&#x27;hello&#x27;); &#125;&#125;const &#123;name,age,sayHello&#125; = obj; 模板字符串 声明方式：&#96;&#96; 可以直接出现换行符 ${}实现字符串拼接 箭头函数rest参数 func(…args){} 必须放在参数列表最后 与arguments的区别 语法：arguments是一个内置对象，而rest参数是通过…语法创建的。 类型：arguments是一个类数组对象，而rest参数是一个真正的数组。 位置：rest参数必须放在函数参数列表的最后面，而arguments对象在任何函数中都可用。 功能：rest参数提供了一个数组，可以直接使用数组的方法，而arguments对象需要转换才能使用数组方法。 扩展运算符...将数组转化为逗号分隔参数序列 Symbol Symbol的值是唯一的，用来解决命名冲突问题 Symbol值不能与其他数据进行运算 Symbol定义的对象属性不能使用for in或for of循环遍历，但是可以使用Object.getOwnPropertySymbols() 和 Reflect.ownKeys()来获取对象的所有键名 迭代器1234567891011121314151617181920212223242526272829303132333435363738394041const banji = &#123; name:&quot;终极一班&quot;, students:[ &#x27;xiaoming&#x27;, &#x27;xiaoning&#x27;, &#x27;xiaotian&#x27;, &#x27;knight&#x27; ], [Symbol.iterator]()&#123; let index = 0; return &#123; next:()=&gt;&#123; if(index&lt;this.students.length)&#123; const res = &#123;value:this.students[index],done:false&#125; index++ return res &#125; return &#123;value: undefined, done:true&#125; &#125; &#125; &#125; &#125; for(let v of banji)&#123; console.log(v) &#125; const iterator = banji[Symbol.iterator]() console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next()) console.log(iterator.next())//输出xiaomingxiaoningxiaotianknight&#123;value: &#x27;xiaoming&#x27;, done: false&#125;done: false&#123;value: &#x27;xiaoning&#x27;, done: false&#125;&#123;value: &#x27;xiaotian&#x27;, done: false&#125;&#123;value: &#x27;knight&#x27;, done: false&#125;&#123;value: undefined, done: true&#125; 生成器1234567891011121314151617181920212223242526272829function * generator()&#123; console.log(&#x27;111&#x27;) yield &#x27;一只没有耳朵&#x27; console.log(&#x27;222&#x27;) yield &#x27;一只没有尾巴&#x27; console.log(&#x27;333&#x27;) yield &#x27;真奇怪&#x27; console.log(&#x27;444&#x27;)&#125;const iterator = generator()for(let v of generator())&#123; console.log(v)&#125;iterator.next()iterator.next()iterator.next()iterator.next()//输出111一只没有耳朵222一只没有尾巴333真奇怪444111222333444 应用实例 解决回调地狱 12345678910111213141516171819202122232425262728293031323334353637//回调地狱// setTimeout(() =&gt; &#123;// console.log(&#x27;111&#x27;)// setTimeout(() =&gt; &#123;// console.log(&#x27;222&#x27;)// setTimeout(() =&gt; &#123;// console.log(&#x27;333&#x27;)// &#125;, 3000)// &#125;, 2000)// &#125;, 1000)//生成器函数解决回调地狱function one()&#123; setTimeout(()=&gt;&#123; console.log(&#x27;111&#x27;) iterator.next() &#125;,1000)&#125;function two()&#123; setTimeout(()=&gt;&#123; console.log(&#x27;222&#x27;) iterator.next() &#125;,2000)&#125;function three()&#123; setTimeout(()=&gt;&#123; console.log(&#x27;333&#x27;) iterator.next() &#125;,3000)&#125;function * generator()&#123; yield one() yield two() yield three()&#125;let iterator = generator()iterator.next() 异步编程 1234567891011121314151617181920212223242526272829function getUsers()&#123; setTimeout(()=&gt;&#123; let data = &#x27;用户数据&#x27; iterator.next(data) &#125;,1000)&#125;function getOrders()&#123; setTimeout(()=&gt;&#123; let data = &#x27;订单数据&#x27; iterator.next(data) &#125;,2000)&#125;function getGoods()&#123; setTimeout(()=&gt;&#123; let data = &#x27;商品数据&#x27; iterator.next(data) &#125;,3000)&#125;function * generator()&#123; const users = yield getUsers() console.log(users) const orders = yield getOrders() console.log(orders) const goods = yield getGoods() console.log(goods)&#125;let iterator = generator()iterator.next() Promise1234567891011121314151617181920212223const fs = require(&quot;fs&quot;)const p = new Promise((resolve,reject)=&gt;&#123; fs.readFile(&#x27;./静夜思.md&#x27;,(err,data)=&gt;&#123; resolve(data) &#125;)&#125;)p.then(value=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(&#x27;./琵琶行.md&#x27;,(err,data)=&gt;&#123; resolve([...value,data]) &#125;) &#125;)&#125;).then(value=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; fs.readFile(&#x27;./滕王阁序.md&#x27;,(err,data)=&gt;&#123; resolve([...value,data]) &#125;) &#125;)&#125;).then(value=&gt;&#123; console.log(value.join(&#x27;\\n&#x27;))&#125;) Set123456789101112131415const arr1 = [3,1,4,1,5,9,2,6]const arr2 = [4,8,6,9]const s2 = new Set(arr2)//数组去重let result = [...new Set(arr1)]console.log(result)//求交集const intersection = [...new Set(arr1)].filter(item=&gt;s2.has(item))console.log(intersection)//求并集const union = [...new Set([...arr1,...arr2])]console.log(union)//求差集const diff = [...new Set(arr1)].filter(item=&gt;!s2.has(item))console.log(diff) class构造函数执行过程 创建新对象 构造函数this指向新对象 执行构造函数代码，修改this，添加新的属性 返回新对象 原型对象 每个构造函数都有一个prototype属性，指向原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存 构造函数通过原型分配的函数是所有对象所共享的，可以将不变的方法直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法 构造函数和原型对象中的this都指向实例化的对象 constructor原型对象上的构造器，指向构造函数 对象原型实例对象的__proto__属性,指向构造函数的原型对象 原型链 当访问一个对象的属性和方法时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（就是__proto__指向的prototype原型对象。 如果还没有就继续查找原型对象的原型，直至查找到null 可以用 instanceof 运算符检测构造函数的prototype属性是否出现在某个实例对象的原型链上。 模块化babelbabel是一个JavaScript编译器 1npm i babel-cli babel-preset-env browserify -D 1234//代码转换npx babel src/js -d dist/js --presets=babel-preset-env//打包npx browserify dist/app.js -o dist/bundle.js async与await作用：使异步代码看起来像同步代码一样 async函数 async函数的返回值为Promise对象 Promise对象的结果由async函数执行的返回值决定 await表达式 await必须写在async函数中 await右侧的表达式一般为Promise对象 await返回的是Promise成功的值 await的Promise失败了，就会抛出异常，需要try…catch捕获处理 动态导入1()=&gt;import()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://example.com/tags/es6/"}]},{"title":"Eslint","slug":"Eslint","date":"2024-12-16T03:28:59.000Z","updated":"2024-12-16T14:11:00.772Z","comments":true,"path":"2024/12/16/Eslint/","permalink":"http://example.com/2024/12/16/Eslint/","excerpt":"","text":"EslintESLint 是一个用于识别和报告在 ECMAScript&#x2F;JavaScript 代码中发现的模式的工具，其目标是使代码更加一致并避免错误。 安装确保事先运行 npm init,已经有 package.json 文件。 1npm init -D @eslint/config@latest 使用托管在 npm 上的特定可共享配置 1npm init -D @eslint/config@latest -- --config packageName 在项目中添加 eslint.config.js文件 1touch eslint.config.js 运行1npx eslint your-project-dir/yourfile.js 配置12345678910111213// eslint.config.jsimport js from &quot;@eslint/js&quot;;export default [ js.configs.recommended, &#123; rules: &#123; &quot;no-unused-vars&quot;: &quot;warn&quot;, &quot;no-undef&quot;: &quot;warn&quot; &#125; &#125;]; 配置文档 实践问题要关闭 ESLint 中的vue&#x2F;multi-word-component-names提示在eslint.config.js中添加 12345&#123; &quot;rules&quot;: &#123; &quot;vue/multi-word-component-names&quot;: &quot;off&quot; &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Eslint","slug":"Eslint","permalink":"http://example.com/tags/Eslint/"}]},{"title":"html&css","slug":"html-css","date":"2024-11-24T06:57:34.000Z","updated":"2025-04-12T14:55:43.065Z","comments":true,"path":"2024/11/24/html-css/","permalink":"http://example.com/2024/11/24/html-css/","excerpt":"","text":"语义化标签header nav main article section aside footer 语义化的优点: 在没CSS样式的情况下，页面整体也会呈现很好的结构效果 代码结构清晰，易于阅读， 利于开发和维护方便其他设备解析（如屏幕阅读器）根据语义渲染网页。 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重 HTML5新特性语义化标签音视频处理API(audio,video)canvas &#x2F; webGL拖拽释放(Drag and drop) APIhistory APIrequestAnimationFrame地理位置(Geolocation)APIwebSocketweb存储 localStorage、SessionStorage表单控件，calendar、date、time、email、url、search 新的HTML5文档类型和字符集HTML5文档类型是&lt;！doctype html&gt;。 HTML5使用的字符集&lt; meta charset&#x3D;“UTF8”&gt;。 HTML5 Canvas元素Canvas元素用于在网页上绘制图形，该元素标签的强大之处在于可以直接在HTML上进行图形操作。 HTML5新增了哪些功能新增的功能API包括 Media APl、 Text Track API、 Application Cache API、User Interaction、 Data Transfer API、 Command API、 Constraint Validation API、 History API HTML5的离线存储localStorage，可长期存储数据，即浏览器关闭后数据不丢失 session Storage，数据在浏览器关闭后自动删除 HTML5的form如何关闭自动补全功能将不想要提示的form元素下的 Input元素的 autocomplete属性设置为off HTML5引入了哪些新的表单属性？新增表单属性包括 datalist、 datetime、 output、 keygen、date、 month、week、time、 number、 range、 email、url HTML5中的应用缓存是什么？HTML5应用缓存的最终目的是帮助用户离线浏览页面。换句话说，如果网络连接不可用，打开的页面就来自浏览器缓存，离线应用缓存可以帮助用户达到这个目的。 应用缓存可以帮助用户指定哪些文件需要缓存，哪些不需要 HTML5应用程序缓存为应用带来什么优势？应用程序缓存为应用带来3个优势。 （1）离线浏览，让用户可在应用离线时（网络不可用时）使用它们。 （2）速度，让已缓存资源加载得更快。 （3）减少服务器负载，让浏览器将只下载服务器更新过的资源。 CSS 选择器及优先级选择器 id选择器(#myid)类选择器(.myclass)属性选择器(a[rel&#x3D;“external”])伪类选择器(a:hover, li:nth-child)标签选择器(div, h1,p)相邻选择器（h1 + p）子选择器(ul &gt; li)后代选择器(li a)通配符选择器(*)优先级： !important内联样式（1000）ID选择器（0100）类选择器&#x2F;属性选择器&#x2F;伪类选择器（0010）元素选择器&#x2F;伪元素选择器（0001）关系选择器&#x2F;通配符选择器（0000）带!important 标记的样式属性优先级最高； 样式表的来源相同时： !important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性 CSS3新特性圆角 阴影 变换 更多的CSS选择器 色彩模式，如rgba； 伪元素::selection; 媒体查询； 多栏布局； 图片边框（ border-image）。 CSS3新增伪类新增伪类有以下几个：p:first- of-type，选择属于其父元素的首个元素的每个元素。 p:last-of-type，选择属于其父元素的最后一个元素的每个元素。 p:only- of-type，选择属于其父元素的唯一元素的每个元素。 p:only- child，选择属于其父元素的唯一子元素的每个元素。 p:nth- child（2），选择属于其父元素的第二个子元素的每个元素。 :enabled:disabled，控制表单控件的禁用状态. :checked，单选框或复选框被选中。 CSS3动画如何在动作结束时保持该状态不变采用 animation- fill-mode。其可以设置为以下值。 none，不改变默认行为。 forwards，当动画完成后，保持最后一个属性值（在最后一个关键帧中定义） backwards，在 animation-delay所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）。 both，向前和向后填充模式都可以应用。 box- sizingbox-sizing属性主要用来控制元素盒模型的解析模式。默认值是 content-box。 content-box让元素维持W3C的标准盒模型。元素的宽度&#x2F;高度由 border+ padding+content的宽度&#x2F;高度决定，设置 width&#x2F;height属性指的是指定 content部分的宽度&#x2F;高度。 border-box让元素维持IE传统盒模型（IE6以下版本和IE6、IE7的怪异模式）。设置 width&#x2F;height属性指的是指定 border+ padding+ content的宽度&#x2F;高度。 标准浏览器下，按照W3C规范解析盒模型。一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 CSS3动画的优缺点优点如下: 在性能上会稍微好一些。代码相对简单。 缺点如下: 在动画控制上不够灵活，兼容性不好。 Animation与 Transition的异同Animation与 Transition的功能相同，都是通过改变元素的属性值来实现动画效果的。 它们的区别在于，使用 Transition的功能时只能用指定属性的开始值和结束值，然后在这两个属性值之间使用平滑过渡的方式实现动画效果，因此不能实现比较复杂的动画效果。 Animation功能通过定义多个关键帧，以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果。 Animation属性值两个必要属性如下。 animation-name，即动画名称。 animation- duration，即动画持续时间。 其他属性值如下。 animation- play-state，即播放状态（ running表示播放， paused表示暂停），可以用来控制动画暂停。 animation- timing- function，即动画运动形式。 animation- delay，即动画延迟时间。 mation-iteration- count，即重复次数。 animation-direction，即播放前重置（ alternate动画直接从上一次停止的位置开始执行）。 媒体查询+rem的使用方法@media媒体类型and（媒体特性）{样式规则}这通常在移动端使用。在做移动端开发的时候，为了适配多屏幕，使用rem单位，然后根据屏幕尺寸的改变动态地设置根节点HIML的font-size值。这样可以解决多屏幕适配的问题。 html{font-size：20px;}@media （min-width：320px） {html{font-size：12px；}}@media （min-width：360px）{html{font-size：16px；}}但是这种做法有两个缺点。 （1）适配屏幕的尺寸不是连续的。 （2）会在CSS文件中添加大段的查询代码，增加了CSS文件的大小，为改进上述缺点，可以使用 JavaScript获取移动设备屏幕的宽度，根据设计稿的原型尺寸，动态地计算font-size的值。 rem的原理在做响应式布局的时候，通过调整HTML的字体大小，页面上所有使用rem单位的元素都会做相应的调整。 设置CSS3文本阴影h1{text- shadow：水平阴影，垂直阴影，模糊距离，阴影颜色} 盒阴影盒阴影的语法结构与文本阴影类似，如box- shadow：5px 5px 5px rgba（255，15，255，0.5）。 但是，盒阴影多了一个属性，即外延值 inset.，如box- -shadow：5px 5px 25px rgba（0,0,255，0.5）inset。 通过CSS3实现背景颜色线性渐变具体代码如下： div{background：-webkit-linear-gradient （left, red, green 50%， blue）；} CSS3中 transition属性值及含义transition属性是一个简写属性，用于设置以下4个过渡属性。 transition- property，哪个属性需要实现过渡 transition- duration，完成过渡效果需要多少秒&#x2F;毫秒 transition- timing- function，速度效果的运动曲线，如 linear、ease-in、ease、ease-out、 ease-in-out, cube-bezier。 transition- delay，规定过渡开始前的延迟时间。 用省略号显示超出文本的内容使用text-overflow:ellopsis。 当文本溢出时，为了不显示省略标记（…），通过clip直接将溢出的部分裁剪掉。 实现文本换行使用word-wrap属性。 normal，只在允许的断字点换行（浏览器保持默认处理）。 break-word，在长单词或URL地址内部进行换行。 position 属性的值有哪些及其区别固定定位 fixed： 元素的位置相对于浏览器窗口是固定位置，即使窗口是滚动的它也不会移动。Fixed 定 位使元素的位置与文档流无关，因此不占据空间。 Fixed 定位的元素和其他元素重叠。 相对定位 relative： 如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直 或水平位置，让这个元素“相对于”它的起点进行移动。 在使用相对定位时，无论是 否进行移动，元素仍然占据原来的空间。因此，移动元素会导致它覆盖其它框。 绝对定位 absolute： 绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那 么它的位置相对于。absolute 定位使元素的位置与文档流无关，因此不占据空间。 absolute 定位的元素和其他元素重叠。 粘性定位 sticky： 元素先按照普通文档流定位，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。而后，元素定位表现为在跨越特定阈值前为相对定 位，之后为固定定位。 默认定位 Static： 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声 明）。 inherit: 规定应该从父元素继承 position 属性的值。 让一个元素水平垂直居中水平居中对于 行内元素 : text-align: center;对于确定宽度的块级元素：（1）width和margin实现。margin: 0 auto;（2）绝对定位和margin-left: margin-left: (父width - 子width）&#x2F;2, 前提是父元素position: relative对于宽度未知的块级元素（1）table标签配合margin左右auto实现水平居中。使用table标签（或直接将块级元素设值为 display:table），再通过给该标签添加左右margin为auto。（2）inline-block实现水平居中方法。display：inline-block和text-align:center实现水平居中。（3）绝对定位+transform，translateX可以移动本身元素的50%。（4）flex布局使用justify-content:center 垂直居中利用 line-height 实现居中，这种方法适合纯文字类通过设置父容器 相对定位 ，子级设置 绝对定位，标签通过margin实现自适应居中弹性布局 flex :父级设置display: flex; 子级设置margin为auto实现自适应居中父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现table 布局，父级通过转换成表格形式，然后子级设置 vertical-align 实现。（需要注意的是：vertical-align: middle使用的前提条件是内联元素以及display值为table-cell的元素）。 隐藏页面中某个元素的方法opacity：0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click 事件，那么点击该区域，也能触发点击事件的visibility：hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件 ，隐藏对应元素，在文档布局中仍保留原来的空间（重绘）display：none，把元素隐藏起来，并且会改变页面布局， 不显示对应的元素。 页面布局Flex 布局布局的传统解决方案，基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex 是 Flexible Box 的缩写，意为”弹性布局”,用来为盒状模型提供最大的灵活性。指定容器 display: flex 即可。 简单的分为容器属性和元素属性。 容器的属性： flex-direction：决定主轴的方向（即子 item 的排列方法）flex-direction: row | row-reverse | column | column-reverse;flex-wrap：决定换行规则 flex-wrap: nowrap | wrap | wrap-reverse;flex-flow： .box { flex-flow: || ; }justify-content：对其方式，水平主轴对齐方式align-items：对齐方式，竖直轴线方向align-content 项目的属性（元素的属性）： order 属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为 0flex-grow 属性：定义项目的放大比例，即使存在空间，也不会放大flex-shrink 属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果 定义个 item 的 flow-shrink 为 0，则为不缩小flex-basis 属性：定义了在分配多余的空间，项目占据的空间。flex：是 flex-grow 和 flex-shrink、flex-basis 的简写，默认值为 0 1 auto。align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认属 性为 auto，表示继承父元素的 align-items 比如说，用 flex 实现圣杯布局 Rem 布局首先 Rem 相对于根(html)的 font-size 大小来计算。简单的说它就是一个相对单例 如:font-size:10px;,那么（1rem &#x3D; 10px）了解计算原理后首先解决怎么在不同设备上设置 html 的 font-size 大小。其实 rem 布局的本质是等比缩放，一般是基于宽度。 优点：可以快速适用移动端布局，字体，图片高度缺点：① 目前 ie 不支持，对 pc 页面来讲使用次数不多；② 数据量大：所有的图片，盒子都需要我们去给一个准确的值；才能保证不同机型的适配；③ 在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小。也就是说 css 样式和 js 代码有一定的耦合性。且必须将改变 font-size 的代码放在 css 样式之前。 百分比布局通过百分比单位 “ % “ 来实现响应式的效果。通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。 直观的理解，我们可能会认为子元素的百分比完全相对于直接父元素，height 百分比相 对于 height，width 百分比相对于 width。 padding、border、margin 等等不论是垂直方向还是水平方向，都相对于直接父元素的 width。 除了 border-radius 外，还有比如 translate、background-size 等都是相对于自身的。缺点： （1）计算困难（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。造成我们使用百分比单位容易使布局问题变得复杂。 浮动布局浮动布局:当元素浮动以后可以向左或向右移动，直到它的外边缘碰到包含它的框或者另外一个浮动元素的边框为止。元素浮动以后会脱离正常的文档流，所以文档的普通流中的框就变的好像浮动元素不存在一样。 优点这样做的优点就是在图文混排的时候可以很好的使文字环绕在图片周围。另外当元素浮动了起来之后，它有着块级元素的一些性质例如可以设置宽高等，但它与inline-block还是有一些区别的，第一个就是关于横向排序的时候，float可以设置方向而inline-block方向是固定的；还有一个就是inline-block在使用时有时会有空白间隙的问题缺点最明显的缺点就是浮动元素一旦脱离了文档流，就无法撑起父元素，会造成父级元素高度塌陷。 自适应布局（bootstrap）自适应布局分别为不同屏幕不同分辨率定义布局，即是创建多个静态页面，每个静态页面对应一个屏幕分辨率的一个范围内。在改变不同的屏幕分辨率可以切换到不同的静态布局上，但是布局中的元素位置会发生改变，但是在每个静态布局中，页面中的元素不会随着窗口大小的调整发生变化。使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。 优点：1.对网站的复杂程度兼容性更大；2.对开发工程师来说制作的成本代价更低；3.代码执行效果更高效；4.测试时更加容易，运营相对更加精准。 缺点： 在现如今的移动端设计百花齐放的时期之下，同一个网站往往需要为不同的设备制作不同的页面，不但会增加开发成本，还会因为客户的需求改变时，可能会改动多套代码、流程相比较来说较繁琐。 流式布局（fluid）流式布局的布局方式是页面的元素的宽度按照屏幕的分辨率进行适配的调整，但是整体布局不变，也称之为栅栏系统。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width&#x2F;min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。缺点： 屏幕大小变化时，页面元素也随之变化但是布局不变。这就会因为如果屏幕太大或太小都会布局时元素无法正常显示。 响应式布局一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验。设计方法： 媒体查询+流式布局。通常使用@media媒体查询，和网格系统配合相对布局单位进行布局。优点： 适应pc端和移动端，如果有足够的耐心，页面效果会很完美。缺点：1.只能适应主流的宽高；2.如果匹配足够多的设备屏幕的大小，对于工程师来说工作量不小，设计更需要多个版本，工作量增大。 前端优化的解决方案我们的优化原则有以下几个： 能缓存的，尽量强缓存。 引入外部资源时不要出现超时、404的状况。 减少HTTP请求数。 合理设置cookie的大小以及过期时间。 合理利用懒加载 网页内容的优化1、懒加载数据。首先根据标签的left和top属性判断是否显示在了屏幕中（如果显示在屏幕中，其left和top属性值应该是在0到窗口长宽之间）。如果显示在屏幕中，则将src标签的内容替换为图片的url。 2、不要缩放图片。img计算缩放也需要时间 3、避免重定向。重定向会重新渲染网页。 4、使用雪碧图（精灵图）：通过使用background-position：-xpx -ypx;来调整图片的位置，不过HTTP2不适用，原因为HTTP2实际上是多路复用的，只用一个TCP连接，所以多个图片的请求也是在同一个TCP连接里，这样能省下非常多的请求时间，但坏处就是单连接开销很大，如果要传多个大文件，就很麻烦。 5、要有网站小图标favicon.ico。 如果没有小图标，会引起404，拖慢网页加载进度。6、能使用jpeg就不要用png，能使用png8就不要用png24。（1）色彩丰富的、大的图片切成jpg的；（2）尺寸小的，色彩不丰富的和背景透明的切成gif或者png8的；（3）半透明的切成png24。 7、使用canvas压缩图片。 css的优化1、避免使用@import。使用@import相当于将引入的css放在了页面底部，因为使用@import引用的文件只有在引用它的那个css文件被下载、解析之后，浏览器才会知道还有另外一个css需要下载，这时才去下载，然后下载后开始解析、构建render tree等一系列操作。因此使用@import会拖慢渲染的过程。 2、将样式表放在head中。如果放在body中，可能出现在浏览器下载好css样式表之前，组件就已经加载好了的情况，这可能会导致重新渲染。 3、避免使用css表达式。如：expression((new Date()).getHours()%2 ? “#B8D4FF” : “#F08A00” );解析表达式和计算都需要时间。 JavaScript的优化1、尽量减少DOM访问。 2、使用事件代理（减少DOM操作）。 3、把脚本放在底部（加载脚本时会阻塞页面渲染）。 4、合理使用节流函数和防抖函数。 CDNCDN即内容分发网络。它依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。优化加载速度。 水平垂直居中的几种方法使用flex布局利用flex的alignItems:center垂直居中，justifycontent:center水平居中 利用相对定位和绝对定位的margin:auto相对定位下，使用绝对定位将上下左右都设置为0，再设置margin:auto即可实现居中 利用相对定位和绝对定位，再加上外边距和平移的配合相对定位下，使用绝对定位，利用margin偏移外容器的50%，再利用translate平移回补自身宽高的50%即可","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"}]},{"title":"数据库","slug":"数据库","date":"2024-10-15T09:17:26.000Z","updated":"2024-10-22T12:14:50.545Z","comments":true,"path":"2024/10/15/数据库/","permalink":"http://example.com/2024/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"数据库系统概论概述 四个基本概念 数据(data)：描述事物的符号记录称为数据 数据库(DB)：长期储存在计算机内的，有组织的、可共享的大量数据的集合。 数据库管理系统(DBMS)：计算机基础软件。具有 数据定义功能(DDL)，定义数据对象的组成和结构 数据组织存储和管理 数据操纵功能（DML），实现数据的增删改查 数据库的事务管理和运行管理 数据库的建立和维护功能 数据库系统（DBS）：由数据库（DB）、数据库管理系统（DBMS）、应用程序（APP）和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。 数据库系统的特点 数据结构化 数据共享性高、冗余度低且易扩充 数据独立性高 物理独立性：应用程序与数据库中数据的物理存储相互独立。 逻辑独立性：应用程序与数据库的逻辑结构相互独立。 数据由数据库管理系统统一管理和控制 数据模型——数据库系统的核心和基础 两类数据模型 概念模型 按用户的观点来对数据和信息建模 逻辑模型和物理模型 逻辑模型：按计算机系统的观点对数据建模。包括层次模型、网状模型、关系模型、面向对象模型、对象关系数据类型、半结构化数据类型等 物理模型：数据在系统内部的表示方式和方法 逻辑模型到物理模型的转换，主要由数据库管理系统实现 概念模型 基本概念 实体：客观存在并可区分的事物 属性：实体具有的某一特性 码：唯一标志实体的属性 实体型：用实体名及其属性名集合来刻画和抽象同类实体。 联系： 实体之间的联系，通常指不同实体集之间的联系。 一种表示方法：实体-联系方法，也称为E-R模型 数据模型的组成要素 数据结构 数据操作 数据的完整性约束条件 关系模型 术语： 关系：对应一张表 元组：表中的一行 属性：表中的一列 码：某个属性组，唯一确定一个元组 域：一组具有相同数据类型是的集合 关系模式：对关系的描述 优点 与格式化模型不同，建立在严格的数学概念基础上 数据独立性保密性更高 概念单一、结构简单、清晰 存取路径对用户透明 缺点 查询效率不如格式化模型数据 数据库系统的结构 模式 模式是相对稳定的，实例是相对变动的 三级模式结构 模式，也称逻辑模式，是所有用户的公共数据视图，模式不涉及物理存储和硬件环境，与应用程序和开发环境无关。 外模式，也称子模式或用户模式，数据库用户的数据视图，外模式通常是模式的子集。 内模式，也称存储模式，是数据在数据库内部的组织方式 二级映象功能与数据独立性 数据独立性是指应用程序与数据库的数据结构之间相互独立 在物理结构改变时，尽量不影响应用程序，称为物理数据独立性 在逻辑结构改变时，尽量不影响应用程序，称为逻辑数据独立性 外模式&#x2F;模式映像 模式改变时，可使外模式保持不变，保证逻辑独立性 模式&#x2F;内模式映像 存储结构发生改变时，可使模式保持不变，保证物理独立性 数据库模式是数据库的中心与关键，应首先确定。 关系数据库结构及定义 在数据库中存储的是数据以及数据之间的联系。 定义 域 笛卡尔积 元组和分量 基数：一个域允许的不同取值的个数 关系 关系的度（单元关系，二元关系） 候选码（能唯一表示一个元组的属性集）——&gt;挑一个作为主码 主属性：候选码的诸属性其余——非主属性或非码属性 全码：关系模式的所有属性是这个关系模式的候选码 三种类型： 基本关系，又称基本表 查询表 视图表 六条性质： 行的顺序无所谓 列的顺序无所谓 列是同质的 不同列可出自同一域 任意两个元组候选码不同 分量必须取原子值（最基本的一条，满足即为第一范式） 关系模式 关系模式是静态的、稳定的，而关系是动态的 基本关系操作 查询操作 选择 投影 并 差 笛卡尔积&#x2F;&#x2F;以上5种基本数据操作 连接 除 交 插入、删除、修改操作 结构化查询语言SQL集 查询 数据定义语言 数据操纵语言 数据控制语言于一体的关系数据语言。 关系的完整性 实体完整性：若属性A是关系R的主属性，则A不能取空值。 参照完整性：若属性F是关系R的外码，它与基本关系S的主码相对应，则对于R上的每一个元组在F上的值应该或者取空值、或者取S中某个元组的主码值。 用户定义的完整性 实体完整性和参照完整性是关系的两个不变性。 关系代数 传统集合运算 并 差 交 笛卡尔积 关系运算象集：给定关系R（X,Z）,x在R中的象集为Zx，表示R中属性组X上的属性值为x的诸元组在Z上分量的集合，是属性组值的子集关系运算的定义： 选择 投影 连接常用： 等值连接 自然连接，一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。 外连接：保留悬浮元组 左外连接：只保留左边关系的悬浮元组 右外连接：只保留右边关系的悬浮元组 除：若T为R除以S的结果，则T包含所有在R中而不在S中的属性及其值，且T与S的所有组合均在R中。 SQL SQL的特点 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供多种使用方式：交互式和嵌入式 语言简洁，易学易用 SQL的基本概念 外模式包括视图和若干基本表，模式包括若干基本表，内模式包括若干存储文件。 在关系数据库管理系统中一个关系就对应一个基本表。一个或多个表对应一个存储文件，一个表可以带若干索引。索引也放在存储文件当中。 数据定义模式的定义与删除 建立模式12CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]; 删除模式1DROP SCHEMA &lt;CASCADE|RESRICT&gt;; 基本表的定义、删除与修改 创建表123456CREATE TABLE &lt;表名&gt; (&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;][,&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;]]...[,&lt;表级完整性约束条件&gt;]); 模式与表 在表中给出模式名，如CREATE TABLE “&lt;模式名&gt;”.&lt;表名&gt; 创建模式语句同时创建表 设置所属模式，如下123SHOW search_path; #显示当前搜索路径SET search_path TO &quot;&lt;模式名&gt;&quot;,PUBLIC; #设置搜索路径CREATE TABLE &lt;表名&gt;(); 修改基本表123456ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt; [完整性约束]][ADD &lt;表级完整性约束&gt;][DROP[COLUMN]&lt;列名&gt;[CASCADE|RESCTICT]][DROP CONSTRAINT&lt;完整性约束名&gt;[CASCADE|RESTRICT]][ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;]; 删除表1DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]; 索引的建立与删除 建立索引12CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;ON &lt;表名&gt;(&lt;列名&gt;[&lt;ASC|DESC&gt;][,&lt;列名&gt;[&lt;ASC|DESC&gt;]]...); 修改索引1ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 删除索引1DROP INDEX &lt;索引名&gt;; 数据操纵数据查询 SELECT语句 12345SELECT [ALL|DISTINCT]&lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]...FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;...]|(SELECT语句)[AS](别名)[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]]; tips SELECT * —-查询全部列 常用查询条件 &#x3D;,&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&lt;&gt;,!&gt;,!&lt;;NOT+ 上述比较符 [NOT] BETWEEN AND [NOT] IN [NOT] LIKE IS [NOT] NULL AND,OR,NOT 聚集函数 COUNT(*) ！！！不忽略空值NULL COUNT([DISTINCT|ALL]&lt;列名&gt;) SUM([DISTINCT|ALL]&lt;列名&gt;) AVG([DISTINCT|ALL]&lt;列名&gt;) MAX([DISTINCT|ALL]&lt;列名&gt;) MIN([DISTINCT|ALL]&lt;列名&gt;) GROUP BY子句 + HAVING子句 连接查询 等值与非等值连接查询 自身连接（要给表取两个别名） 外连接 多表连接 嵌套查询 相关定义： 一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询 外层查询又称父查询，内层查询又称子查询 子查询不能使用ORDER BY语句 不相关子查询：子查询的查询条件不依赖于父查询 相关子查询：子查询的查询条件依赖于父查询，不能一次性将子查询的结果求解出来，而是反复求值 嵌套查询中维持ANY&#x2F;SOME表示任一，ALL表示所有（任意） 带有EXISTS谓词的子查询，产生ture或false。（！！！所有带有IN谓词，、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS的子查询等价替代） 空值进行四则运算还是空值 集合查询–各查询结果列数必须相同，对应数据项的数据类型也必须相同 UNION–自动去掉重复元组，如要保留则用UNION ALL操作符。 INTERSECT EXCEPT 派生表查询：子查询嵌套于FROM子句中。（！！！AS关键字可以省略，但必须为派生关系指定别名） 插入数据12INSERT INTO &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]...)]VALUES(&lt;常量1&gt;[,&lt;常量2&gt;]...); 或 12INSERT INTO &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]...)]子查询; 修改数据123UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]...[WHERE &lt;条件&gt;]; 删除数据12DELETE FROM &lt;表名&gt;[WHERE &lt;条件&gt;]; 视图——只存放定义，不存放数据 建立视图123CREATE VIEW &lt;视图名&gt; [&lt;列名&gt;[,&lt;列名&gt;]...]AS &lt;子查询&gt;[WITH CHECK OPTION]; 创建视图时并不执行SELECT语句，对视图查询时，才将数据查出。 删除视图1DROP VIEW &lt;视图名&gt; CASCADE; 视图的作用 视图能够简化用户操作 视图使用户能以多角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 更加清晰地表达查询 数据库安全授予与收回权限（控制类指令）–实现自主存取控制 用户权限由两要素组成：数据库对象和操作类型 GRANT：授予用户对列的操作权限1234GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION]; REVOKE1234REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE|RESTRINCT]; 创建数据库模式的权限1CREATE USER &lt;username&gt; [WITH][DBA|RESOURCE|CONNECT]; 数据库角色 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。 创建角色1CREATE ROLE &lt;角色名&gt;; 给角色授权123GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt; &lt;对象名&gt;TO &lt;角色&gt;[,&lt;角色&gt;]...; 将一个角色授权给其他角色或用户123GRANT &lt;角色1&gt;[,&lt;角色2&gt;]...TO &lt;角色3&gt;[,&lt;用户1&gt;]...[WITH ADMIN OPTION]; 角色权限的收回123REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;角色&gt;[,&lt;角色&gt;]... 强制存取控制敏感度标记：TS&gt;&#x3D;S&gt;&#x3D;C&gt;&#x3D;P规则： 仅当主体的许可证级别大于或者等于客体的密级时，改主体才能读取相应的客体。 仅当主体的许可证级别小于或者等于客体的密级时，改主体才能写相应的客体。 审计功能–一种事后检查的安全机制 记录一切成功和不成功的操作-AUDIT&#x2F;NOAUDIT12[NO]AUDIT &lt;操作名&gt;[,&lt;操作名&gt;]...ON &lt;表名&gt;; 数据加密 存储加密 传输加密 其他安全性保护 推理控制 隐蔽信道 数据隐私保护 数据库完整性——数据库的正确性和相容性 实体完整性 检查主码值是否唯一，如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空，只要有一个空值就拒绝插入或修改。 参照完整性 （破坏参照完整性的）操作 违约处理 参照表插入元组 拒绝 参照表修改外码值 拒绝 被参照表删除元组 拒绝&#x2F;级联删除&#x2F;设置为空值 被参照表修改主码值 拒绝&#x2F;级联删除&#x2F;设置为空值 3. 用户自定义的完整性 1. 属性上的约束条件——不满足则拒绝执行 - NOT NULL - UNIQUE - CHECK短语 2. 元组上的约束条件——不满足则拒绝执行 完整性命令约束命名子句 完整性约束命名子句(新建表时)1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;; 修改表中的完整性限制 删除完整性约束 12ALTER TABLE &lt;表名&gt;DROP CONSTRAINT &lt;完整性约束条件名&gt;; 增加完整性约束 12ALTER TABLE &lt;表名&gt;ADD CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;; 断言 通过声明断言来指定更具一般性的约束。可以定义涉及多个表或聚集操作的比较复杂的完整性约束，任何使断言不为真值的操作都会被拒绝执行。 创建断言语句1CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt;; 删除断言语句1DROP ASSERTION &lt;断言名&gt;; 触发器 定义触发器12345CREATE TRIGGER &lt;触发器名&gt;&#123;BEFORE|AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;REFERENCES NEW|OLD ROW AS &lt;变量&gt;FOR EACH &#123;ROW|STATEMENT&#125;[WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;; 激活触发器， 多个触发器时： 执行该表上的BEFORE触发器 激活触发器的SQL语句 执行该表上的AFTER触发器 删除触发器1DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;; 关系数据理论 相关术语 函数依赖：R(U)是属性集U上的关系模式，X，Y是U的子集。对于R的任意一个可能关系r，r中不可能存在两个元组在X上的属性值相等，在Y上的属性值不等，称Y函数依赖于X，记作X-&gt;Y。 若Y$\\subseteqq$X，为平凡的函数依赖。 部分函数依赖：X-&gt;Y，若对于X的每一个真子集X’，X’-&#x2F;-&gt;Y，则称Y对X完全函数依赖，记作X$\\frac{F}{}$&gt;Y。否则称为部分函数依赖。 传递函数依赖：X-&gt;Y,Y-&#x2F;-&gt;X，Y-&gt;Z(Z$\\subsetneqq$Y，Y$\\subsetneqq$X)，称Z传递函数依赖于X，记作X$\\frac{传递}{}$&gt;Z。 超码：K为R&lt;U,F&gt;中的属性或属性组合，K-&gt;U，称K为超码。 候选码：K$\\frac{F}{}$&gt;U,称K为候选码。(特殊的超码) 主码：选定的一个候选码。 全码：整个属性组是码。 主属性：包含在任何一个候选码中的属性。 非主属性&#x2F;非码属性：不包含在任何候选码中的属性。 多值依赖：X，Y，Z是U的子集，且Z&#x3D;U-X-Y，若给定一对(x,z)值，有一组Y值，这组值仅仅决定于x值而与z无关。称Y多值依赖于X，记作X-&gt;-&gt;Y。 闭包：$X^{+}{F}$&#x3D;{A|X-&gt;A能由F导出}，$X^{+}{F}$称为属性集X关于函数依赖集F的闭包。 最小依赖集&#x2F;最小覆盖： 任一函数依赖右部仅含一个属性。 函数依赖个数精简到最少 函数依赖的左部精简到最少 范式 第一范式（1NF）：每一个分量都是不可分的数据项 第二范式（2NF）：1NF&amp;不存在非主属性对任一候选码的部分函数依赖。 第三范式（3NF）：2NF&amp;不存在非主属性对任一候选码的传递函数依赖。 所有属性都是主属性的模式最高一定可以达到 BC范式（BCNF）:每一个决定因素都包含码，消除了插入、删除的异常。满足： 3NF 所有主属性对于任一不包含它的码也是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性。 (全码组成的关系模式最高一定可以到达||3NF+唯一候选码||二元模式最高一定可以到达) 4NF：属性之间不允许有非平凡且非函数依赖的多值依赖 判断范式 求候选码 如果有属性只在函数依赖集的左边出现，则该属性一定包含在候选码中（继续求它的闭包，如果他的闭包是属性全集，则为候选码，如果不是，则需要结合其他属性求闭包，继而判断是否是候选码） 只在函数依赖集右边出现的属性，一定不属于候选码 对于左右都出现过的属性：（1）先结合只在左边出现的属性求闭包，看看是否包括所有属性，如果他的闭包是属性全集，则为候选码；（2）如果没有包括所有属性，就结合其他左右都出现的求闭包，看看是否包括所有属性，如果他的闭包是属性全集，则为候选码 如果有属性不在函数依赖集中出现（外部属性），那么一定包含在候选码中（继续求它的闭包，如果他的闭包是属性全集，则为候选码，如果不是，则需要结合其他属性求闭包，继而判断是否是候选码） 分主属性、非主属性 判断范式。 规范化1NF$\\frac{消除非主属性对码的部分函数依赖}{}$&gt;2NF$\\frac{消除非主属性对码的传递函数依赖}{}$&gt;3NF$\\frac{消除主属性对码的部分和传递函数依赖}{}$&gt;BCNF$\\frac{消除非平凡且非函数依赖的多值依赖}{}$&gt;4NF 函数依赖的公理系统 推理规则——Armstrong公理系统 自反率：若Y$\\subseteqq$X$\\subseteqq$U，则X——&gt;Y被F所蕴含 增广率：若X——&gt;Y被F所蕴含，且Z$\\subseteqq$U，则XZ——&gt;YZ被F所蕴含 传递率：若X——&gt;Y及Y——&gt;Z被F所蕴含，则X——&gt;Z被F所蕴含 模式的分解无损连接性 保证不丢失信息 判断无损连接 保持函数依赖性 减轻或解决各种异常情况 判断保持函数依赖： 求投影F’&#x3D;F1∪F2∪…Fn是否包含全部函数依赖。 对于缺少的函数依赖，求左侧属性在判断F’中的闭包是否蕴含右侧。（$F’^{+}$&#x3D;&#x3D;$F^{+}$?） 模式分解算法 保持函数依赖，最多可以达到3NF。 保持无损连接性，最多可以达到4NF。 保持函数依赖和无损连接性，最多可以达到3NF 数据库恢复技术 事务的基本概念 事务的定义：用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务通常以BEGIN TRANSACTION开始，以COMMIT（提交）或ROLLBACK（回滚）结束。 事务的ACID特性： 原子性：事务是数据库的逻辑工作单位，事务中所包括的诸操作要么都做，要么都不做。 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。 隔离性：对于并发执行而言，一个事务的执行不能被其他事务干扰。 持久性：也称永久性，一个事务一旦提交，它对数据库中数据的改变就应该是永久的。 故障的种类 事务内部的故障：非预期的，不能由应用程序处理的。 常见原因： 运算溢出 并发进程发生死锁而被选中撤销该事务 违反了某些完整性限制 恢复操作：事务撤销（UNDO）：反向扫描日志文件，查找事务的更新操作执行逆操作 系统故障：称为软故障，指造成系统停止运转的任何事件，使得系统要重新启动 常见原因 特定类型的硬件错误 操作系统故障 DBMS代码错误 系统断电 恢复策略 正向扫描日志文件 发生系统故障时，事务未提交：强行撤销所有未完成的事务 发生系统故障时，事务已提交，但缓冲区的信息未完全写回到磁盘上：重做所有已提交的事务。 介质故障：称为硬故障，指外存故障。 常见原因 磁盘损坏 磁头碰撞 操作系统的某种潜在错误 瞬时强磁场干扰 恢复策略 装入数据库发生介质故障前某个时刻的数据副本 重做此时起的所有成功事务，将这些事务已提交的结果重新记入数据库。 使用检查点改善恢复效率 数据库镜像 计算机病毒 人为故障或破坏的计算机程序，可以繁殖和传播，等同于介质故障。 恢复的实现技术 基本原理：冗余——利用存储在系统其他地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据。 如何建立冗余数据？数据转储和登记日志文件 数据转储 转储方式分类 海量转储 增量转储 转储状态分类 动态转储 静态转储 登记日志文件——用来记录事务对数据库的更新操作的文件 登记内容（每个登记内容作为日志文件的一个日志记录）： 各个事务开始标记 各个事务结束登记 各个事务的所有更新操作 日志记录内容 事务标识 操作类型 操作对象 更新前数据的旧值 更新后数据的新值 作用： 进行事务故障和系统故障恢复 协助后备副本对介质故障进行恢复 登记日志文件时必须遵循两条原则： 登记的次序严格按并发事务执行的时间次序。 必须先写日志文件，后写数据库。 并发控制 概述 事务是并发控制的基本单位 并发操作带来的数据不一致性 丢失修改 读“脏”数据 不可重复读&#x2F;幻影现象 主要方法 封锁 时间戳 乐观控制法 多版本控制 封锁 排他锁&#x2F;写锁（X锁） 共享锁（S锁） 封锁协议： 一级封锁协议：修改数据之前必须加X锁，直到事务结束才释放——解决丢失修改 二级封锁协议：读数据之前必须加S锁，读完后释放——解决读脏数据 三级封锁协议：读数据之前必须加S锁，直到事务结束才释放——解决不可重复读 活锁和死锁 当两个（或多个）并发的事务分别等待对方释放封锁的资源，而使事务处于长期等待状态的现象称为死锁。 解决活锁的方法：先来先服务策略 解决死锁的两种方法： 预防： 一次封锁法:为了完成一个事务，一次性封锁所需要的全部表 顺序封锁法:所有的事务约定都按相同的顺序来封锁表 诊断与解除 超时法 事务等待图法 并发调度的可串行性——并发事务正确调度的准则 冲突可串行化是可串行化的充分条件 两段锁协议 事务分为两个阶段 扩展阶段，获得封锁 收缩阶段，释放封锁 事务遵守两段锁协议是可串行化的充分条件 封锁的粒度 封锁对象的大小称为封锁粒度，封锁对象可以是逻辑对象，也可以是物理对象 封锁粒度越大、数据库所能封锁的数据单元就越少，并发度就越小，系统开销越小；反之，封锁粒度越小、数据库所能封锁的数据单元就越多，并发度就越大，系统开销越大 多粒度封锁 显示封锁：应事务要求直接加到数据对象上的锁 隐式封锁：由于上级对象加锁而导致该数据对象加上了锁","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"node.js","slug":"node-js","date":"2024-10-12T13:31:48.000Z","updated":"2025-04-12T14:46:16.032Z","comments":true,"path":"2024/10/12/node-js/","permalink":"http://example.com/2024/10/12/node-js/","excerpt":"","text":"fs文件系统读取文件内容12345678910111213141516171819202122232425const fs = require(&quot;fs&quot;);// 异步读取fs.readFile(&#x27;input.txt&#x27;,&#x27;utf8&#x27;, function (err, data) &#123; //如果读取成功，则err的值为null //如果读取失败，则err的值为错误对象，dataStr的值为undefined if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取: &quot; + data.toString());&#125;);// 同步读取var data = fs.readFileSync(&#x27;input.txt&#x27;);console.log(&quot;同步读取: &quot; + data.toString());console.log(&quot;程序执行完毕。&quot;);//执行结果同步读取: 文件读取实例程序执行完毕。异步读取: 文件读取实例 写入文件内容1234567const fs = require(&quot;fs&quot;);fs.writeFile(&#x27;input.txt&#x27;, &#x27;我是通 过fs.writeFile 写入文件的内容&#x27;, function(err) &#123; if (err) &#123; return console.error(err); &#125;&#125;) 处理路径问题__dirname表示当前文件所处目录 path路径模块1const path = require(&quot;path&quot;) 方法 描述 path.join([path1][, path2][, …]) 用于连接路径。 path.basename() 获取路径中的文件名 path.extname(p) 获取文件的扩展名 path.dirname(p) 返回路径中代表文件夹的部分 path.resolve([from …], to) 将 to 参数解析为绝对路径 path.relative(from, to) xxxxxxxxxx import requestInstance from ‘.&#x2F;http’​export { requestInstance as http }typescript http创建服务器123456789const http = require(&#x27;http&#x27;)const server = http.createServer()server.on(&#x27;request&#x27;, function (req, res) &#123; console.log(&#x27;Someone visit our web server.&#x27;)&#125;)server.listen(8080, function () &#123; console.log(&#x27;服务器启动了，运行在http://127.0.0.1:8080&#x27;)&#125;) req请求对象属性 描述 req.url 客户端请求的url地址 req.method 客户端请求方式 req.session 访问和使用session对象，需要配置express-session中间件 req.session.destroy() 清空session对象 res响应对象属性 描述 res.end() 向客户端响应内容 res.writeHead(200, { “Content-Type”: “text&#x2F;html; charset&#x3D;utf-8” }) 写入响应头 res.setHeader(“Content-Type”,”text&#x2F;html; charset&#x3D;utf-8”) 设置响应头的内容类型，解决中文乱码 模块化模块作用域自定义模块中定义的方法、变量等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。 module对象在每一个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息 module.exports可以将模块内的成员共享出去，供外界使用。外界用require()方法导入自定义模块时，得到的就是module.exports所指向的对象（也可写成exports） npm命令 npm init -y：新建包管理配置文件 npm uninstall：卸载包 npm install -D：安装包到开发环境中，这些包只在项目开发环境中用到，如sass,记录在devDependencies节点中 npm install：安装到开发和生产环境中，记录在dependencies节点中 npm install -g：安装为全局包 Express封装的http模块 安装1npm i express 创建基本的Web服务器1234567891011121314//1.导入 expressconst express = require(&#x27;express&#x27;)//2.创建 web 服务器const app = express()app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#123; name: &#x27;hzx&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)&#125;)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#x27;请求成功&#x27;)&#125;)//3. 启动 web 服务器app.listen(80, () =&gt; &#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 获取请求参数req.query 通过?匹配到的参数 req.params 通过:匹配到的动态参数 req.body 请求体数据，需要调用express.json()和express.urlencoded({extended:false})中间件 托管静态资源app.use(express.static(‘public’)) 如果要托管多个静态资源目录，多次调用express.static()函数，访问静态资源函数时，根据目录的添加顺序查找所需的文件 挂载路径前缀：app.use(“&#x2F;public”,express.static(‘public’)) nodemonnodemon能够监听项目文件的变动，当代码被修改后，nodemon会自动帮我们重启项目。 安装npm install -g nodemon 使用nodemon test.js 路由Express中的路由分3部分组成，分别是请求的类型、请求的URL地址、处理函数 1app.METHOD(PATH,HANDLER(req,res)) 模块化路由为了方便对路由进行模块化的管理，推荐将路由抽离为单独的模块 创建路由模块对应的.js文件 调用express.Router()函数创建路由对象 向路由对象上挂载具体的路由 module.exports向外共享路由对象 使用app.use()函数注册路由模块 示例代码12345678910//router.jsconst express = require(&#x27;express&#x27;)const router = express.Router()router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Get user list.&#x27;)&#125;)router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Add new user.&#x27;)&#125;)module.exports = router 12345678910111213//index.js//1.导入 expressconst express = require(&#x27;express&#x27;)//2.创建 web 服务器const app = express()//注册路由模块const router = require(&#x27;./router&#x27;)app.use(router)//3. 启动 web 服务器app.listen(80, () =&gt; &#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 中间件作用：对请求进行预处理 中间件的格式123app.get(&#x27;/&#x27;,function(req,res,next)&#123;next()//把流转关系转交给下一个中间件或者路由&#125;) 全局生效的中间件123456789101112const app = express()const mw = function (req,res,next)&#123; console.log(&#x27;这是最简单的中间件函数&#x27;) next()&#125;app.use(mw)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&quot;User Page&quot;)&#125;) 局部生效的中间件12345678const app = express()const mw = function (req,res,next)&#123; console.log(&#x27;这是最简单的中间件函数&#x27;) next()&#125;app.get(&#x27;/&#x27;,mw,(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;) 多个局部生效的中间件123456app.get(&#x27;/&#x27;,mw1,mw2,(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;)app.get(&#x27;/&#x27;,[mw1,mw2],(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;) 注意事项 在路由之前注册中间件 客户端发送的请求，可以连续调用多个中间件进行处理 执行完中间件后，要调用next()函数 调用next()函数后，不要再写业务逻辑 多个中间件共享req、res对象 中间件的分类 应用级别：app.use(),app.get(),app.post() 路由级别：绑定在express.Router()实例上 错误级别：function处理函数中必须有4个形参，分别是(err,req,res,next)。必须注册在所有路由之后！ Express内置 express.static快速托管静态资源的内置中间件 express.json解析JSON格式的请求体数据 12345app.use(express.json())app.post(&#x27;/user&#x27;, function (req, res) &#123; console.log(req.body) res.send(&#x27;ok&#x27;)&#125;) express.urlencoded({extended:false})解析URL-encoded格式的请求体数据 第三方 1234567891011121314151617//定义中间件const bodyParser = (req, res, next) =&gt; &#123; let str = &#x27;&#x27; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; str += chunk &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; req.body = querystring.parse(str) &#125;) next()&#125;module.exports = bodyParser------------------------------------//使用中间件const bodyParser = require(&#x27;./bodyParser&#x27;)app.use(bodyParser) 基于CORS解决跨域问题安装1npm install cors 导入并配置12const cors = require(&#x27;cors&#x27;)app.use(cors()) 注意：先配置cors（跨域资源共享）再配置路由 原理：CORS由一系列HTTP响应头组成，这些响应头决定浏览器是否阻止前端JS代码跨域获取资源。浏览器的同源安全策略（协议、ip地址、端口号必须相同）默认会阻止网页”跨域“获取资源。但是如果接口服务器配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制。 CORS响应头部 描述 res.setHeader(‘Access-Control-Allow-Origin’,’*’) 设置允许访问该资源的外域URL res.setHeader(‘Access-Control-Allow-Headers’,’X-Custom-Header’) 对额外的请求头进行声明 res.setHeader(‘Access-Control-Allow-Methods’,’*’) 设置实际请求所允许使用的HTTP方法 预检请求只要符合以下任何条件之一，都需要进行预检请求： 请求方式为GET、POST、HEAD之外的请求Method类型 请求头中包含自定义头部字段 向服务器发送了application&#x2F;json格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求，所以这一次的OPTION请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并携带真实数据。 JSONP接口浏览器通过&lt;script&gt;标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP JSONP不属于真正的Ajax请求，没有使用XMLHttpRequest这个对象。JSONP仅支持GET请求，不支持POST、PUT、DELETE请求。 JSONP接口要声明在CORS接口之前 操作MySQL 安装mysql2模块 1npm i mysql2 配置mysql模块 1234567const mysql = require(&#x27;mysql2&#x27;)const db = mysql.createPool(&#123; host: &#x27;127.0.0.1&#x27;, user: &#x27;root&#x27;, password: &#x27;123456&#x27;, database: &#x27;my_db_01&#x27;&#125;) 测试mysql模块是否正常工作 1234db.query(&#x27;SELECT 1&#x27;,(err,results)=&gt;&#123;if(err) return console.log(err.message)console.log(results)&#125;) xxxxxxxxxx import create from ‘zustand’​&#x2F;&#x2F; 导入核心方法import { mountStoreDevtool } from ‘simple-zustand-devtools’​&#x2F;&#x2F; 省略部分代码…​​&#x2F;&#x2F; 开发环境开启调试if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; ‘development’) { mountStoreDevtool(‘channelStore’, useChannelStore)}​​export default useChannelStorejavascript123456789101112131415const user = &#123; username:&#x27;spider-man&#x27;, password:&#x27;pcc123&#x27;&#125;const sqlStr = &#x27;insert into users (username,password) values (?,?)&#x27;db.query(sqlStr,[user.username,user.password],(err,results)=&gt;&#123; if(err) return console.log(err.message) //insert into 的返回结果为对象,select 的结果为数组 if(results.affectedRows === 1) console.log(&#x27;数据插入成功！&#x27;)&#125;)//若对象的属性值与数据表的字段一一对应const sqlStr = &#x27;insert into users set ?&#x27;db.query(sqlStr, user, (err, results) =&gt; &#123; if (err) return console.log(err.message) if (results.affectedRows === 1) console.log(&#x27;数据插入成功！&#x27;)&#125;) 12345678910111213141516const user = &#123; id: 5, username: &#x27;aaa&#x27;, password: &#x27;000123&#x27; &#125;const sqlStr = &#x27;update users set username=?,password=? where id=?&#x27;db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; &#123; if (err) return console.log(err.message) //update 的返回结果为对象 if (results.affectedRows === 1) console.log(&#x27;数据修改成功！&#x27;)&#125;)//若对象的属性值与数据表的字段一一对应const sqlStr = &#x27;update users set ? where id=?&#x27;db.query(sqlStr, [user, user.id], (err, results) =&gt; &#123; if (err) return console.log(err.message) //update 的返回结果为对象 if (results.affectedRows === 1) console.log(&#x27;数据修改成功！&#x27;)&#125;) 123456const sqlStr = &#x27;delete from users where id=?&#x27;db.query(sqlStr, 5, (err, results) =&gt; &#123; if (err) return console.log(err.message) //update 的返回结果为对象 if (results.affectedRows === 1) console.log(&#x27;数据删除成功！&#x27;)&#125;) 前后端的身份认证Session认证机制http的无状态性客户端的每次HTTP请求都是独立的，服务器不会主动保留每次HTTP请求的状态 突破http的无状态性设置cookie CookieCookie是存储在用户浏览器中一段不超过4KB的字符串。它由一个名称、一个值和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。 客户端第一次请求服务器时，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie。当客户端每次请求服务器时，浏览器自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。 使用1npm install express-session 12345678const express = require(&#x27;express&#x27;)const session = require(&#x27;express-session&#x27;)const app = express()app.use(session(&#123; secret: &#x27;keyboard cat&#x27;,//可以为任意字符串 resave: false, saveUninitialized: true&#125;)) JWT认证机制session不支持跨域访问，当前端请求后端接口不跨域时，推荐使用session。当前端请求后端接口跨域时，推荐使用JWT（JSON Web Token) JWT组成成分Header.Payload.Signature Payload是真正的用户信息，是用户信息经过加密后生成的字符串 Header和Signature是安全性相关的部分，只是为了保证Token的安全性 JWT使用方式客户端收到服务器返回的JWT后，通常将它存储在localStorage和sessionStorage中 客户端把JWT放在HTTP请求头的Authorization字段中，此后每次通信都要带上这个JWT的字符串，格式如下 1Authorization: Bear &lt;token&gt; 安装及使用1npm install jsonwebtoken express-jwt 1234567891011121314151617181920212223// 1.导入用于生成JWT字符串的包const jwt = require(&#x27;jsonwebtoken&#x27;)// 2.导入将JWT字符串还原成JSON对象的包const &#123;expressjwt&#125; = require(&#x27;express-jwt&#x27;)//错误级别的中间件app.use((err, req, res, next) =&gt; &#123; //token解析失败 if (err.name === &quot;UnauthorizedError&quot;) &#123; return res.send(&#123; status: 401, message: &quot;无效的token&quot;, &#125;) &#125; res.send(&#123; status: 500, message: &quot;服务端错误&quot;, &#125;)&#125;)//.unless(&#123;&#125;)用来指定哪一些接口不需要访问权限，以下匹配/api/开头的路径const secretKey = &#x27;Sherlock Holmes ^_^&#x27;app.use(expressjwt(&#123;secret:secretKey,algorithms:[&#x27;HS256&#x27;]&#125;).unless(&#123;path:[/^\\/api\\//]&#125;)) 123456789//登录获取tokenapp.post(&#x27;/api/login&#x27;,function(req,res)&#123; res.send(&#123; status:200, message:&#x27;登录成功！&#x27;, //参数1：用户的信息对象，参数2：加密的密钥，参数3：配置对象：可以配置当前token的有效期 token:jwt.sign(&#123;username:userinfo.username&#125;,secretKey,&#123;expiresIn:&#x27;30s&#x27;&#125;) &#125;)&#125;) 12345678app.get(&#x27;/admin/getinfo&#x27;, function (req, res) &#123; res.send(&#123; status: 200, message: &quot;获取用户信息成功!&quot;, data: req.auth &#125;)&#125;) 密码加密1npm i bcryptjs 加密存储密码： 123456var bcrypt = require(&#x27;bcryptjs&#x27;);//生成随机盐var salt = bcrypt.genSaltSync(10);//生成加密密码var hash = bcrypt.hashSync(&quot;B4c0/\\/&quot;, salt);// 存入数据库 检测密码： 123// 从数据库中获取加密密码bcrypt.compareSync(&quot;B4c0/\\/&quot;, hash); // truebcrypt.compareSync(&quot;not_bacon&quot;, hash); // false 自动生成随机盐和哈希值: 12// bcrypt.hashSync(明文密码，随机盐的长度)var hash = bcrypt.hashSync(&#x27;bacon&#x27;, 8);","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://example.com/tags/node-js/"}]},{"title":"设计模式","slug":"设计模式","date":"2024-10-11T16:00:44.000Z","updated":"2024-12-21T03:15:22.704Z","comments":true,"path":"2024/10/12/设计模式/","permalink":"http://example.com/2024/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式的分类 模式 &amp; 描述 包括 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 结构型模式 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 行为型模式 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 设计模式工厂模式表现形式调用工厂函数返回新对象 使用场景 Vue3-createApp：将全局改变Vue实例的行为，移到Vue实例上 axios-create：基于自定义配置新建实例 单例模式表现形式整个系统只有一个单例对象 使用场景vant中的toast和notify组件 vue中的use方法 观察者模式表现形式在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知 使用场景addEventListener vue中的watch react中的useEffect 发布订阅模式表现形式与观察者模式相似，有中间商进行发布订阅 使用场景pubsub.js vue的provide与inject 原型模式表现形式复制一个已经存在的实例来返回新的实例，而不是新建实例 使用场景Object.create() vue的数组方法重写 代理模式表现形式为一个对象提供一个代用品或占位符，以便控制对它的访问 使用场景缓存代理：第一次查询的数据通过接口获取，重复查询通过缓存获取 迭代器模式表现形式遍历容器中的每一个元素 使用场景for in 和 for of 区别： for in 遍历的是索引，继承而来的也可以遍历 for of 遍历的是值，继承而来的无法遍历，无法遍历对象 可迭代对象：实现迭代协议","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"}]},{"title":"linux","slug":"linux","date":"2024-10-11T15:25:06.000Z","updated":"2024-10-14T08:47:45.124Z","comments":true,"path":"2024/10/11/linux/","permalink":"http://example.com/2024/10/11/linux/","excerpt":"","text":"linux常用命令处理目录的常用命令 ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称 可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 ls (列出目录)语法： 123[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) 1[root@www ~]# ls -al ~ ~为根目录 cd (切换目录)cd是Change Directory的缩写，这是用来变换工作目录的命令。 pwd (显示目前所在的目录)pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 1[root@www ~]# pwd [-P] 选项与参数： -P ：显示出确实的路径，而非使用链接 (link) 路径。 mkdir (创建新目录)语法： 1mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 123456[root@www ~]# cd /tmp[root@www tmp]# mkdir test &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！ 实例：创建权限为 rwx–x–x 的目录。 12345[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。 如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。 rmdir (删除空的目录)语法： 1rmdir [-p] 目录名称 选项与参数： -p ：从该目录起，一次删除多级空目录 删除 runoob 目录 1[root@www tmp]# rmdir runoob/ 将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！ 12345678910[root@www tmp]# ls -l &lt;==看看有多少目录存在？drwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1 &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#x27;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。 要注意的是，这个 rmdir 仅能删除空的目录，可以使用 rm 命令来删除非空目录。 cp (复制文件或目录)cp 即拷贝文件和目录。 语法: 12[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式链接(hard link)的链接档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用于目录的复制行为；(常用) -s：复制成为符号链接档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc 123[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#x27;? n &lt;==n不覆盖，y为覆盖 rm (移除文件或目录)语法： 1rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ mv (移动文件与目录，或修改名称)语法： 12[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 复制一文件，创建一目录，将文件移动到目录中 1234[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest 查看文件cat由第一行开始显示文件内容 语法： 1cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 检看 &#x2F;etc&#x2F;issue 这个文件的内容： 123[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \\r on an \\m 创建文件touchtouch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 语法1touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…] 参数说明： a 改变档案的读取时间记录。 m 改变档案的修改时间记录。 c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。 f 不使用，是为了与其他 unix 系统的相容性而保留。 r 使用参考档的时间记录，与 –file 的效果一样。 d 设定时间与日期，可以使用各种不同的格式。 t 设定档案的时间记录，格式与 date 指令相同。 –no-create 不会建立新档案。 –help 列出指令格式。 –version 列出版本讯息。 vim","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"vue3-rabbit小兔鲜电商项目","slug":"vue3-rabbit小兔鲜电商项目","date":"2024-10-01T14:48:11.000Z","updated":"2025-04-08T09:37:01.063Z","comments":true,"path":"2024/10/01/vue3-rabbit小兔鲜电商项目/","permalink":"http://example.com/2024/10/01/vue3-rabbit%E5%B0%8F%E5%85%94%E9%B2%9C%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"创建项目并整理目录1npm init vue@latest 目录结构 文件夹 作用 apis 接口 assets 静态资源 components 通用组件 composables 组合函数 directives 全局指令 router 路由Router stores Pinia仓库 styles 全局样式文件夹 utils 工具函数 views 页面级组件 jsconfig.json配置别名路径1. 安装 Path Intellisense 插件安装一个名为 Path Intellisense 的插件，它可以帮助你在输入路径时自动补全。 2. 配置 jsconfig.json 或 tsconfig.json为了让 VSCode 能够识别 @ 作为 src 目录的别名，你需要在项目根目录下创建一个 jsconfig.json（适用于 JavaScript 项目）或 tsconfig.json（适用于 TypeScript 项目）文件。 对于 JavaScript 项目 (jsconfig.json):123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;]&#125; 对于 TypeScript 项目 (tsconfig.json):123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [&quot;src/*&quot;] &#125; &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;]&#125; 3. 配置 Path Intellisense为了让 Path Intellisense 插件能够识别 @ 别名，需要在 VSCode 的设置中进行配置。 打开 VSCode 的设置（Ctrl+, 或通过菜单 文件 &gt; 首选项 &gt; 设置）。 搜索 Path Intellisense。 找到 Path Intellisense: Mappings，点击 编辑 in settings.json。 在 settings.json 中添加以下配置： 12345&#123; &quot;path-intellisense.mappings&quot;: &#123; &quot;@&quot;: &quot;$&#123;workspaceFolder&#125;/src&quot; &#125;&#125; 完成上述配置后，重启 VSCode 以确保所有配置生效。 定制elementPlus主题安装sass 基于vite的项目默认不支持css预处理器，需要开发者单独安装 1npm i sass -D 准备定制化的样式文件12345678910111213141516171819202122232425/* 只需要重写你需要的即可 */@forward &#x27;element-plus/theme-chalk/src/common/var.scss&#x27; with ( $colors: ( &#x27;primary&#x27;: ( // 主色 &#x27;base&#x27;: #27ba9b, ), &#x27;success&#x27;: ( // 成功色 &#x27;base&#x27;: #1dc779, ), &#x27;warning&#x27;: ( // 警告色 &#x27;base&#x27;: #ffb302, ), &#x27;danger&#x27;: ( // 危险色 &#x27;base&#x27;: #e26237, ), &#x27;error&#x27;: ( // 错误色 &#x27;base&#x27;: #cf4444, ), )) 自动导入配置 这里自动导入需要深入到elementPlus的组件中，按照官方的配置文档来 自动导入定制化样式文件进行样式覆盖 按需定制主题配置 （需要安装 unplugin-element-plus） 1234567891011121314151617181920212223242526272829303132import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver(&#123;importStyle: &quot;sass&quot;&#125;)], &#125;), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;, css: &#123; preprocessorOptions: &#123; scss: &#123; // 自动导入定制化样式文件进行样式覆盖 additionalData: ` @use &quot;@/styles/element/index.scss&quot; as *; `, &#125; &#125; &#125;&#125;) Error Lens插件安装scss变量自动导入123456// src/styles/var.scss$xtxColor: #27ba9b;$helpColor: #e26237;$sucColor: #1dc779;$warnColor: #ffb302;$priceColor: #cf4444; 1234567891011css: &#123; preprocessorOptions: &#123; scss: &#123; // 自动导入scss文件 additionalData: ` @use &quot;@/styles/element/index.scss&quot; as *; @use &quot;@/styles/var.scss&quot; as *; `, &#125; &#125;&#125; 懒加载指令实现封装全局指令123456789101112131415161718192021import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;export const lazyPlugin = &#123; install(app) &#123; app.directive(&#x27;img-lazy&#x27;, &#123; mounted(el, binding) &#123; // el: 指令绑定的那个元素 img // binding: binding.value 指令等于号后面绑定的表达式的值 图片url const &#123; stop &#125; = useIntersectionObserver( el, ([&#123; isIntersecting &#125;]) =&gt; &#123; if (isIntersecting) &#123; el.src = binding.value stop() &#125; &#125;, ) &#125; &#125;) &#125;&#125; 注册全局指令123// 全局指令注册import &#123; lazyPlugin &#125; from &#x27;@/directives&#x27;app.use(lazyPlugin) 项目亮点路由缓存问题，即路由跳转时，页面没有更新什么是路由缓存问题：使用带有参数的路由时需要注意的是，当用户从／users／johnny 导航到／users／jolyne 时，相同的组件实例将被重复使用。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会被调用。 问题：一级分类的切换正好满足上面的条件，组件实例复用，导致分类数据无法更新 解决问题的思路： 让组件实例不复用，强制销毁重建 。 给router-view添加key属性 监听路由变化，变化之后执行数据更新操作。 当router更新时重新发送页面请求 onBeforeRouteUpdate((to)=&gt;&#123;getNavList(to.params.id)&#125;) 支付业务流程 定制路由滚动行为当切换路由时，页面自动滚动到顶部，在router文件中进行配置 12345678910const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [], // 路由行为的配置项 切换路由时自动滚回顶部 scrollBehavior()&#123; return &#123; top:0 &#125; &#125;&#125;) 在路由页面，使用导航守卫，配置路由跳转前后的行为主要实现以下几点： 1、配置页面跳转的loading动效 2、切换路由时自动滚回页面顶部 3、没有登录时，在地址栏输入url，不能直接跳转到相对应的页面 4、页面标题随着meta进行变化 12345678910111213141516171819import &#123; ElLoading &#125; from &#x27;element-plus&#x27;import &#x27;element-plus/theme-chalk/el-loading.css&#x27;// 跳转前router.beforeEach((to,from,next)=&gt;&#123; ElLoading.service(&#123; fullscreen: true, text: &#x27;Loading...&#x27; &#125;) window.scrollTo(0,0) next()&#125;)// 跳转后router.afterEach((to)=&gt;&#123; setTimeout(()=&gt;&#123; const loadingInstance = ElLoading.service() loadingInstance.close() &#125;,1000) document.title = to.meta.title || &#x27;my project&#x27;&#125;)","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"2024-9-30","slug":"2024-9-30","date":"2024-09-30T12:56:07.000Z","updated":"2024-10-09T16:09:43.468Z","comments":true,"path":"2024/09/30/2024-9-30/","permalink":"http://example.com/2024/09/30/2024-9-30/","excerpt":"","text":"😀😀 发财了发财了！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2024-09-28T03:21:13.000Z","updated":"2025-03-05T15:37:39.143Z","comments":true,"path":"2024/09/28/JavaScript/","permalink":"http://example.com/2024/09/28/JavaScript/","excerpt":"","text":"输入输出语句 prompt(info) alert(msg) console.log(msg) undefined与null undefined表示没有赋值，未定义数据类型 null表示值为空，空数据类型。如果一个变量里面确定存放的是对象，如果还没准备好对象，可以放一个null 类型转换隐式转换 +号两边只要有一个是字符串，都会把另外一个转成字符串 -，*，&#x2F;，%：字符串转数字型后计算 +作为正号解析可以转换成数字型 显示转换 +|Number()|parseInt()|parseFloat():转换为数字型 数组 方法&#x2F;属性 作用 arr.length 获取数组长度 arr.at() 接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。 arr.concat() 合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。可以用来拷贝数组 arr.every() 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。 arr.fill(element,i,j) 用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。 arr.filter() 创建给定数组一部分的浅拷贝，其包含通过所提供函数实现的测试的所有元素。 arr.find() 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 arr.findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回 -1。 arr.findLast() 反向迭代数组，并返回满足提供的测试函数的第一个元素的值。如果没有找到对应元素，则返回 undefined。 arr.findLastIndex() 反向迭代数组，并返回满足所提供的测试函数的第一个元素的索引。若没有找到对应元素，则返回 -1。 arr.flat(Infinity) 创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。 arr.forEach() 对数组的每个元素执行一次给定的函数。 arr.includes() 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 arr.indexOf() 返回数组中第一次出现给定元素的下标，如果不存在则返回 -1。 arr.join() 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，用逗号或指定的分隔符字符串分隔。 arr.findLastIndexOf(element,fromIndex) 返回数组中给定元素最后一次出现的索引，如果不存在则返回 -1。该方法从 fromIndex 开始向前搜索数组。 arr.map() 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 arr.pop() 数组中删除最后一个元素，并返回该元素的值。 arr.push() 将指定的元素添加到数组的末尾，并返回新的数组长度。 arr.reduce((pre,current)&#x3D;&gt;func,initial) 对数组中的每个元素按序执行一个提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 arr.reverse() 就地反转数组中的元素，并返回同一数组的引用。 arr.toReversed() 不改变原始数组的情况下反转数组中的元素。 arr.shift() 从数组中删除第一个元素，并返回该元素的值。 arr.slice(start,end) 返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。 arr.some() 测试数组中是否至少有一个元素通过了由提供的函数实现的测试。如果在数组中找到一个元素使得提供的函数返回 true，则返回 true；否则返回 false arr.sort((a,b)&#x3D;&gt;a-b) 就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。 arr.toSorted() 对数组的元素进行排序，不改变原数组，并返回新的数组。 arr.splice(splice(start, deleteCount, item1,……)) 就地移除或者替换已存在的元素和&#x2F;或添加新的元素。 arr.toSpliced() 创建一个删除和&#x2F;或替换部分内容而不改变原数组的新数组。 arr.unshift() 将指定元素添加到数组的开头，并返回数组的新长度。 对象 属性&#x2F;方法 描述 Object.keys(obj) 获得所有的属性名（数组） Object.values(obj) 获得所有的属性值（数组） Object.assign(copyObj,obj) 拷贝对象（浅拷贝）,常用以配置对象合并 Object.entries(obj) 返回对象的所有可枚举属性[key,value]数组 for(let key in obj) obj[key] 遍历对象 Math.random() 生成0-1之间的随机数 Math.ceil() 向上取整 Math.floor() 向下取整 Math.max() 找最大值 Math.min() 找最小值 Math.pow() 幂运算 Math.abs() 绝对值 Math.sign() 获取符号 date.getfullYear() 以四位数字返回年份。 date.getMonth() 返回月份 (0 ~ 11)。 date.getDate() 返回一个月中的某一天 (1 ~ 31)。 date.getDay() 返回一周中的某一天 (0 ~ 6)。 date.getHours() 返回小时 (0 ~ 23)。 date.getMinutes() 返回分钟 (0 ~ 59)。 date.getSeconds() 返回秒数 (0 ~ 59)。 date.getTime()|+new Date()|Date.now() 获取时间戳 str.length 字符串的长度 str.concat(s) 连接两个或更多字符串，并返回新的字符串 str.endsWith(s[,检测位置索引号]) 判断当前字符串是否是以指定的子字符串结尾的（区分大小写） str.indexOf(s) 返回某个指定的字符串值在字符串中首次出现的位置 str.lastIndexOf(s) 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 str.includes(s[,检测位置索引号]) 查找字符串中是否包含指定的子字符串 str.match(reg) 查找找到一个或多个正则表达式的匹配 str.split(‘分隔符’) 把字符串分割为字符串数组 str.substring(from,to) 提取字符串中两个指定的索引号[form,to)之间的字符 str.startsWith(s[,检测位置索引号]) 查看字符串是否以指定的子字符串开头 str.toLowerCase() 把字符串转换为小写 str.toUpperCase() 把字符串转换为大写 str.substr(startIndex,n) 从起始索引号提取字符串中指定数目的字符。 str.replace() 在字符串中查找匹配的子串，并替换与正则表达式匹配的子串 str.replaceAll() 在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串 str.search() 查找与正则表达式相匹配的值,返回匹配的起始位置 str.trim() 去除字符串两边的空白 Number.EPSILON JavaScript能表示的最小精度数 Number.isFinite() 检测是否为有限数 Number.isNaN() 检测是否为NaN Number.parseInt() 转化为整数 Number.parseFloat() 转化为浮点数 Number.isInteger() 判断是否为整数 正则表达式定义正则表达式1const reg = /表达式/修饰符 匹配字符 字符 描述 . 匹配任意字符，除了\\n、\\r abc 匹配对应的字符串 [abc] 查找方括号之间的任何字符 [^abc] 匹配除了括号内的字符以外的任意一个字符 [0-9] 查找任何从 0 至 9 的数字 (x|y) 查找任何以|分隔的选项，匹配不同模式 \\d 查找数字 \\s 查找空白字符,等于[\\t\\r\\n\\v\\f] \\w 匹配数字、字母、下划线，等价于[0-9a-zA-Z_] \\D \\S \\W 与对应的小写形式相反 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 ^ 匹配字符串的开头 $ 匹配字符串的结尾 量词 *：匹配前面的模式零次或一次或多次。 +：匹配前面的模式一次或多次。 ?：匹配前面的模式零次或一次。 &#123;n&#125;：匹配前面的模式恰好 n 次。 &#123;n,&#125;：匹配前面的模式至少 n 次。 &#123;n,m&#125;：匹配前面的模式至少 n 次且不超过 m 次。 分组和捕获 ( )：用于分组和捕获子表达式。 (?: )：用于分组但不捕获子表达式。 修饰符 i:执行对大小写不敏感的匹配。 g:全局匹配 m:多行匹配 匹配123456const reg = /she/string str = &#x27;sherlock-holmes&#x27;reg.test(str)//返回true|falsereg.exec(str)//返回数组|nullstr.replace(reg,&#x27;substitute&#x27;)str.search(reg) test() 方法用于检测一个字符串是否匹配某个模式。 exec() 方法用于检索字符串中的正则表达式的匹配。 search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。 DOM对象document对象 属性&#x2F;方法 描述 document.querySelector() 返回文档中匹配指定的CSS选择器的第一元素 document.querySelectorAll() 返回文档中匹配的CSS选择器的所有元素节点列表 document.write() 向文档写 HTML 表达式 或 JavaScript 代码 document.createElement() 创建元素节点。 document.body 返回文档的body元素 document.documentElement 返回文档的根节点 document.title 返回当前文档的标题 DOM元素对象 属性&#x2F;方法 描述 element.innerHTML 设置或者返回元素的内容（解析标签）。 element.innerText 设置或者返回元素的文字内容（不解析标签）。 element.style 设置或返回元素的样式属性。 element.src|title|value|type 设置或返回元素的源|标题|值|类型。 element.className 设置或返回元素的类名。 element.classList.add()|remove()|toggle() 追加类名|移除类名|切换类名 element.dataset 获取data-属性 element.addEventListener(‘事件类型’,Func，是否使用捕获机制)|on事件 添加事件 element.removeEventListener(‘事件类型’,Func，是否使用捕获机制) 解绑事件（匿名函数无法解绑） element.parentNode 返回元素的父节点 element.children 返回元素的子元素的集合 element.nextElementSibling 返回元素的下一个兄弟节点 element.previousElementSibling 返回元素的上一个兄弟节点 element.appendChild(ele) 为元素添加一个新的子元素 element.insertBefore(insertEle,ele) 现有的子元素之前插入一个新的子元素 element.cloneNode(false|true) 克隆某个元素,参数为true时，同时克隆子元素 element.removeChild(ele) 删除一个子元素 事件对象 属性&#x2F;方法 描述 e.target 返回触发此事件的元素（事件的目标节点）。 e.type 返回当前 Event 对象表示的事件的名称。 e.currentTarget 返回其事件监听器触发该事件的元素。 e.timeStamp 返回事件生成的日期和时间。 e.preventDefault() 通知浏览器不要执行与事件关联的默认动作。 e.stopPropagation() 阻止冒泡。 BOM对象 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 document、alert()、console都是window的属性和方法 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用时可以省略window location对象 属性&#x2F;方法 描述 location.href 返回完整的URL,可以用来跳转页面 location.hostname 返回URL的主机名 location.port 返回一个URL服务器使用的端口号 location.protocol 返回一个URL协议 location.search 返回一个URL的查询部分(?后部分) location.hash 返回一个URL的锚部分(#后部分) location.reload(true) 刷新页面 navigator对象12345678!(function()&#123; const userAgent = navigator.userAgent const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) if(android||iphone)&#123; location.href = &#x27;http://m.itcast.cn&#x27; &#125;&#125;)() history对象 属性方法 作用 history.length 返回历史列表中的网址数 history.back() 加载 history 列表中的前一个 URL history.forword() 加载 history 列表中的下一个 URL history.go(n) 加载 history 列表中的某个具体页面,正数前进、负数后退 localStorage对象 属性&#x2F;方法 描述 localStorage.length 返回存储对象中包含多少条数据 localStorage.key(n) 返回存储对象中第 n 个键的名称 localStorage.getItem(keyname) 返回指定键的值 localStorage.setItem(keyname,value) 添加键和值，如果对应的值存在，则更新该键对应的值 localStorage.removeItem(keyname) 移除键 localStorage.clear() 清除存储对象中所有的键 JSON.stringfy(复杂数据类型) JSON.parse(json数据) 定时器 const timer &#x3D; setInterval(function(){},ms) clearInterval(timer) const timer &#x3D; setTimeout(Func,ms) clearTimeout(timer) Base64转码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;input type=&quot;file&quot; id=&quot;fileInput&quot; /&gt;&lt;button id=&quot;downloadButton&quot; disabled&gt;Download Decoded File&lt;/button&gt;&lt;script&gt; let base64String = &#x27;&#x27;; // 1. 将文件转换为Base64 document.getElementById(&#x27;fileInput&#x27;).addEventListener(&#x27;change&#x27;, async (event) =&gt; &#123; const file = event.target.files[0]; if (file) &#123; const reader = new FileReader(); // 将 FileReader 包装为 Promise const readFile = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; reader.onloadstart = function (e) &#123; console.log(&#x27;开始上传&#x27;); &#125;; reader.onload = function (e) &#123; base64String = e.target.result.split(&#x27;,&#x27;)[1]; // 获取纯Base64部分 console.log(&#x27;Base64:&#x27;, base64String); resolve(); // 文件读取完成，解析 Promise &#125;; reader.onerror = function (e) &#123; reject(new Error(&#x27;文件读取失败&#x27;)); // 文件读取失败，拒绝 Promise &#125;; reader.readAsDataURL(file); // 开始读取文件 &#125;); &#125;; try &#123; await readFile(); // 等待文件读取完成 console.log(&#x27;加载完毕&#x27;); document.getElementById(&#x27;downloadButton&#x27;).disabled = false; // 启用下载按钮 &#125; catch (error) &#123; console.error(&#x27;文件读取失败:&#x27;, error); &#125; &#125; &#125;); // 2. 将Base64解码为文件并下载 document.getElementById(&#x27;downloadButton&#x27;).addEventListener(&#x27;click&#x27;, function() &#123; if (!base64String) &#123; console.error(&#x27;No Base64 data available.&#x27;); return; &#125; // 将Base64字符串解码为二进制数据 const binaryString = atob(base64String); const bytes = new Uint8Array(binaryString.length); for (let i = 0; i &lt; binaryString.length; i++) &#123; bytes[i] = binaryString.charCodeAt(i); &#125; // 创建Blob对象 const blob = new Blob([bytes], &#123; type: &#x27;application/octet-stream&#x27; &#125;); // 创建下载链接 const url = URL.createObjectURL(blob); const a = document.createElement(&#x27;a&#x27;); a.href = url; a.download = &#x27;decoded_file&#x27;; // 设置下载文件名 document.body.appendChild(a); a.click(); // 清理 document.body.removeChild(a); URL.revokeObjectURL(url); &#125;);&lt;/script&gt;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"2024-9-26","slug":"2024-9-26","date":"2024-09-26T14:20:07.000Z","updated":"2025-04-07T14:39:45.243Z","comments":true,"path":"2024/09/26/2024-9-26/","permalink":"http://example.com/2024/09/26/2024-9-26/","excerpt":"","text":"学生证发啦 学校里随机刷新的🐱学长 今天把css的基础课程看完了，做了一个名侦探柯南旋转海报的网页 名侦探柯南旋转海报","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"css","slug":"css","date":"2024-09-23T05:03:55.000Z","updated":"2025-05-23T15:22:41.500Z","comments":true,"path":"2024/09/23/css/","permalink":"http://example.com/2024/09/23/css/","excerpt":"","text":"通配符选择器1234* &#123; margin:0; padding:0;&#125; 字体属性 font-family:字体系列 font-size:字体大小 默认16px font-weight:字体粗细 normal|bold|bolder|lighter|number(默认400) font-style:字体样式 normal|italic font: font-style font-weight font-size&#x2F;line-height font-family; font-size:14px&#x2F;1.5 1.5倍行高 文本属性 color:文本颜色 text-align:对齐方式 left|center|right text-decoration:添加&#x2F;删除一条线none|underline|overline|line-through text-index:首行缩进 em为1个文字的大小 line-height:行间距 要比font-size大 text-shadow:h-shadow v-shadow blur color 复合选择器 div a 后代选择器 div&gt;a 子元素选择器 div,span 并集选择器 a:link|a:visited|a:hover|a:active 链接伪类选择器（LoVe HaTe顺序编写） input:focus focus伪类选择器 E:first-child E:last-child E:nth-child(n|even|odd|5n|n+3|-n+5) E:first-of-type E:last-of-type E:nth-of-type(n|even|odd|5n|n+3|-n+5) 显示模式 块元素 自己独占一行 高度、宽度、外边距、内边距都可以控制 默认宽度是父级宽度的100% （除了文字类块元素）里面可以放行内或块级元素 行内元素 相邻行内元素在一行上 设置宽高无效 默认宽度为内容宽度 行内元素只能容纳文本或者行内元素 行内块元素：&lt;img/&gt;&lt;input/&gt;&lt;td/&gt; 相邻行内块元素在一行上 默认宽度为内容宽度 高度、宽度、外边距、内边距都可以控制 显示模式切换： display:none|block|inline 设置居中 类别 居中方法 块级元素 margin-left:auto;margin-right auto; 行内元素 父级元素添加text-align:center; 行内块元素 父级元素添加text-align:center; 所有元素的垂直居中 line-height:height 行内块（图片）和文字居中对齐 vertical-align:middle background background-image:url() background-repeat:repeat|no-repeat|repeat-x|repeat-y background-attachment:scroll|fixed background-position: x y|left center right|top center down background-size:x y|x|cover|contain cover可能显示不全，contain可能无法完全覆盖而显示空白 background:bg-color bg-image position&#x2F;bg-size bg-repeat bg-origin bg-attachment; 默认值为 transparent none 0% 0%&#x2F;auto repeat padding-box scroll; 选择器优先级 选择器 选择器权重 继承或者* 0，0，0，0 元素选择器，伪元素选择器 0，0，0，1 类选择器，伪类选择器 0，0，1，0 ID选择器 0，1，0，0 行内样式 1，0，0，0 !important ∞ 边框 border-width:5px border-style:none|solid|dashed|dotted border-color: border-top|down|left|down: border-collapse:separate|collapse 控制边框合并 border-radius:圆角边框 border:border-width||border-style||border-color 盒子模型由内至外(均会影响盒子大小)： padding border margin：设置左右边距为auto居中盒子 盒子阴影 box-shadow: h-shadow v-shadow blur spread color inset; 嵌套块元素的塌陷问题对于两个父子关系的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷比较大的外边距值 解决方案： 为父元素定义上边框 为父元素定义内边距 为父元素添加overflow:hidden 传统网页布局方式 标准流 浮动：多个块级元素横向排列 定位 float:none|left|right 浮动特性 脱离标准流浮动到指定位置，不再保留原先位置 如果多个盒子设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列 浮动元素具有行内块元素特性 流程： 先用标准流的父元素排列上下位置，之后内部元素采取浮动排列左右位置 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 清除浮动父元素未指定高度，子元素全部浮动，导致父元素高度为0的问题，解决方法： 额外标签法 最后一个元素后添加块级元素清除浮动&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 父元素添加overflow:hidden|auto|scroll; 缺点：无法显示溢出部分 :after伪元素法 1234567.clearfix:after&#123; content:&quot;&quot;; display:block; height:0; clear:both; visibility:hidden;&#125; 父元素添加类名clearfix 双伪元素法 12345678.clearfix:before,.clearfix:after&#123; content:&quot;&quot;; display:table;&#125;.clearfix:after&#123; clear:both;&#125; 定位定位&#x3D;定位模式+边偏移 定位模式 position:static|relative|absolute|fixed|sticky 边偏移 top|bottom|left|right 静态定位默认方式，没有边偏移。 相对定位相对原来位置，原来的位置继续保留。 绝对定位相对最近一级祖先元素位置，若祖先元素无定位（静态定位）或无祖先元素，则相对浏览器。若要固定与祖先元素的某个位置，祖先元素应添加相对定位。原来的位置不保留。 固定定位固定于浏览器可视区的位置，不随滚动条滚动，原来的位置不保留，特殊的绝对定位。 粘性定位相对定位+固定定位 以浏览器窗口为参照点移动元素，占有原来位置。 定位叠放次序z-index:取值越大越靠上 定位的其他特性绝对定位和固定定位也和浮动类似。 行内元素添加绝对或者固定定位，可以直接设置宽度和高度。 块级元素添加绝对或者固定定位，不给宽度和高度，默认大小为内容的大小。 浮动、定位的盒子不会引起外边距合并的问题。 浮动的元素不会压住下面标准流的文字（可以用来做文字环绕），而绝对定位和固定定位会。 元素的显示与隐藏 display:none|block 不保留位置 visibility:hidden|visible 保留位置 overflow:visible|auto|hidden|scroll （内容溢出元素框时，会发生什么。有定位的盒子慎用） 精灵图将小背景图片整合到一张大图中，减少服务器接收和发送请求的次数，提高页面加载速度 background-position: -x -y; 字体图标 文件小 放大缩小不失真 灵活，可以改变颜色、产生阴影、透明效果、旋转等 iconfont-阿里巴巴矢量图标库 三角形123456.box&#123; width:0; height:0; border:50px solid transparent; border-left-color:pink;//朝右的三角形&#125; 鼠标样式&amp;表单轮廓线&amp;f防止拖拽文本域cursor:default|pointer|move|text|no-allowed outline:none textarea{ ​ resize:none; } 行内块和文字垂直居中对齐image{ ​ vertical-align:top|bottom|middle 可以解决图片底部默认空白的问题 } 文字省略号显示1234div &#123; white-space:norap; text-overflow:ellipsis;&#125; 视频&#x2F;音频播放器12&lt;video src=&quot;&quot; autoplay=&quot;autoplay&quot; muted=&quot;muted&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; poster=&quot;&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot;&gt;&lt;/audio&gt; 属性选择器 选择符 简介 E[att&#x3D;”val”] 选择具有att属性的E元素 E[att&#x3D;”val”]] 选择具有att属性且属性值等于val的E元素 E[att^&#x3D;”val”]] 选择具有att属性且值以val开头的E元素 E[att$&#x3D;”val”]] 选择具有att属性且值以val结尾的E元素 E[att*&#x3D;”val”]] 选择具有att属性且值中含有val的E元素 伪元素选择器 before和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法： element::before{} before和after必须有content属性 before在父元素内容前面创建元素，after在父元素内容后面插入元素 伪元素选择器与标签选择器权重一样 切换盒子模型 box-sizing:content-box 盒子大小为width+padding+border box-sizing:border-box 盒子大小为width CSS3过度鼠标悬浮时触发 transition:要过度的属性 花费时间(2s) 运动曲线(ease|liner) 何时开始(1s),要过度的属性 花费时间(2s) 运动曲线(ease) 何时开始(1s)； 全部变化，填all 2D转换 tranform:translate(x,y); tranform:translateX(x); tranform:translateY(y); transform:rotate(45deg); transform:scale(x,y) transform-origin: x y; 设置中心点 3D转换 transform:translate3d(x,y,z); tranform:translateX(x); tranform:translateY(y); transform:translateZ(z); perspective: px; &#x2F;&#x2F;透视写在观察元素的父元素上 transform-style:preserve-3d; &#x2F;&#x2F;子元素开启立体空间 动画 定义动画 12345678@keyframes move &#123; 0%(from) &#123; transform: translate(0px); &#125; 100%(to) &#123; transform: translate(100px); &#125;&#125; 调用动画 1animation: name duration timing-function delay iteration-count(1|infinite) direction(normal|alternate) fill-mode(backwords|forwords); 移动端常见布局 单独制作移动端页面 流式布局(百分比布局) flex弹性布局 less+rem+媒体查询布局 混合布局 响应式页面兼容移动端 媒体查询 bootstrap 流式布局 max-width: px;&#x2F;&#x2F;页面拉抻最大宽度 min-width: px;&#x2F;&#x2F;页面拉抻最小宽度 width:x% flex布局与浮动效果相似,但默认不换行，装不下时自动缩小子元素宽度 给父元素添加 display:flex; 给子元素设置宽高或分配比例 flex:1; 父元素属性 flex-direction:row|row-reverse|column|column-reverse 设置主轴 justify-content:flex-start|flex-end|center|space-around|space-between 设置主轴子元素排列方式 flex-wrap:nowrap|wrap 是否换行 align-items:flex-start|flex-end|center|stretch 设置侧轴子元素排列方式(单行) align-content:flex-start|flex-end|center|space-around|space-between|stretch 设置侧轴子元素排列方式(多行) flex-flow: flex-direction flex-wrap; 子元素属性 flex: 分配比例，可实现拉伸效果 align-self: 控制自己在侧轴的排列方式 order: 控制项目的排列顺序，越小越靠前，默认为0 rem适配方案通过修改html里面的文字大小来改变页面中元素的大小 媒体查询1234567891011121314151617181920212223//从小到大写，后面覆盖前面 &lt;link rel=&quot;stylesheet&quot; href=&quot;style320.css&quot; media=&quot;screen and (max-width:320px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style640.css&quot; media=&quot;screen and (min-width:640px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style960.css&quot; media=&quot;screen and (min-width:960px)&quot;&gt;//或@media screen and (max-width:539px) &#123; html&#123; &#125;&#125;@media screen and (min-width:540px) &#123; html &#123; &#125;&#125;@media screen and (min-width:970px) &#123; html &#123; &#125;&#125; lessvscode插件：easy less，cssrem 基本语法 @变量名:变量值 后代——嵌套 伪类&#x2F;伪元素选择器 &amp;: &amp;:: 运算符+-*&#x2F; 空格隔开 除法运算要加 () 单位不同则取第一个值的单位 @import “” 导入less文件 元素大小取值方法页面元素的rem值&#x3D;页面元素值（px)&#x2F;font-size字体大小","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"面试八股","slug":"面试八股","date":"2024-09-21T12:28:26.000Z","updated":"2025-05-28T15:04:38.219Z","comments":true,"path":"2024/09/21/面试八股/","permalink":"http://example.com/2024/09/21/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/","excerpt":"","text":"面试八股HTTP请求&#x2F;响应的步骤 用户在浏览器地址栏输入URL,URL由协议、域名、端口号、文件路径组成，没有文件路径的时候，就会访问根目录下的默认文件，例如index.html 浏览器检查本地缓存是否有该域名对应的IP地址。如果缓存中没有，浏览器会通过递归方式请求本地DNS服务器、本地DNS服务器通过迭代方式请求根域名服务器、顶级域名服务器、权威域名服务器等，最终将IP地址返回给客户端，这个过程中浏览器、操作系统、各级DNS服务器都会先查看本地缓存，没有记录再去查询 浏览器通过IP地址和端口号与服务器建立TCP连接。也就是”三次握手“过程，如果是HTTPS协议，还会进行TLS&#x2F;SSL握手，确保通信安全。 浏览器向服务器发送HTTP请求，请求头中包含浏览器信息、支持的编码格式、Cookie等。服务器接收到请求后，根据路径和参数处理请求，生成响应内容。 服务器将响应数据和HTTP状态码返回给浏览器。响应头中包含内容类型、缓存策略等信息。 览器接收到响应后，开始解析HTML文件。解析过程中，浏览器会加载HTML中的CSS、JavaScript、图片等资源。浏览器构建DOM树、CSSOM树，合并生成渲染树，最后进行布局和绘制，将页面显示在屏幕上。 当所有资源加载完毕，页面完全渲染后，浏览器触发load事件，页面加载完成。 TCP连接关闭（四次挥手） HTTP 的 5 种方法GET—获取资源POST—传输资源PUT—更新资源DELETE—删除资源HEAD—获取报文首部 POST请求和GET请求 GET传递的参数在url后拼接，不安全。POST传递的参数在request body中，更安全。 GET对数据进行查询，POST主要对数据进行增删改！ GET在浏览器回退时是无害的，而POST会再次提交请求 GET请求会被浏览器主动缓存，POST不会，要手动设置 GET请求长度有限制，POST没有 cookie、localStorage、sessionStorage区别 相同：在本地（浏览器端）存储数据 不同： cookie同域名共享；localStorage要在相同的协议、域名、端口号下；sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，还要求在同一窗口（也就是浏览器的标签页）下。 localStorage是永久存储，除非手动删除；sessionStorage当会话结束（当前页面关闭的时候，自动销毁）；cookie可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁 cookie的数据会在每一次发送http请求的时候，同时发送给服务器而localStorage、sessionStorage不会。 sessionStorage和localStorage的存储比cookie大得多 HTTP状态码及常见状态码HTTP状态码• 1xx：指示信息类，表示请求已接受，继续处理• 2xx：指示成功类，表示请求已成功接受• 3xx：指示重定向，表示要完成请求必须进行更近一步的操作• 4xx：指示客户端错误，请求有语法错误或请求无法实现• 5xx：指示服务器错误，服务器未能实现合法的请求 常见状态码• 200 OK：客户端请求成功• 301 Moved Permanently：所请求的页面已经永久重定向至新的URL• 302 Found：所请求的页面已经临时重定向至新的URL• 304 Not Modified 未修改• 403 Forbidden：对请求页面的访问被禁止• 404 Not Found：请求资源不存在• 500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用• 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常 MVVMMVVM是一种软件架构模式，是Model、View、ViewModel的缩写。其中Model是数据层，包含数据和业务逻辑。View是UI组件。ViewModel是连接Model和View的桥梁，它一边管理数据，一边控制视图更新。 进程和线程进程是是系统进行资源分配的基本单位，线程是CPU调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源，每个线程拥有独立的栈和寄存器。进程之间相互独立，每个进程拥有自己的地址空间和系统资源，多个线程共享所属进程的资源。线程不拥有自己独立的地址空间，所以切换较快。进程之间有进程间通信机制，如共享存储、消息队列、管道等。线程可以直接访问同一进程的全局变量，通信成本较低。创建和切换进程的开销更大。一个进程崩溃不会影响其他进程，而一个线程崩溃，可能会导致整个进程崩溃。 面向对象和面向过程有什么区别，JavaScript是哪一种面向对象以对象为基本单元，数据和方法绑定在对象中。强调封装继承多态。 面向过程以函数为基本单元，数据和方法分离，通过函数和流程控制组织代码。 JavaScript属于面向对象的语言，两种范式都支持。 什么是模块化设计将代码拆分为独立的、功能单一的模块，每个模块负责特定功能，通过明确的接口与其他模块通信。减少代码耦合，提高可维护性和复用性。 两种规范 CommonJS Node.js默认 ES Modules 原生浏览器支持 什么是组件化开发将UI界面拆分为独立的、可复用的组件，每个组件包含自身的结构（HTML）、样式（CSS）和逻辑（JS）。 提高代码的复用性，隔离性，组合性。 Vue和React有什么区别，有什么相同不同： 模板语法：React采用JSX，Vue采用基于HTML的模板语法 数据绑定：Vue实现了双向的数据绑定，React需要手动控制组件的属性和状态 状态管理：Vue采用Vuex&#x2F;Pinia，React使用Redux 组件通信不同：Vue采用props和事件来实现父子组件通信，React采用props和回调函数实现 生命周期不同：Vue有8个生命周期钩子，React有10个 响应式原理不同：Vue使用双向数据绑定来实现数据更新，React使用单向数据流来实现 相同： Vue 和 React 都采用了组件化开发的方式。 Vue 和 React 都使用虚拟 DOM 技术。 Vue 和 React 都支持响应式更新。 Vue 和 React 都具有良好的集成能力。 生命周期函数组件从创建到销毁的一些钩子函数 vue3 setup() onBeforemount() onMounted() onBeforeUpdate() onUpdated() onBeforeUnMount() onUnMounted() React constructor() useState() render() 函数本身 componentDidMount() useEffect() getDerivedStateFromProps() useState()返回的setState()函数 shouldComponentUpdate() useMemo() getSnapshotBeforeUpdate() componentDidUpdate() useEffect() componentWillUnmount() useEffect()的返回函数 闭包 函数可以捕获外部作用域的变量，即使在定义的外部作用域之外被调用。 在函数外部无法读取函数内的局部变量。出于种种原因，我们有时候需要得到函数内的局部变量。那就是在函数的内部，再定义一个函数，利用内层函数来获取外层函数的局部变量。常用于模块化编程和数据封装。 闭包可能会引起内存泄漏和性能问题 防抖节流防抖和节流都是前端限制函数触发频率的技术。 防抖：函数触发后的一段时间内，不再触发事件时，才执行一次。应用：搜索栏搜索历史、浏览器窗口大小调整引起的页面变化 节流：函数触发后的一段时间内，保证只触发这一次。应用：无限滚动列表加载数据、表单提交。 箭头函数和普通函数的区别 普通函数有自己的this，由调用方式决定。对象调用指向调用，new调用指向实例；箭头函数没有自己的this，继承外部作用域的this 箭头函数不能作为构造函数，普通函数可以 箭头函数有简洁语法，函数体只有一个表达式的时候，可以省略大括号和return 普通函数可以访问隐式的arguments对象，它包含传递给函数的所有参数，而箭头函数没有 webpack构建过程 初始化配置项 config.js 解析依赖：模块之间的依赖关系 模块转化 ：vue文件，jsx文件等解析为对应和html、css、js文件 优化：消除未使用的代码块、代码分割、代码压缩。 输出：将优化后的代码输出到指定目录中 Vite 和 Webpack的区别vite的优势：基于原生ESModules,启动和热更新快。 webpack的优势：功能更全面更加灵活，生态更好，适合复杂的项目。 Vite 之所以在启动和热更新快的原因 Vite 直接基于浏览器的原生 ESM 功能，无需打包启动，在浏览器请求时按需编译。启动时使用 esbuild将第三方依赖预编译为 ESM 格式并缓存，后续启动直接使用缓存。更新时仅替换修改的模块及其依赖链，无需重建整个 bundle。 Vite生产环境使用rolluprollup是js模块打包工具，将分散的ESM代码高效打包为少数几个优化后的文件。它的核心优势就是使用Tree-shaking进行优化： 从入口文件出发，静态分析所有 import&#x2F;export 语句，构建依赖关系图。 遍历依赖图，标记哪些 export 被其他模块 import 并使用。 将标记为未使用的代码从最终 Bundle 中移除。生成扁平化的 Bundle（合并作用域、变量名压缩等）。 跨域跨域是指在浏览器中，当一个网页的脚本试图获取另一个源的资源的时候，由于同源策略限制协议域名端口号必须相同，可能会被浏览器阻止。解决方法CORS，JSONP，开发时正向代理（dev-server）、部署时反向代理（nginx）、WebSocket 正向代理和反向代理正向代理代理客户端，目标服务器只能看到代理的IP，无法知道真实客户端的身份，可以用来做科学上网、爬虫、缓存加速。 反向代理代理服务器端，客户端以为反向代理就是真实的服务器，不知道后端服务器的存在。可以用来做CDN、负载均衡、隐藏服务器架构 浏览器渲染流程 解析HTML和CSS生成DOM树和CSSOM树 将两棵树合并成渲染树 布局计算和绘制生成像素 合成显示 重排和重绘重排：DOM结构发生改变以及元素的几何属性发生变化时，重新计算元素的位置和尺寸 重绘：元素的外观发生改变但不影响布局的时候，重新绘制元素 重排的渲染消耗更大，频繁的重排和重绘都会影响页面性能。 面对瞬时的并发请求，如何减少后端请求压力 请求合并成一个请求 数据缓存 懒加载 WebSocket实时数据推送 防抖和节流 UDP和TCP的区别、使用场景、如何让UDP变得可靠UDP和TCP都是计算机网络传输层的协议，UDP是无连接、不可靠的，TCP是有链接、可靠的。UDP适合数据量小、需要实时传输、丢失数据可容忍的场景，如音视频传输、在线游戏。TCP适合于需要数据完整性和顺序性的场景，如网页浏览、文件传输。可以在应用层实现重传机制、数据校验来保证UDP的可靠性。 前端路由的几种方式hash路由：利用URL中#后的哈希值变化不会引起路由跳转的特性。通过监听hashChange事件，读取hash值来实现。兼容性更好。 （最初是用来做锚点定位，滚动到页面的指定位置的） history路由：利用history API修改URL路径并通过监听popState事件来监听浏览器前进后退。URL更简洁，使得服务器端可以解析完整路径 Vue的响应式原理vue2中是通过Object.defineProperty来实现的，在页面加载时，vue会使用Object.defineProperty来重新定义data中的所有属性，劫持各个属性的setter和getter，读取属性时触发getter方法，修改属性时触发setter方法，通知组件实例对应的watch方法实现视图的更新。 defineProperty也是有缺点的： 对于复杂对象需要深度监听、性能不好 对于对象的新增、删除属性无法监听这些操作。所以需要Vue.$set和Vue.$delete 需要重写数组的原生方法来实现数组监听 在vue3中使用proxy来替代defineProperty,它的优势： 可以直接监听整个对象、不需要遍历监听属性，性能有所提升。 可以直接监听数组的变化 拦截方法更多（13种） Vue2和Vue3有哪些区别 Vue2使用的是选项式API ，Vue3使用组合式API，提高代码可维护性和复用性。 Vue3使用Proxy代理替代Object.defineProperty实现了新的响应式系统，提高了性能。 Vue3引入了Teleport组件，可以将DOM元素渲染到DOM树的其他位置，用于创建模态框、弹出框等。 Vue3全局API名称发生了变化，同时新增了watchEffect、Hooks等功能 Vue3对TypeScript的支持更加友好 Vue3核心库的依赖更少，减少打包体积 reactive 对比 ref 都是用来生成响应式数据 不同点 reactive不能处理简单类型的数据 ref参数类型支持更好，但是必须通过.value做访问和修改 ref函数内部的实现依赖于reactive函数 VUE组件通信方式 父子组件：props和自定义事件 祖先组件和后代组件：provide和inject 父子组件：defineExpose Pinia SPA的理解，有什么优缺点SPA（单页应用）是一种前端应用程序的架构模式，它通过在加载应用程序时只加载单个 HTML 页面，并通过使用 JavaScript 动态地更新页面内容，从而实现无刷新的用户体验。 SPA和多页面有什么区别区别 页面加载方式：在多页面应用中，每个页面都是独立的 HTML 文件，每次导航时需要重新加载整个页面。而在 SPA 中，初始加载时只加载一个 HTML 页面，后续的导航通过 JavaScript 动态地更新页面内容，无需重新加载整个页面。 用户体验：SPA 提供了流畅、快速的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。 代码复用：SPA 通常采用组件化开发的方式，可以在不同的页面中复用组件，提高代码的可维护性和可扩展性。多页面应用的每个页面都是独立的，组件复用的机会较少。 路由管理：在多页面应用中，页面之间的导航和路由由服务器处理，每个页面对应一个不同的 URL。而在 SPA 中，前端负责管理页面的导航和路由，通过前端路由库（如 React Router 或 Vue Router）来管理不同路径对应的组件。 SEO（搜索引擎优化）：由于多页面应用的每个页面都是独立的 HTML 文件，搜索引擎可以直接索引和抓取每个页面的内容，有利于搜索引擎优化。相比之下，SPA 的内容是通过 JavaScript 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容，需要采取额外的优化措施。 服务器负载：SPA 只需初始加载时获取 HTML、CSS 和 JavaScript 文件，后续的页面更新和数据获取通常通过 API 请求完成，减轻了服务器的负载。而多页面应用每次导航都需要从服务器获取整个页面的内容。 优点 用户体验：SPA 提供了流畅、快速的用户体验，在页面加载后，只有需要的数据和资源会被加载，减少了页面刷新的延迟。 响应式交互：由于 SPA 依赖于异步数据加载和前端路由，可以实现实时更新和动态加载内容，使用户可以快速地与应用程序交互。 代码复用：SPA 通常采用组件化开发的方式，提高了代码的可维护性和可扩展性。 服务器负载较低：由于只有初始页面加载时需要从服务器获取 HTML、CSS 和 JavaScript 文件，减轻了服务器的负载。 缺点： 首次加载时间：SPA 首次加载时需要下载较大的 JavaScript 文件，这可能导致初始加载时间较长。 SEO（搜索引擎优化）问题：由于 SPA 的内容是通过 JavaScript 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容。 内存占用：SPA 在用户浏览应用程序时保持单个页面的状态，这可能导致较高的内存占用。 Vue的性能优化有哪些编码阶段 v-if和v-for不一起使用 v-for保证key的唯一性 使用keep-alive缓存组件 v-if和v-show酌情使用 路由懒加载、异步组件 图片懒加载 节流防抖 第三方模块按需引入 打包优化 压缩代码 使用CDN加载第三方模块 抽离公共文件 用户体验 骨架屏 客户端缓存 SEO优化 预渲染 服务端渲染 合理使用 meta 标签 常用的vue2属性、指令有哪些属性： data：用于定义组件的初始数据。 props：用于传递数据给子组件。 computed：用于定义计算属性。 methods：用于定义组件的方法。 watch：用于监听组件的数据变化。 components：用于注册子组件。可以通过 components 属性将其他组件注册为当前组件的子组件，从而在模板中使用这些子组件。 指令： v-if：条件渲染指令，根据表达式的真假来决定是否渲染元素。 v-show：条件显示指令，根据表达式的真假来决定元素的显示和隐藏。 v-for：列表渲染指令，用于根据数据源循环渲染元素列表。 v-bind：属性绑定指令，用于动态绑定元素属性到 Vue 实例的数据。 v-on：事件绑定指令，用于监听 DOM 事件，并执行对应的 Vue 方法。 v-model：双向数据绑定指令，用于在表单元素和 Vue 实例的数据之间建立双向绑定关系。 v-text：文本插值指令，用于将数据插入到元素的文本内容中。 v-html：HTML 插值指令，用于将数据作为 HTML 解析并插入到元素中。 Computed 和 Watch 的区别computed计算属性，通过对已有的属性值进行计算得到一个新值。它需要依赖于其他的数据，当数据发生变化时，computed会自动计算更新。computed属性值会被缓存，只有当依赖数据发生变化时才会重新计算，这样可以避免重复计算提高性能。 watch用于监听数据的变化，并在变化时执行一些操作。它可以监听单个数据或者数组，当数据发生变化时会执行对应的回调函数，和computed不同的是watch不会有缓存。 常见的事件修饰符及其作用 .stop阻止冒泡 .prevent阻止默认事件 .capture ：与事件冒泡的方向相反，事件捕获由外到内； .self ：只会触发自己范围内的事件，不包含子元素； .once：只会触发一次。 v-if和v-show的区别v-if条件渲染，v-show条件显示。v-if切换条件时会通过响应式系统销毁或渲染整个条件块，有更高的切换消耗，适用于初始不存在或不频繁切换可见性的组件； v-show通过设置元素display属性控制显示隐藏，更高的初始渲染消耗，适用于频繁切换可见性的组件。 v-html 的原理会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。 v-model 是如何实现的，语法糖实际是什么？ 当作用在表单上：通过v-bind:value绑定数据，v-on:input来监听数据变化并修改value 当作用在组件上：本质上是一个父子通信语法糖，通过props和$emit实现。 data为什么是一个函数而不是对象因为对象是一个引用类型，如果data是一个对象的情况下会造成多个组件共用一个data，data为一个函数，每个组件都会有自己的私有数据空间，不会干扰其他组件的运行。 router和route的区别 $route 是路由信息，包括path、params、query、name等路由信息参数 $router 是路由实例，包含了路由跳转方法、钩子函数等 如何设置动态路由 params传参 路由配置： /index/:id 路由跳转：this.$router.push(&#123;name: &#39;index&#39;, params: &#123;id: &quot;zs&quot;&#125;&#125;); 路由参数获取：$route.params.id 最后形成的路由：/index/zs query传参 路由配置：/index正常的路由配置 路由跳转：this.$rouetr.push(&#123;path: &#39;index&#39;, query:&#123;id: &quot;zs&quot;&#125;&#125;); 路由参数获取：$route.query.id 最后形成的路由：/index?id=zs 区别 获取参数方式不一样，一个通过$route.params，一个通过 $route.query 参数的生命周期不一样，query参数在URL地址栏中显示不容易丢失，params参数不会在地址栏显示，刷新后会消失 路由守卫 全局前置钩子：beforeEach、beforeResolve、afterEach 路由独享守卫：beforeEnter 组件内钩子：beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave Vue中key的作用key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，减少DOM操作量，提高性能。 为什么不建议用index作为key?当删除或添加列表元素时，其后面的所有元素的下标都会发生改变，导致Vue重新渲染整个列表。导致性能问题。 v-for和v-if优先级vue2中for大于if vue3中if大于for slot是什么？有什么作用？slot插槽，一般在封装组件的时候使用，在组件内不知道以那种形式来展示内容时，可以用slot来占据位置，最终展示形式由父组件以内容形式传递过来，主要分为三种： 默认插槽：又名匿名插槽，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。 具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。 作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。 $nextTick 原理及作用Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。 nextTick是将回调函数放到一个异步队列中，保证在异步更新DOM的watcher后面，从而获取到更新后的DOM。 因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在nextTick()的回调函数中。 虚拟DOM就一定比真实DOM更快吗虚拟DOM不一定比真实DOM更快，而是在特定情况下可以提供更好的性能。 在复杂情况下，虚拟DOM可以比真实DOM操作更快，因为它是在内存中维护一个虚拟的DOM树，将真实DOM操作转换为对虚拟DOM的操作，然后通过diff算法找出需要更新的部分，最后只变更这部分到真实DOM就可以。在频繁变更下，它可以批量处理这些变化从而减少对真实DOM的访问和操作，减少浏览器的回流重绘，提高页面渲染性能。 而在一下简单场景下，直接操作真实DOM可能会更快，当更新操作很少或者只是局部改变时，直接操作真实DOM比操作虚拟DOM更高效，省去了虚拟DOM的计算、对比开销。 Diff 算法Diff 算法（差异算法）是前端框架（如 React、Vue）用来 高效更新 DOM 的核心机制。它的核心思想是：对比新旧虚拟 DOM（或 VNode）的差异，只更新真正变化的部分，而不是全部重新渲染，从而提升性能。 为什么需要 ？ 直接操作 DOM 很慢：浏览器渲染 DOM 的开销很大，频繁更新会导致页面卡顿。 全量更新浪费资源：如果数据变化时直接重新渲染整个页面，性能会很差。 基本流程（1）虚拟 DOM（Virtual DOM） 框架（如 React&#x2F;Vue）会先用 JavaScript 对象（虚拟 DOM）描述页面结构。 数据变化时，生成新的虚拟 DOM，然后和旧的虚拟 DOM 进行 对比（Diff）。 （2）Diff 对比规则① 同级比较（Tree Diff） 只比较同一层级的节点，不会跨层级对比（减少计算量）。 如果节点类型不同（如 div → span），直接销毁重建。 ② 列表对比（List Diff &#x2F; Key 优化） **给列表元素加 key**（如 key=&#123;item.id&#125;），帮助框架识别哪些元素是新增、移动或删除的。 如果没有 key，框架会按顺序对比，可能导致不必要的 DOM 操作。 ③ 组件对比（Component Diff） 如果组件类型相同（如 &lt;Button /&gt; → &lt;Button /&gt;），复用组件实例，只更新 props。 如果组件类型不同（如 &lt;Button /&gt; → &lt;Input /&gt;），直接销毁重建。 当Token被窃取并被用于伪造请求 快速撤销被盗Token（如使用JWT的无状态特性，需通过黑名单或刷新Token强制失效）。 监控异常请求：检查日志，识别异常IP、高频请求或非常规操作，及时拦截。 设置较短的过期时间。 Token与首次请求的IP或设备指纹绑定，异常时拒绝请求。 强制使用HTTPS，避免明文传输。避免将Token存储在localStorage中，优先使用HttpOnly+Secure的Cookie。 避免在URL、日志或前端代码中暴露Token。对敏感操作（如修改密码）要求二次认证（如短信&#x2F;OTP）。 Token使用限制 单次Token（如微信支付的nonce_str）或限制Token使用次数。 动态Token（如每次请求生成新Token，旧Token立即失效）。 OAuth2.0防护 XSS攻击Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。 对比: 类型 存储区 插入点 存储型 XSS 后端数据库 HTML 反射型 XSS URL HTML DOM 型 XSS 后端数据库&#x2F;前端存储&#x2F;URL 前端 JavaScript 常用防范方法 httpOnly: 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。 输入过滤: 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。 转义 HTML: 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义。 预防 DOM 型 XSS 攻击DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 如果用 Vue&#x2F;React 技术栈，并且不使用 v-html&#x2F;dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患。 CSRF 跨站点请求伪造跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 XSS 是代码注入问题，CSRF 是 HTTP 问题。 XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面。 防御 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。 Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。 token；token 验证的 CSRF 防御机制是公认最合适的方案。 JavaScript 的 Event Loop（事件循环）JavaScript 是单线程的，意味着它一次只能执行一个任务。 Event Loop（事件循环） 就是 JS 处理异步任务的机制，它的核心逻辑是JS 按顺序执行同步代码（函数调用等）。异步任务完成后，它们的回调函数会被放入队列。队列又分成宏任务队列和微任务队列。宏任务队列包括 setTimeout、setInterval、IO、ui渲染事件的回调函数。微任务队列包括Promise.then、MutationObserver 等回调，优先级更高。 当调用栈为空时，先检查微任务队列，依次执行所有微任务。 然后从宏任务队列取一个任务（如 setTimeout 回调）执行。 重复这个过程。 垃圾回收机制标记清除算法 JavaScript 中最常用的垃圾收集方式这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。 该算法假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。垃圾回收器将定期从根开始（在JS中就是全局对象）扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的。那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。 此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)。 标记阶段，垃圾回收器会从根对象开始遍历。每一个可以从根对象访问到的对象都会被添加一个标识，于是这个对象就被标识为可到达对象。 清除阶段，垃圾回收器会对堆内存从头到尾进行线性遍历，如果发现有对象没有被标识为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作。 当内存耗尽时，程序将会被挂起，垃圾回收开始执行。 标记清除算法缺陷 那些无法从根对象查询到的对象都将被清除 垃圾收集后有可能会造成大量的内存碎片 引用计数算法这是最初级的垃圾收集算法.现在已经没有浏览器会用这种算法. 此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。 引用计数缺陷 该算法有个限制：无法处理循环引用。如果两个对象被创建，并互相引用，形成了一个循环。它们被调用之后会离开函数作用域，所以它们已经没有用了，可以被回收了。然而，引用计数算法考虑到它们互相都有至少一次引用，所以它们不会被回收。 确定this的值在非严格模式下，总是指向同一个对象，在严格模式下可以是任意值 非严格模式 严格模式 全局环境 window window 直接调用 window undefined 对象方法调用 调用者 调用者 开启严格模式 1&#x27;use strict&#x27;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"}]},{"title":"git","slug":"git","date":"2024-09-20T13:23:00.000Z","updated":"2025-05-11T11:39:22.178Z","comments":true,"path":"2024/09/20/git/","permalink":"http://example.com/2024/09/20/git/","excerpt":"","text":"常用命令 git init 初始化git仓库 git clone [本地目录] 克隆仓库到本地 git add (file) 添加工作区文件到暂存区 git commit -m (“message”) 从暂存区提交到本地仓库 git push [-f] [–set-upstream] [远端仓库名称 [本地分支名] [:远端分支名]] 推送到远程分支（同名可省略远端分支名） –set-upstream 推送的同时建立起和远程分支的关联关系 git status 查看仓库状态 git reset –hard (commitId) 版本回退 git-log&#x2F;git log 查看版本 git branch 查看分支 git branch (dev) 创建分支 git branch -d (dev) 删除分支 -D 强制删除 git checkout (dev) 切换分支 git checkout -b (dev) 创建并切换分支 git merge (dev) 将某分支合并到当前分支 git fetch [remote name] [branch name] 抓取仓库里的更新到本地，不会进行合并 git pull [remote name] [branch name] 拉取远程仓库里的更新到本地,自动进行合并 常见分支 master分支 线上运行分支，主分支 dev分支 从master创建的分支，开发分支，开发完成后合并到master分支 feature分支 从dev创建的分支，同期并行开发一些功能，完成后合并到dev分支 hotfix分支 master派生的分支，线上bug修复使用，修复完成后合并到master、test、develop分支 配置公&#x2F;私钥 用户（hzx）目录下 12ssh-keygen -t rsacat .ssh/id_rsa.pub 到代码托管平台粘贴公钥 1ssh -T git@github.com 关联远程仓库 创建仓库时README,.gitignore，liscence都不要添加 1git remote add origin(远端仓库名称) git@github.com:hzx-bit/git_test.git(远程仓库地址) git remote 查看远程仓库 git push origin main 本地仓库推送到远程仓库 同步远程仓库，远程解决冲突 git fetch+git merge：拉取远程仓库+合并 git pull","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"《我与地坛》文摘","slug":"《我与地坛》文摘","date":"2024-09-18T06:02:32.000Z","updated":"2025-02-13T06:47:17.663Z","comments":true,"path":"2024/09/18/《我与地坛》文摘/","permalink":"http://example.com/2024/09/18/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B%E6%96%87%E6%91%98/","excerpt":"","text":"一个人，出生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个事实；上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。这样想过之后我安心多了，眼前的一切不再那么可怕。比如你起早熬夜准备考试的时候，忽然想起有一个长长的假期在前面等待你，你会不会觉得轻松一点儿？并且庆幸并且感激这样的安排？ 有一年，十月的风又翻动起安详的落叶，我在园中读书，听见两个散步的老人说：“没想到这园子有这么大。”我放下书，想，这么大一座园子，要在其中找到她的儿子，母亲走过了多少焦灼的路。多年来我头一次意识到，这园中不单是处处都有过我的车辙，有过我的车辙的地方也都有过母亲的脚印。 谁又能把这世界想个明白呢？世上的很多事是不堪说的。你可以抱怨上帝何以要降诸多苦难给这人间，你也可以为消灭种种苦难而奋斗，并为此享有崇高与骄傲，但只要你再多想一步你就会坠入深深的迷茫了：假如世界上没有了苦难，世界还能够存在么？要是没有愚钝，机智还有什么光荣呢？要是没了丑陋，漂亮又怎么维系自己的幸运？要是没有了恶劣和卑下，善良与高尚又将如何界定自己又如何成为美德呢？要是没有了残疾，健全会否因其司空见惯而变得腻烦和乏味呢？我常梦想着在人间彻底消灭残疾，但可以相信，那时将由患病者代替残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由(比如说)相貌丑陋的人去承担了。就算我们连丑陋，连愚昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以统统消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢？怕是人间的剧目就全要收场了，一个失去差别的世界将是一潭死水，是一块没有感觉没有肥力的沙漠。 看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。 于是就有一个最令人绝望的结论等在这里：由谁去充任那些苦难的角色？又有谁去体现这世间的幸福、骄傲和快乐？只好听凭偶然，是没有道理好讲的。 就命运而言，休论公道。 那么，一切不幸命运的救赎之路在哪里呢？ 设若智慧或悟性可以引领我们去找到救赎之路，难道所有的人都能够获得这样的智慧和悟性吗？ 我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 这下好了，您不再恐慌了不再是个人质了，您自由了。算了吧你，我怎么可能自由呢？别忘了人真正的名字是：欲望。所以您得知道，消灭恐慌的最有效的办法就是消灭欲望。可是我还知道，消灭人性的最有效的办法也是消灭欲望。那么，是消灭欲望同时也消灭恐慌呢？还是保留欲望同时也保留人生？ 我在这园子里坐着，我听见园神告诉我：每一个有激情的演员都难免是一个人质。每一个懂得欣赏的观众都巧妙地粉碎了一场阴谋。每一个乏味的演员都是因为他老以为这戏剧与自己无关。每一个倒霉的观众都是因为他总是坐得离舞台太近了。我在这园子里坐着，园神成年累月地对我说：孩子，这不是别的，这是你的罪孽和福祉。 要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，也不能想，却又不能忘。它们不能变成语言，它们无法变成语言，一旦变成语言就不再是它们了。它们是一片朦胧的温馨与寂寥，是一片成熟的希望与绝望，它们的领地只有两处：心与坟墓。比如说邮票，有些是用于寄信的，有些仅仅是为了收藏。 我说不好我想不想回去。我说不好是想还是不想，还是无所谓。我说不好我是像那个孩子，还是像那个老人，还是像一个热恋中的情人。很可能是这样：我同时是他们三个。我来的时候是个孩子，他有那么多孩子气的念头所以才哭着喊着闹着要来，他一来一见到这个世界便立刻成了不要命的情人，而对一个情人来说，不管多么漫长的时光也是稍纵即逝，那时他便明白，每一步每一步，其实一步步都是走在回去的路上。当牵牛花初开的时节，葬礼的号角就已吹响。 但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布散烈烈朝辉之时。那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。 当然，那不是我。 但是，那不是我吗？ 宇宙以其不息的欲望将一个歌舞炼为永恒。这欲望有怎样一个人间的姓名，大可忽略不计。 因此偶尔有人说我是活在世外桃源，语气中不免流露了一点儿讥讽，仿佛这全是出于我的自娱甚至自欺。我颇不以为然。我既非活在世外桃源，也从不相信有什么世外桃源。但我相信世间桃源，世间确有此源，如果没有恐怕谁也就不想再活；倘此源有时弱小下去，依我看，至少讥讽并不能使其强大。千万年来它作为现实，更作为信念，这才不断。它源于心中再流入心中，它施于心又由于心，这才不断。欲其强大，舍心之虔诚又向何求呢？ 也有人说我是不是一直活在童话里？语气中既有赞许又有告诫。赞许并且告诫，这很让我信服。赞许既在，告诫并不意指人们之间应该加固一条防线，而只是提醒我：童话的缺憾不在于它太美，而在于它必要走进一个更为纷繁而且严酷的世界，那时只怕它太娇嫩。 我想，倘有来世，我先要占住几项先天的优越：聪明、漂亮和一副好身体。命运从一开始就不公平，人一生下来就有走运的和不走运的。譬如说一个人很笨，这该怨他自己吗？然而由此所导致的一切后果却完全要由他自己负责——他可能因此在兄弟姐妹之中是最不被父母喜爱的一个，他可能因此常受教师的斥责和同学们的嘲笑，他于是便更加自卑、更加委顿，饱受了轻蔑终也不知这事到底该怨谁。再譬如说，一个人生来就丑，相当丑，再怎么想办法去美容都无济于事，这难道是他的错误是他的罪过？不是，好，不是。那为什么就该他难得姑娘们的喜欢呢？因而婚事就变得格外困难，一旦有个漂亮姑娘爱上他却又赢得多少人的惊诧和不解，终于有了孩子，不要说别人就连他自己都希望孩子千万别长得像他自己。为什么就该他是这样呢？为什么就该他常遭取笑，常遭哭笑不得的外号，或者常遭怜悯，常遭好心人小心翼翼地对待呢？再说身体，有的人生来就肩宽腿长潇洒英俊（或者婀娜妩媚娉娉婷婷），生来就有一身好筋骨，跑得也快跳得也高，气力足耐力又好，精力旺盛，而且很少生病，可有的人却与此相反生来就样样都不如人。对于身体，我的体会尤甚。譬如写文章，有的人写一整天都不觉得累，可我连续写上三四个钟头眼前就要发黑。譬如和朋友们一起去野游，满心欢喜妙想联翩地到了地方，大家的热情正高雅趣正浓，可我已经累得只剩了让大家扫兴的份儿了。所以我真希望来世能有一副好身体。今生就不去想它了，只盼下辈子能够谨慎投胎，有健壮优美如卡尔·刘易斯一般的身材和体质，有潇洒漂亮如周恩来一般的相貌和风度，有聪明智慧如阿尔伯特·爱因斯坦一般的大脑和灵感。 既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？我便如醉如痴并且极端自私自利地梦想下去。 其实秘密就已经是墙了。肚皮和眼皮都是墙，假笑和伪哭都是墙，只因这样的墙嫌软嫌累，要弄些坚实耐久的来加密。就算这心灵之墙可以轻易拆除，但山和水都是墙，天和地都是墙，时间和空间都是墙，命运是无穷的限制，上帝的秘密是不尽的墙。真要把这秘密之墙也都拆除，虽然很像是由来已久的理想接近了实现，但是等着瞧吧，满地球都怕要因为失去趣味而响起昏昏欲睡的鼾声，梦话亦不知从何说起。 趣味是要紧而又要紧的。秘密要好好保存。 探秘的欲望终于要探到意义的墙下。 真是神奇。很可能，生和死都不过取决于观察，取决于观察的远与近。比如，当一颗距离我们数十万光年的星星实际早已熄灭，它却正在我们的视野里度着它的青年时光。 时间限制了我们，习惯限制了我们，谣言般的舆论让我们陷于实际，让我们在白昼的魔法中闭目塞听不敢妄为。白昼是一种魔法，一种符咒，让僵死的规则畅行无阻，让实际消磨掉神奇。所有的人都在白昼的魔法之下扮演着紧张、呆板的角色，一切言谈举止，一切思绪与梦想，都仿佛被预设的程序所圈定。 因而我盼望夜晚，盼望黑夜，盼望寂静中自由的到来。 甚至盼望站到死中，去看生。 历史的每一瞬间，都有无数的历史蔓展，都有无限的时间延伸。我们生来孤单，无数的历史和无限的时间因破碎而成片断。互相埋没的心流，在孤单中祈祷，在破碎处眺望，或可指望在梦中团圆。记忆，所以是一个牢笼。印象是牢笼以外的天空。 谁说我没有死过?出生以前，太阳已无数次起落悠久的时光被悠久的虚无吞并又以我生日的名义卷土重来。 然而，终于这一天到来之时，时间已经远远地超过了暂时。我独自看那“编剧”后面的三个字，早已懂得:有为，与爱情，原是风马牛不相及的两个领域。但暂时，亦可在心中长久，而写作，却永远地不能与爱情无关。 但要是“爱”也喧嚣，“美”也招摇，“真诚”沦为一句时髦的广告，那怎么办?惟柔弱是爱愿的识别，正如放弃是喧嚣的解剂。人一活脱便要嚣张，天生的这么一种动物。这动物适合在地坛放养些时日——我是说当年的地坛。回望地坛，回望它的安静，想念中坐在不管它的哪一个角落，重新铺开一张纸吧。写，真是个办法，油然地通向着安静。写，这形式，注定是个人的，容易撞见诚实，容易被诚实揪住不放，容易在市场之外遭遇心中的阴暗，在自以为是时回归零度。把一切污浊、畸形、歧路，重新放回到那儿去检查，勿使伪劣的心魂流布。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"}],"tags":[{"name":"《我与地坛》","slug":"《我与地坛》","permalink":"http://example.com/tags/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B/"}]},{"title":"react","slug":"react","date":"2024-09-16T02:24:16.000Z","updated":"2025-04-12T02:56:04.095Z","comments":true,"path":"2024/09/16/react/","permalink":"http://example.com/2024/09/16/react/","excerpt":"","text":"目录结构 文件夹 作用 apis 接口 assets 静态资源 components 通用组件 pages 页面级组件 router 路由Router store Redux状态 utils 工具函数 安装依赖12npm i sass @craco/craco -Dnpm i antd react-router-dom axios @reduxjs/toolkit react-redux 配置别名路径 项目根目录创建craco.config.js，添加路径解析配置 123456789const path = require(&#x27;path&#x27;)module.exports = &#123; webpack:&#123; alias:&#123; &#x27;@&#x27;:path.resolve(__dirname,&#x27;src&#x27;) &#125; &#125;&#125; package.json中配置启动和打包配置 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;, 配置路由 page文件夹放置路由组件&lt;Outlet/&gt;,或navigate&#x3D;useNavigate()，调用navigate()函数 router文件夹配置路由 createBrowserRouter index.js 提供路由 &lt;RouterProvider router=&#123;router&#125;/&gt; 获取parameter 123456789navigate(&#x27;/article?id=1001&#x27;)const [params] = useSearchParams()let id = params.get(&#x27;id&#x27;)path:&#x27;/article/:id/:name&#x27;navigate(&#x27;/article/1001/jack&#x27;)const params = useParams()let id = params.id 刷新页面window.location.reload() 项目打包 npm run build serve -s build 路由懒加载12const Home = lazy(()=&gt;import(&quot;@/pages/Home&quot;))&lt;Suspense fallback=&#123;&#x27;加载中&#x27;&#125;&gt;&lt;Home/&gt;&lt;/Suspense&gt; 包体积可视化分析 npm i source-map-explore package.json中配置 1234567&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;, &quot;analyze&quot;:&quot;source-map-explorer &#x27;build/static/js/*.js&#x27;&quot;&#125;, npm run analyze CDN优化 CDN是一种内容分发网络服务，当用户请求网站内容时，由离用户最近的服务器将缓存的资源内容传递给用户 体积较大的非业务js文件，比如react、react-dom可以放到CDN服务器 体积较大，需要利用CDN文件在浏览器的缓存特性，加快加载时间 非业务JS文件，不需要经常做变动，CDN不用频繁更新缓存 具体做法 把需要做CDN缓存的文件排除在打包之外 以CDN的方式重新引入资源 跨域代理配置 npm install http-proxy-middleware –save npm install axios 新建setupProxy.js文件 123456789101112const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;); module.exports = function (app) &#123; app.use( &#x27;/api1&#x27;, createProxyMiddleware(&#123; target: &#x27;http://localhost:5000&#x27;, changeOrigin: true, pathRewrite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125; &#125;) );&#125;; 发布订阅 xxxxxxxxxx import { ElLoading } from ‘element-plus’import ‘element-plus&#x2F;theme-chalk&#x2F;el-loading.css’&#x2F;&#x2F; 跳转前router.beforeEach((to,from,next)&#x3D;&gt;{ ElLoading.service({ fullscreen: true, text: ‘Loading…’ }) window.scrollTo(0,0) next()})&#x2F;&#x2F; 跳转后router.afterEach((to)&#x3D;&gt;{ setTimeout(()&#x3D;&gt;{ const loadingInstance &#x3D; ElLoading.service() loadingInstance.close() },1000) document.title &#x3D; to.meta.title || ‘my project’})jsx 123456import PubSub from &#x27;pubsub-js&#x27;//引入PubSub.publish(&#x27;atguigu&#x27;,&#123;isFirst:false,isLoading:true&#125;)//发布this.token = PubSub.subscribe(&#x27;atguigu&#x27;,(_,data)=&gt;&#123; this.setState(data); &#125;)//订阅PubSub.unsubscribe(this.token);//取消订阅 fetch123456789async()=&gt;&#123; try&#123; const response = await fetch(`/api1/search/user2?q=$&#123;KeyWord&#125;`); const data = await response.json(); console.log(data); &#125;catch(error)&#123; console.log(&#x27;请求出错&#x27;,error); &#125;&#125; classNames（高亮切换）123import classNames from &#x27;classnames&#x27;&lt;className=&#123;classNames(&#x27;normal-style&#x27;,&#123;&#x27;active&#x27;:type===item.type&#125;)&#125;&gt;&lt;className=&#123;classNames(&#x27;normal-style&#x27;,type===item.type&amp;&amp;&#x27;active&#x27;)&#125;&gt; uuid12import &#123; v4 as uuidv4 &#125; from &#x27;uuid&#x27;;uuidv4(); useRef123456789import &#123;useRef&#125; from &#x27;react&#x27;const inputRef = useRef(null);&lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt;inputRef.current//拿到节点 跨级传递信息1234//封装上下文对象给生产者和消费者//MsgContext.jsimport &#123;createContext&#125; from &#x27;react&#x27;export default const MsgContext = createContext() 12345678910//顶层组件import MsgContext from &#x27;./MsgContext.js&#x27;&lt;MsgContext.Provider value=&#123;&#x27;this is a msg&#x27;&#125;&gt; &lt;Component/&gt;&lt;/MsgContext.Provider&gt;//底层组件import &#123;useContext&#125; from &#x27;react&#x27;import MsgContext from &#x27;./MsgContext.js&#x27;const msg = useContext(MsgContext); useEffect 无参：初始和更新 空数组：初始 依赖项：初始和依赖项发生变化 返回的函数在组件销毁时调用 1234567891011121314151617import &#123;useEffect,useState&#125; from &#x27;react&#x27;const URL=&#x27;http://geek.itheima.net/v1_0/channels&#x27;const [list, setList] = useState([]); useEffect(()=&gt;&#123; async function getList() &#123; const res =await fetch(URL); const jsonRes =await res.json(); setList(jsonRes.data.channels); &#125; getList(); const timer = setInterval(()=&gt;&#123; console.log(&#x27;............&#x27;) &#125;,1000) return ()=&gt;&#123; clearInterval(timer) &#125; &#125;,[]); json-server npm install json-server 根目录下新建db.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;, &quot;list&quot;:[ &#123; &quot;rpid&quot;: 3, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;13258165&quot;, &quot;avatar&quot;: &quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.FY7sfLpXX6K8x4SfSxFA0gHaHa?w=200&amp;h=199&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;周杰伦&quot; &#125;, &quot;content&quot;: &quot;哎哟，不错哦&quot;, &quot;ctime&quot;: &quot;10-18 08:15&quot;, &quot;like&quot;: 99 &#125;, &#123; &quot;rpid&quot;: 2, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;36080105&quot;, &quot;avatar&quot;: &quot;https://tse4-mm.cn.bing.net/th/id/OIP-C.B7PjPsZql8BH1LLnLZawvgAAAA?w=195&amp;h=195&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;许嵩&quot; &#125;, &quot;content&quot;: &quot;我寻你千百度 日出到迟暮&quot;, &quot;ctime&quot;: &quot;11-13 11:29&quot;, &quot;like&quot;: 88 &#125;, &#123; &quot;rpid&quot;: 1, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;30009257&quot;, &quot;avatar&quot;: &quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.FY7sfLpXX6K8x4SfSxFA0gHaHa?w=200&amp;h=199&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;黑马前端&quot; &#125;, &quot;content&quot;: &quot;学前端就来黑马&quot;, &quot;ctime&quot;: &quot;10-19 09:00&quot;, &quot;like&quot;: 66 &#125; ]&#125; package.json 配置 1&quot;serve&quot;: &quot;json-server db.json --port 3004&quot; npm run serve Redux npm i @reduxjs&#x2F;toolkit react-redux 在modules文件夹下创建不同的store切片，每个store有自己的name、initialState和reducers，reducers有管理状态的方法（与actions同名）。从store中解构出actions和reducer并导出 在index.js中导入reducer，配置store中的reducer &lt;Provider store=&#123;store&#125;&gt;包裹根节点 在App.js中用useSelector取出数据，用useDispatch产生dispatch函数，导入actions，需要时调用dispatch（action) useMemo使用场景：缓存性能消耗大的计算 1234567891011121314151617181920212223242526272829import &#123; useMemo, useState &#125; from &#x27;react&#x27;function fib (n) &#123; console.log(&#x27;计算函数执行了&#x27;) if (n &lt; 3) return 1 return fib(n - 2) + fib(n - 1)&#125;function App() &#123; const [count, setCount] = useState(0) // 计算斐波那契之和 // const sum = fib(count) // 通过useMemo缓存计算结果，只有count发生变化时才重新计算 const sum = useMemo(() =&gt; &#123; return fib(count) &#125;, [count]) const [num, setNum] = useState(0) return ( &lt;&gt; &#123;sum&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+count:&#123;count&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt;+num:&#123;num&#125;&lt;/button&gt; &lt;/&gt; )&#125;export default App React.memo作用：允许组件在props没有改变的情况下跳过重新渲染 机制：只有props发生变化时才重新渲染下面的子组件通过 memo 进行包裹之后，返回一个新的组件MemoSon, 只有传给MemoSon的props参数发生变化时才会重新渲染 12345678910111213141516171819import React, &#123; useState &#125; from &#x27;react&#x27;const MemoSon = React.memo(function Son() &#123; console.log(&#x27;子组件被重新渲染了&#x27;) return &lt;div&gt;this is span&lt;/div&gt;&#125;)function App() &#123; const [, forceUpdate] = useState() console.log(&#x27;父组件重新渲染了&#x27;) return ( &lt;&gt; &lt;MemoSon /&gt; &lt;button onClick=&#123;() =&gt; forceUpdate(Math.random())&#125;&gt;update&lt;/button&gt; &lt;/&gt; )&#125;export default App props变化重新渲染1234567891011121314151617181920import React, &#123; useState &#125; from &#x27;react&#x27;const MemoSon = React.memo(function Son() &#123; console.log(&#x27;子组件被重新渲染了&#x27;) return &lt;div&gt;this is span&lt;/div&gt;&#125;)function App() &#123; console.log(&#x27;父组件重新渲染了&#x27;) const [count, setCount] = useState(0) return ( &lt;&gt; &lt;MemoSon count=&#123;count&#125; /&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&#123;count&#125;&lt;/button&gt; &lt;/&gt; )&#125;export default App 对于props的比较，进行的是‘浅比较’，底层使用 Object.is 进行比较，针对于对象数据类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心对象中的具体属性 useCallback缓存函数 useCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用 12345678910111213141516171819202122232425// useCallBackimport &#123; memo, useCallback, useState &#125; from &#x27;react&#x27;const MemoSon = memo(function Son() &#123; console.log(&#x27;Son组件渲染了&#x27;) return &lt;div&gt;this is son&lt;/div&gt;&#125;)function App() &#123; const [, forceUpate] = useState() console.log(&#x27;父组件重新渲染了&#x27;) const onGetSonMessage = useCallback((message) =&gt; &#123; console.log(message) &#125;, []) return ( &lt;div&gt; &lt;MemoSon onGetSonMessage=&#123;onGetSonMessage&#125; /&gt; &lt;button onClick=&#123;() =&gt; forceUpate(Math.random())&#125;&gt;update&lt;/button&gt; &lt;/div&gt; )&#125;export default App forwardRef作用：允许组件使用ref将一个DOM节点暴露给父组件 12345678910111213141516171819202122import &#123; forwardRef, useRef &#125; from &#x27;react&#x27;const MyInput = forwardRef(function Input(props, ref) &#123; return &lt;input &#123;...props&#125; type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&#125;, [])function App() &#123; const ref = useRef(null) const focusHandle = () =&gt; &#123; console.log(ref.current.focus()) &#125; return ( &lt;div&gt; &lt;MyInput ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;focusHandle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default App useImperativeHandle作用：如果我们并不想暴露子组件中的DOM而是想暴露子组件内部的方法 12345678910111213141516171819202122232425262728293031import &#123; forwardRef, useImperativeHandle, useRef &#125; from &#x27;react&#x27;const MyInput = forwardRef(function Input(props, ref) &#123; // 实现内部的聚焦逻辑 const inputRef = useRef(null) const focus = () =&gt; inputRef.current.focus() // 暴露子组件内部的聚焦方法 useImperativeHandle(ref, () =&gt; &#123; return &#123; focus, &#125; &#125;) return &lt;input &#123;...props&#125; ref=&#123;inputRef&#125; type=&quot;text&quot; /&gt;&#125;)function App() &#123; const ref = useRef(null) const focusHandle = () =&gt; ref.current.focus() return ( &lt;div&gt; &lt;MyInput ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;focusHandle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default App ZustandZustand Documentation store&#x2F;index.js - 创建store1234567891011121314import &#123; create &#125; from &#x27;zustand&#x27;//1. 使用create方法创建store//2. 函数参数必须返回一个对象，包含状态数据和方法//3. set是用来修改数据的专门方法const useStore = create((set) =&gt; &#123; return &#123; count: 0, inc: () =&gt; &#123; set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125; &#125;&#125;)export default useStore app.js - 绑定组件12345678import useStore from &#x27;./store/useCounterStore.js&#x27;function App() &#123; const &#123; count, inc &#125; = useStore() return &lt;button onClick=&#123;inc&#125;&gt;&#123;count&#125;&lt;/button&gt;&#125;export default App 异步支持对于异步操作的支持不需要特殊的操作，直接在函数中编写异步逻辑，最后把接口的数据放到set函数中返回即可 store&#x2F;index.js - 创建store1234567891011121314151617181920import &#123; create &#125; from &#x27;zustand&#x27;const URL = &#x27;http://geek.itheima.net/v1_0/channels&#x27;const useStore = create((set) =&gt; &#123; return &#123; count: 0, ins: () =&gt; &#123; return set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125;, channelList: [], fetchChannelList: async () =&gt; &#123; const res = await fetch(URL) const jsonData = await res.json() set(&#123;channelList: jsonData.data.channels&#125;) &#125; &#125;&#125;)export default useStore app.js - 绑定组件1234567891011121314151617181920import &#123; useEffect &#125; from &#x27;react&#x27;import useChannelStore from &#x27;./store/channelStore&#x27;function App() &#123; const &#123; channelList, fetchChannelList &#125; = useChannelStore() useEffect(() =&gt; &#123; fetchChannelList() &#125;, [fetchChannelList]) return ( &lt;ul&gt; &#123;channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default App 切片模式场景：当我们单个store比较大的时候，可以采用一种切片模式进行模块拆分再组合 拆分并组合切片1234567891011121314151617181920212223242526272829import &#123; create &#125; from &#x27;zustand&#x27;// 创建counter相关切片const createCounterStore = (set) =&gt; &#123; return &#123; count: 0, setCount: () =&gt; &#123; set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125; &#125;&#125;// 创建channel相关切片const createChannelStore = (set) =&gt; &#123; return &#123; channelList: [], fetchGetList: async () =&gt; &#123; const res = await fetch(URL) const jsonData = await res.json() set(&#123; channelList: jsonData.data.channels &#125;) &#125; &#125;&#125;// 组合切片const useStore = create((...a) =&gt; (&#123; ...createCounterStore(...a), ...createChannelStore(...a)&#125;)) 组件使用123456789101112131415function App() &#123; const &#123;count, inc, channelList, fetchChannelList &#125; = useStore() return ( &lt;&gt; &lt;button onClick=&#123;inc&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;ul&gt; &#123;channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/&gt; )&#125;export default App 对接DevTools 简单的调试我们可以安装一个 名称为 simple-zustand-devtools 的调试工具 安装调试包1npm i simple-zustand-devtools -D 配置调试工具123456789101112131415import create from &#x27;zustand&#x27;// 导入核心方法import &#123; mountStoreDevtool &#125; from &#x27;simple-zustand-devtools&#x27;// 省略部分代码...// 开发环境开启调试if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; mountStoreDevtool(&#x27;channelStore&#x27;, useChannelStore)&#125;export default useChannelStore","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"landscape","slug":"landscape","date":"2024-09-15T13:50:48.000Z","updated":"2024-09-16T02:32:03.725Z","comments":true,"path":"2024/09/15/landscape/","permalink":"http://example.com/2024/09/15/landscape/","excerpt":"","text":"","categories":[{"name":"照片","slug":"照片","permalink":"http://example.com/categories/%E7%85%A7%E7%89%87/"}],"tags":[{"name":"风景","slug":"风景","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF/"}]},{"title":"我的第一篇博客","slug":"myFirstBlog","date":"2024-09-14T16:00:00.000Z","updated":"2024-09-15T10:22:39.218Z","comments":true,"path":"2024/09/15/myFirstBlog/","permalink":"http://example.com/2024/09/15/myFirstBlog/","excerpt":"","text":"2024.9.15,重新搭建博客网站，用来记录日常和学习笔记。。。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"},{"name":"照片","slug":"照片","permalink":"http://example.com/categories/%E7%85%A7%E7%89%87/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"},{"name":"node.js","slug":"node-js","permalink":"http://example.com/tags/node-js/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"《围城》","slug":"《围城》","permalink":"http://example.com/tags/%E3%80%8A%E5%9B%B4%E5%9F%8E%E3%80%8B/"},{"name":"es6","slug":"es6","permalink":"http://example.com/tags/es6/"},{"name":"Eslint","slug":"Eslint","permalink":"http://example.com/tags/Eslint/"},{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"《我与地坛》","slug":"《我与地坛》","permalink":"http://example.com/tags/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"风景","slug":"风景","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF/"}]}