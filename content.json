{"meta":{"title":"hzx's blog","subtitle":"","description":"","author":"huangzhixin","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2024-09-15T09:45:48.795Z","updated":"2024-09-15T09:45:48.795Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2024-09-15T09:40:25.000Z","updated":"2024-09-15T09:40:25.154Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-09-15T09:46:14.266Z","updated":"2024-09-15T09:46:14.266Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-09-15T09:45:11.683Z","updated":"2024-09-15T09:45:11.683Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"css","slug":"css","date":"2024-09-23T05:03:55.000Z","updated":"2024-09-23T09:47:59.665Z","comments":true,"path":"2024/09/23/css/","permalink":"http://example.com/2024/09/23/css/","excerpt":"","text":"通配符选择器1234* &#123; 属性1:属性值1; ...&#125; 字体属性 font-family:字体系列 font-size:字体大小 默认16px font-weight:字体粗细 normal|bold|bolder|lighter|number(默认400) font-style:字体样式 normal|italic font: font-style font-weight font-size&#x2F;line-height font-family; 文本属性 color:文本颜色 text-align:对齐方式 left|center|right text-decoration:添加&#x2F;删除一条线none|underline|overline|line-through text-index:首行缩进 em为1个文字的大小 line-height:行间距 要比font-size大 复合选择器 div a 后代选择器 div&gt;a 子元素选择器 div,span 并集选择器 a:link|a:visited|a:hover|a:active 链接伪类选择器（LoVe HaTe顺序编写） input:focus focus伪类选择器 显示模式 块元素 自己独占一行 高度、宽度、外边距、内边距都可以控制 默认宽度是父级宽度的100% （除了文字类块元素）里面可以放行内或块级元素 行内元素 相邻行内元素在一行上 设置宽高无效 默认宽度为内容宽度 行内元素只能容纳文本或者行内元素 行内块元素：&lt;img/&gt;&lt;input/&gt;&lt;td/&gt; 相邻行内块元素在一行上 默认宽度为内容宽度 高度、宽度、外边距、内边距都可以控制 显示模式切换： display:none|block|inline|inline-block","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"面试八股","slug":"面试八股","date":"2024-09-21T12:28:26.000Z","updated":"2024-09-23T05:02:55.040Z","comments":true,"path":"2024/09/21/面试八股/","permalink":"http://example.com/2024/09/21/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/","excerpt":"","text":"确定this的值在非严格模式下，总是指向同一个对象，在严格模式下可以是任意值 非严格模式 严格模式 全局环境 window window 直接调用 window undefined 对象方法调用 调用者 调用者 开启严格模式 1&#x27;use strict&#x27; 指定this的值 调用时指定 call方法 1func.call(thisArg,arg1,arg2...) apply方法 1func.apply(thisArg,[arg1,arg2...]) 创建时指定 bind方法 1const bindFunc = func.bind(thisArg,arg1,arg2...) 箭头函数 12345678const dog = &#123; name:&#x27;ason&#x27;, eat()&#123; setTimeout(()=&gt;&#123; console.log(this)//输出eat()的调用者dog &#125;) &#125;&#125; 面试回答:如何改变this指向,有2类改变this指向的方法,分别是: call与apply方法调用并传入具体的this， 创建函数时绑定this? bind:返回一个绑定了this以及参数(可选)的新函数 箭头函数:创建时会绑定上一级作用域中的this 手写call方法与apply方法1234567891011121314151617181920212223242526272829303132333435363738Function.prototype.myCall = function(thisArg,...args)&#123; const key = Symbol(&#x27;key&#x27;) thisArg[key] = this const res = thisArg[key](...args) delete thisArg[key] return res&#125;Function.prototype.myApply = function(thisArg,args)&#123; const key = Symbol(&#x27;key&#x27;) thisArg[key] = this const res = thisArg[key](args) delete thisArg[key] return res&#125;const person = &#123; name:&#x27;hzx&#x27;&#125;function func(numA,numB) &#123; console.log(this) console.log(numA,numB) return numA+numB&#125;function func2([numA,numB]) &#123; console.log(this) console.log(numA,numB) return numA+numB&#125;const res = func.myCall(person,2,8)console.log(&#x27;myCall返回值为：&#x27;,res)const res2 = func2.myApply(person,[2,8])console.log(&#x27;myApply的返回值为：&#x27;,res2) 面试回答：手写call方法的步骤为 在function的原型上添加myCall方法,保证所有函数都可以调用 方法内部,通过动态为对象添加方法的形式来指定this指向 调用完毕之后通过delete关键字删除上一步动态增加的方法 方法的名字通过Symbol进行设置,避免和默认名重复 使用剩余参数的形式传递参数2-参数n(函数参数) 手写apply方法 在function的原型上添加myApply方法,保证所有函数都可以调用 方法内部,通过动态为对象添加方法的形式来指定this指向 调用完毕之后通过delete关键字删除上一步动态增加的方法 方法的名字通过Symbol进行设置,避免和默认名重复 直接使用数组传递函数的参数,内部调用时结合...运算符展开数组 手写bind方法12345678910111213141516171819Function.prototype.myBind = function(thisArg,...args1)&#123; return (...args2)=&gt;&#123; return this.call(thisArg,...args1,...args2) &#125;&#125;const person = &#123; name:&#x27;hzx&#x27;&#125;function func(numA,numB,numC,numD) &#123; console.log(this) console.log(numA,numB,numC,numD) return numA+numB+numC+numD&#125;const bindFunc = func.myBind(person,1,2)const res = bindFunc(3,4)console.log(&#x27;myBind返回值为：&#x27;,res) 面试回答:手写bind方法 function原型上添加myBind函数,参数1为绑定的this,参数2-参数2为绑定的参数 内部返回一个新箭头函数,目的是绑定作用域中的this 返回的函数内部,通过call进行this和参数绑定 通过call的参数2和参数3指定绑定的参数,和调用时传递的参数 JavaScript静态属性和私有属性面试回答:class实现继承 子类通过extends继承继承父类 子类如果需要重新定义构造函数,必须在内部通过super关键字调用父类的构造函数 静态：类通过static关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。 私有：类属性默认共有，可以使用增加哈希前缀#的方法来定义私有类字段，声明和访问时也需要加上,只能在类的内部访问。 123456789101112131415class Test &#123; static 静态属性 static 静态方法() &#123;&#125; #私有属性 #私有方法() &#123; &#125; info() &#123; this.#私有属性 this.#私有方法() &#125;&#125;Test.静态属性Test.静态方法() 面试回答:class语法补充 class中私有属性&#x2F;方法 定义和使用时需要使用关键字# 私有属性只能在类的内部使用,外部无法使用(代码中) Chrome的控制台中为了方便调试,可以直接访问 class中静态属性&#x2F;方法 定义和使用时需要使用关键字static 通过类访问 静态方法中的this是类 寄生组合继承123456789101112131415function Person(name) &#123; this.name = name&#125;Person.prototype.sayHi = function()&#123; console.log(`你好，我叫$&#123;this.name&#125;`)&#125;function Student(name) &#123; Person.call(this,name)&#125;Student.prototype = Object.create(Person,&#123; constructor:&#123; value:Student &#125;&#125;) 面试回答:ES5-寄生组合式继承 寄生组合式继承的核心步骤是:通过构造函数来继承属性,通过原型链来继承方法 寄生组合式继承和组合式继承的区别是:原型链的继承并没有调用父类的构造函数,而是直接基于父类的原型创建一个新副本实现继承 fetch方法123const res = await fetch(URL);res.statusconst data = await res.json(); 生成查询字符串： 12const p = new URLSearchParams(&#123;pname:&#x27;广东省&#x27;,cname:&#x27;深圳市&#x27;&#125;)p.toString() 1234567891011121314&lt;input type=&quot;file&quot; class=&quot;file&quot; accept=&quot;image/*&quot;&gt; &lt;script&gt; document.querySelector(&#x27;.file&#x27;).addEventListener(&#x27;change&#x27;, async function (e) &#123; // 生成FormData对象并添加数据 const data = new FormData() data.append(&#x27;img&#x27;, this.files[0]) const res = await fetch(&#x27;http://hmajax.itheima.net/api/uploadimg&#x27;, &#123; method: &#x27;post&#x27;, body: data &#125;) const json = await res.json() console.log(json) &#125;) &lt;/script&gt; 12345678910111213141516async function () &#123; // 通过headers设置请求头 const headers = new Headers() // 通过 content-type指定请求体数据格式 headers.append(&#x27;content-type&#x27;, &#x27;application/json&#x27;) // 参数1 url // 参数2 请求配置 const res = await fetch(&#x27;http://hmajax.itheima.net/api/register&#x27;, &#123; method: &#x27;post&#x27;,// 请求方法 headers, // 请求头 // 请求体 body: JSON.stringify(&#123; username: &#x27;itheima9876&#x27;, password: &#x27;123456&#x27; &#125;) &#125;) const json = await res.json() console.log(json) &#125; GeneratorGenerator-核心语法核心语法: 如何定义生成器函数: 如何获取generator对象 yield表达式的使用 通过for of获取每一个yield的值 12345678910111213141516171819202122232425262728293031// 1. 通过function* 创建生成器函数 function* foo() &#123; // 遇到yield表达式时会暂停后续的操作 yield &#x27;a&#x27; yield &#x27;b&#x27; yield &#x27;c&#x27; return &#x27;d&#x27;&#125;// 2. 调用函数获取生成器const f = foo()// 3. 通过next方法获取yield 之后的表达式结果，会被包装到一个对象中// 执行一次next 即可获取一次 yield之后的表达式结果const res1 = f.next()console.log(res1)// &#123;value: &#x27;a&#x27;, done: false&#125;const res2 = f.next()console.log(res2)// &#123;value: &#x27;b&#x27;, done: false&#125;const res3 = f.next()console.log(res3)// &#123;value: &#x27;c&#x27;, done: false&#125;// 最后一次可以拿到return的结果const res4 = f.next()console.log(res4)// &#123;value: &#x27;d&#x27;, done: true&#125; // done 为true之后，获取到的value为undefinedconst res5 = f.next()console.log(res5)// &#123;value: undefined, done: true&#125; // 4. 通过for of 获取每一个yield之后的值，const f2 = foo()for (const iterator of f2) &#123; console.log(iterator)&#125; 面试回答:Generator-核心语法 可以通过生成器函数(function* xxx()&#123;&#125;)来生成Generator对象: 通过Generator对象的next方法可以获取yield表达式之后的结果 Generator-id生成器**需求:**使用Generator实现一个id生成器id 12345678910function* idGenerator() &#123; // 逻辑略&#125;const idMaker = idGenerator()// 调用next方法,获取id(每次累加1)const &#123; value: id1 &#125; = idMaker.next()console.log(id1)const &#123; value: id2 &#125; = idMaker.next()console.log(id2) 核心步骤: 定义生成器函数 内部使用循环,通过yield返回id并累加 12345678910111213141516// 1. 通过function* 创建生成器函数 function* generator() &#123; let id = 0 // 无限循环 while (true) &#123; // id累加并返回 yield id++ &#125;&#125;// 2. 调用函数获取生成器const idMaker = generator()// 3. 需要id的时候 通过next获取即可const &#123; value: id1 &#125; = idMaker.next()console.log(id1)const &#123; value: id2 &#125; = idMaker.next()console.log(id2) 面试回答:Generator-id生成器 生成器函数内部的代码会在调用next方法时执行,利用这一特点,可以实现任意的生成器,需要时调用next即可获取结果 Generator-流程控制遇到yield表达式时会暂停后续的操作 **需求:**使用Generator实现流程控制 12345678function* weatherGenerator() &#123; // 逻辑略 yield axios()&#125;// 获取Generator实例const weather = weatherGenerator()// 依次获取 北上广深的天气 (axios)weather.next() 123456789101112131415161718192021222324252627282930&lt;button class=&quot;getWeather&quot;&gt;天气查询&lt;/button&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.6/axios.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /** * 需求：流程控制，依次查询，北上广深的天气预报 * 参考code: 北京 110100 上海 310100 广州 440100 深圳 440300 * 接口文档: https://apifox.com/apidoc/project-1937884/api-49760220 * */ function* weatherGenerator() &#123; // 北京 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=110100&#x27;) // 上海 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=310100&#x27;) // 广州 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=440100&#x27;) // 深圳 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=440300&#x27;) &#125; const cityWeather = weatherGenerator() document.querySelector(&#x27;.getWeather&#x27;).addEventListener(&#x27;click&#x27;,() =&gt; &#123; cityWeather.next().value.then(res=&gt;&#123; console.log(res) return cityWeather.next().value &#125;).then(res=&gt;&#123; console.log(res) return cityWeather.next().value &#125;) &#125;)&lt;/script&gt; 面试回答:Generator-流程控制 使用Generator控制流程的本质是利用yield关键字来分隔逻辑比如示例中依次调用了多个接口,通过yield分隔,通过next来触发调用 手写promise1","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"}]},{"title":"9.21","slug":"9-21","date":"2024-09-21T11:48:00.000Z","updated":"2024-09-21T12:15:31.593Z","comments":true,"path":"2024/09/21/9-21/","permalink":"http://example.com/2024/09/21/9-21/","excerpt":"","text":"高新区的晚霞，我想我会想念这里的 今天状态不错 学信网档案更新啦","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"git","slug":"git","date":"2024-09-20T13:23:00.000Z","updated":"2024-09-21T05:18:35.327Z","comments":true,"path":"2024/09/20/git/","permalink":"http://example.com/2024/09/20/git/","excerpt":"","text":"常用命令 git reset –hard (commitId) 版本回退 git-log&#x2F;git log 查看版本 git add (file) 添加工作区到暂存区 git commit -m (“message”) 提交暂存区到本地仓库 git branch 查看分支 git branch (dev) 创建分支 git checkout (dev) 切换分支 git checkout -b (dev) 创建并切换分支 git merge (dev) 将某分支合并到当前分支 git branch -d (dev) 删除分支 -D 强制删除 git push [-f] [–set-upstream] [远端仓库名称 [本地分支名] [:远端分支名]] 推送到远程分支（同名可省略远端分支名） –set-upstream 推送的同时建立起和远程分支的关联关系 git branch -vv 查看本地分支和远程分支的对应关系 git clone [本地目录] 克隆仓库到本地 git fetch [remote name] [branch name] 抓取仓库里的更新到本地，不会进行合并 git pull [remote name] [branch name] 抓取仓库里的更新到本地,自动进行合并 常见分支 master分支 线上运行分支，主分支 dev分支 从master创建的分支，开发分支，开发完成后合并到master分支 feature分支 从dev创建的分支，同期并行开发一些功能，完成后合并到dev分支 hotfix分支 master派生的分支，线上bug修复使用，修复完成后合并到master、test、develop分支 配置公&#x2F;私钥 用户（hzx）目录下 12ssh-keygen -t rsacat .ssh/id_rsa.pub 到代码托管平台粘贴公钥 1ssh -T git@github.com 关联远程仓库 创建仓库时README,.gitignore，liscence都不要添加 1git remote add origin(远端仓库名称) git@github.com:hzx-bit/git_test.git(远程仓库地址) git remote 查看远程仓库 git push origin master 本地仓库推送到远程仓库 同步远程仓库，远程解决冲突 git fetch+git merge git pull","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"react-jike-mobile","slug":"react-jike-mobile","date":"2024-09-19T15:21:56.000Z","updated":"2024-09-20T07:20:03.521Z","comments":true,"path":"2024/09/19/react-jike-mobile/","permalink":"http://example.com/2024/09/19/react-jike-mobile/","excerpt":"","text":"初始化项目 npm create vite@latest react-jike-mobile – –template react-ts 精简项目结构 git init git commit -m “初始化项目” git add origin https://github.com/hzx-bit/react-jike-mobile.git git branch -M main git push -u origin main 安装依赖12npm i antd-mobile react-router-dom axiosnpm i sass @types/node -D 配置路径别名修改vite配置123456789101112131415//vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import react from &#x27;@vitejs/plugin-react&#x27;import path from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [react()], resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#125;, &#125;,&#125;) 安装node类型包1npm i @types/node -D 修改tsconfig.app.json文件12345678&#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;src/*&quot; ] &#125;,&#125; axios安装配置安装axios1npm i axios 简易封装123456789101112131415161718192021222324252627282930313233import axios from &#x27;axios&#x27;//1.根域名配置//2.超时时间//3.请求拦截器 响应拦截器const requestInstance = axios.create(&#123; baseURL: &#x27;http://geek.itheima.net/v1_0&#x27;, timeout: 5000,&#125;)// 添加请求拦截器//在请求发送之前 做拦截 处理参数requestInstance.interceptors.request.use( (config) =&gt; &#123; return config &#125;, (error) =&gt; &#123; return Promise.reject(error) &#125;)//添加响应拦截器requestInstance.interceptors.response.use( (response) =&gt; &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response &#125;, (error) =&gt; &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error) &#125;)export default requestInstance 123import requestInstance from &#x27;./http&#x27;export &#123; requestInstance as http &#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"《我与地坛》文摘","slug":"《我与地坛》文摘","date":"2024-09-18T06:02:32.000Z","updated":"2024-09-19T14:10:12.589Z","comments":true,"path":"2024/09/18/《我与地坛》文摘/","permalink":"http://example.com/2024/09/18/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B%E6%96%87%E6%91%98/","excerpt":"","text":"一个人，出生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个事实；上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。这样想过之后我安心多了，眼前的一切不再那么可怕。比如你起早熬夜准备考试的时候，忽然想起有一个长长的假期在前面等待你，你会不会觉得轻松一点儿？并且庆幸并且感激这样的安排？ 有一年，十月的风又翻动起安详的落叶，我在园中读书，听见两个散步的老人说：“没想到这园子有这么大。”我放下书，想，这么大一座园子，要在其中找到她的儿子，母亲走过了多少焦灼的路。多年来我头一次意识到，这园中不单是处处都有过我的车辙，有过我的车辙的地方也都有过母亲的脚印。 谁又能把这世界想个明白呢？世上的很多事是不堪说的。你可以抱怨上帝何以要降诸多苦难给这人间，你也可以为消灭种种苦难而奋斗，并为此享有崇高与骄傲，但只要你再多想一步你就会坠入深深的迷茫了：假如世界上没有了苦难，世界还能够存在么？要是没有愚钝，机智还有什么光荣呢？要是没了丑陋，漂亮又怎么维系自己的幸运？要是没有了恶劣和卑下，善良与高尚又将如何界定自己又如何成为美德呢？要是没有了残疾，健全会否因其司空见惯而变得腻烦和乏味呢？我常梦想着在人间彻底消灭残疾，但可以相信，那时将由患病者代替残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由(比如说)相貌丑陋的人去承担了。就算我们连丑陋，连愚昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以统统消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢？怕是人间的剧目就全要收场了，一个失去差别的世界将是一潭死水，是一块没有感觉没有肥力的沙漠。 看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。 于是就有一个最令人绝望的结论等在这里：由谁去充任那些苦难的角色？又有谁去体现这世间的幸福、骄傲和快乐？只好听凭偶然，是没有道理好讲的。 就命运而言，休论公道。 那么，一切不幸命运的救赎之路在哪里呢？ 设若智慧或悟性可以引领我们去找到救赎之路，难道所有的人都能够获得这样的智慧和悟性吗？ 我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 这下好了，您不再恐慌了不再是个人质了，您自由了。算了吧你，我怎么可能自由呢？别忘了人真正的名字是：欲望。所以您得知道，消灭恐慌的最有效的办法就是消灭欲望。可是我还知道，消灭人性的最有效的办法也是消灭欲望。那么，是消灭欲望同时也消灭恐慌呢？还是保留欲望同时也保留人生？ 我在这园子里坐着，我听见园神告诉我：每一个有激情的演员都难免是一个人质。每一个懂得欣赏的观众都巧妙地粉碎了一场阴谋。每一个乏味的演员都是因为他老以为这戏剧与自己无关。每一个倒霉的观众都是因为他总是坐得离舞台太近了。我在这园子里坐着，园神成年累月地对我说：孩子，这不是别的，这是你的罪孽和福祉。 要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，也不能想，却又不能忘。它们不能变成语言，它们无法变成语言，一旦变成语言就不再是它们了。它们是一片朦胧的温馨与寂寥，是一片成熟的希望与绝望，它们的领地只有两处：心与坟墓。比如说邮票，有些是用于寄信的，有些仅仅是为了收藏。 我说不好我想不想回去。我说不好是想还是不想，还是无所谓。我说不好我是像那个孩子，还是像那个老人，还是像一个热恋中的情人。很可能是这样：我同时是他们三个。我来的时候是个孩子，他有那么多孩子气的念头所以才哭着喊着闹着要来，他一来一见到这个世界便立刻成了不要命的情人，而对一个情人来说，不管多么漫长的时光也是稍纵即逝，那时他便明白，每一步每一步，其实一步步都是走在回去的路上。当牵牛花初开的时节，葬礼的号角就已吹响。 但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布散烈烈朝辉之时。那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。 当然，那不是我。 但是，那不是我吗？ 宇宙以其不息的欲望将一个歌舞炼为永恒。这欲望有怎样一个人间的姓名，大可忽略不计。 因此偶尔有人说我是活在世外桃源，语气中不免流露了一点儿讥讽，仿佛这全是出于我的自娱甚至自欺。我颇不以为然。我既非活在世外桃源，也从不相信有什么世外桃源。但我相信世间桃源，世间确有此源，如果没有恐怕谁也就不想再活；倘此源有时弱小下去，依我看，至少讥讽并不能使其强大。千万年来它作为现实，更作为信念，这才不断。它源于心中再流入心中，它施于心又由于心，这才不断。欲其强大，舍心之虔诚又向何求呢？ 也有人说我是不是一直活在童话里？语气中既有赞许又有告诫。赞许并且告诫，这很让我信服。赞许既在，告诫并不意指人们之间应该加固一条防线，而只是提醒我：童话的缺憾不在于它太美，而在于它必要走进一个更为纷繁而且严酷的世界，那时只怕它太娇嫩。 我想，倘有来世，我先要占住几项先天的优越：聪明、漂亮和一副好身体。命运从一开始就不公平，人一生下来就有走运的和不走运的。譬如说一个人很笨，这该怨他自己吗？然而由此所导致的一切后果却完全要由他自己负责——他可能因此在兄弟姐妹之中是最不被父母喜爱的一个，他可能因此常受教师的斥责和同学们的嘲笑，他于是便更加自卑、更加委顿，饱受了轻蔑终也不知这事到底该怨谁。再譬如说，一个人生来就丑，相当丑，再怎么想办法去美容都无济于事，这难道是他的错误是他的罪过？不是，好，不是。那为什么就该他难得姑娘们的喜欢呢？因而婚事就变得格外困难，一旦有个漂亮姑娘爱上他却又赢得多少人的惊诧和不解，终于有了孩子，不要说别人就连他自己都希望孩子千万别长得像他自己。为什么就该他是这样呢？为什么就该他常遭取笑，常遭哭笑不得的外号，或者常遭怜悯，常遭好心人小心翼翼地对待呢？再说身体，有的人生来就肩宽腿长潇洒英俊（或者婀娜妩媚娉娉婷婷），生来就有一身好筋骨，跑得也快跳得也高，气力足耐力又好，精力旺盛，而且很少生病，可有的人却与此相反生来就样样都不如人。对于身体，我的体会尤甚。譬如写文章，有的人写一整天都不觉得累，可我连续写上三四个钟头眼前就要发黑。譬如和朋友们一起去野游，满心欢喜妙想联翩地到了地方，大家的热情正高雅趣正浓，可我已经累得只剩了让大家扫兴的份儿了。所以我真希望来世能有一副好身体。今生就不去想它了，只盼下辈子能够谨慎投胎，有健壮优美如卡尔·刘易斯一般的身材和体质，有潇洒漂亮如周恩来一般的相貌和风度，有聪明智慧如阿尔伯特·爱因斯坦一般的大脑和灵感。 既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？我便如醉如痴并且极端自私自利地梦想下去。 其实秘密就已经是墙了。肚皮和眼皮都是墙，假笑和伪哭都是墙，只因这样的墙嫌软嫌累，要弄些坚实耐久的来加密。就算这心灵之墙可以轻易拆除，但山和水都是墙，天和地都是墙，时间和空间都是墙，命运是无穷的限制，上帝的秘密是不尽的墙。真要把这秘密之墙也都拆除，虽然很像是由来已久的理想接近了实现，但是等着瞧吧，满地球都怕要因为失去趣味而响起昏昏欲睡的鼾声，梦话亦不知从何说起。 趣味是要紧而又要紧的。秘密要好好保存。 探秘的欲望终于要探到意义的墙下。 真是神奇。很可能，生和死都不过取决于观察，取决于观察的远与近。比如，当一颗距离我们数十万光年的星星实际早已熄灭，它却正在我们的视野里度着它的青年时光。 时间限制了我们，习惯限制了我们，谣言般的舆论让我们陷于实际，让我们在白昼的魔法中闭目塞听不敢妄为。白昼是一种魔法，一种符咒，让僵死的规则畅行无阻，让实际消磨掉神奇。所有的人都在白昼的魔法之下扮演着紧张、呆板的角色，一切言谈举止，一切思绪与梦想，都仿佛被预设的程序所圈定。 因而我盼望夜晚，盼望黑夜，盼望寂静中自由的到来。 甚至盼望站到死中，去看生。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"}],"tags":[{"name":"《我与地坛》","slug":"《我与地坛》","permalink":"http://example.com/tags/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B/"}]},{"title":"中秋","slug":"中秋","date":"2024-09-17T12:20:02.000Z","updated":"2024-09-17T12:39:04.124Z","comments":true,"path":"2024/09/17/中秋/","permalink":"http://example.com/2024/09/17/%E4%B8%AD%E7%A7%8B/","excerpt":"","text":"但愿人长久，千里共婵娟独在异乡为异客，每逢佳节倍思亲 感谢老姐拍来老家的月亮（合肥刮台风看不到）","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"react-jike","slug":"react-jike","date":"2024-09-16T04:05:55.000Z","updated":"2024-09-20T07:28:48.790Z","comments":true,"path":"2024/09/16/react-jike/","permalink":"http://example.com/2024/09/16/react-jike/","excerpt":"","text":"目录结构 文件夹 作用 apis 接口 assets 静态资源 components 通用组件 pages 页面级组件 router 路由Router store Redux状态 utils 工具函数 安装依赖12npm i sass @craco/craco -Dnpm i antd react-router-dom axios @reduxjs/toolkit react-redux normalize.css 样式reset12345678910111213//index.jsimport &#x27;normalize.css&#x27;//index.scsshtml,body &#123; margin: 0; height: 100%;&#125;#root &#123; height: 100%;&#125; 配置别名路径 项目根目录创建craco.config.js，添加路径解析配置 123456789const path = require(&#x27;path&#x27;)module.exports = &#123; webpack:&#123; alias:&#123; &#x27;@&#x27;:path.resolve(__dirname,&#x27;src&#x27;) &#125; &#125;&#125; package.json中配置启动和打包配置 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;, 根目录下创建jsconfig.json 12345678910&#123; &quot;compilerOptions&quot;:&#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;:&#123; &quot;@/*&quot;:[ &quot;src/*&quot; ] &#125; &#125;&#125; 配置路由 page文件夹放置路由组件&lt;Outlet/&gt;,或navigate&#x3D;useNavigate()，调用navigate()函数 router文件夹配置路由 createBrowserRouter index.js 提供路由 &lt;RouterProvider router=&#123;router&#125;/&gt; 获取parameter 123456789navigate(&#x27;/article?id=1001&#x27;)const [params] = useSearchParams()let id = params.get(&#x27;id&#x27;)path:&#x27;/article/:id/:name&#x27;navigate(&#x27;/article/1001/jack&#x27;)const params = useParams()let id = params.id 关联远程github项目git init git add . git commit -m “项目初始化” git remote add origin https://github.com/hzx-bit/react-jike.git 封装request请求模块 在utils文件夹中新建request.js文件 12345678910111213141516171819202122232425262728293031323334353637383940//axios封装处理import axios from &quot;axios&quot;;//1.根域名配置//2.超时时间//3.请求拦截器 响应拦截器const request = axios.create(&#123; baseURL: &#x27;http://geek.itheima.net/v1_0&#x27;, timeout: 5000&#125;)// 添加请求拦截器//在请求发送之前 做拦截 处理参数request.interceptors.request.use((config)=&gt; &#123; const token = getToken() if(token)&#123; config.headers.Authorization = `Bearer $&#123;token&#125;` &#125; return config &#125;, (error)=&gt; &#123; return Promise.reject(error)&#125;)// 添加响应拦截器request.interceptors.response.use((response)=&gt; &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response.data &#125;, (error)=&gt; &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 //监控401 token失效 if(error.response.status === 401)&#123; removeToken() router.navigate(&#x27;/login&#x27;) window.location.reload() &#125; return Promise.reject(error)&#125;)export &#123;request&#125; 在utils文件夹中新建index.js文件，统一中转工具模块函数 1234import &#123; request &#125; from &quot;./request&quot;;export&#123; request&#125; 使用Redux管理token12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//token.jsconst TOKENKEY = &#x27;token_key&#x27;function setToken(token)&#123; localStorage.setItem(TOKENKEY,token)&#125;function getToken()&#123; return localStorage.getItem(TOKENKEY)&#125;function removeToken()&#123; localStorage.removeItem(TOKENKEY)&#125;export&#123; setToken, getToken, removeToken&#125;//user.js//和用户相关的状态管理import &#123; request &#125; from &quot;@/utils&quot;;import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;import &#123; setToken as _setToken,getToken &#125; from &quot;@/utils&quot;;const userStore = createSlice(&#123; name:&#x27;user&#x27;, initialState:&#123; token:getToken()||&#x27;&#x27; &#125;, reducers:&#123; setToken(state,action)&#123; state.token = action.payload _setToken(action.payload) &#125; &#125;&#125;)//解构出actionCreaterconst &#123;setToken&#125; = userStore.actionsconst reducer = userStore.reducerconst fetchLogin = (loginForm)=&gt;&#123; return async(dispatch)=&gt;&#123; const res = await request.post(&#x27;/authorizations&#x27;,loginForm) dispatch(setToken(res.data.token)) &#125;&#125;export &#123;fetchLogin&#125;export default reducer 根据Token控制路由跳转123456789101112131415161718192021//AuthRoute.jsimport &#123; getToken &#125; from &quot;@/utils&quot;import &#123; Navigate &#125; from &quot;react-router-dom&quot;function AuthRoute(&#123;children&#125;)&#123; const token = getToken() if(token)&#123; return &lt;&gt;&#123;children&#125;&lt;/&gt; &#125; else return &lt;Navigate to=&#123;&#x27;/login&#x27;&#125; replace/&gt;&#125;export default AuthRoute//配置router&#123; path:&#x27;/&#x27;, element:&lt;AuthRoute&gt;&lt;Layout/&gt;&lt;/AuthRoute&gt;&#125; echartsnpm i echarts 123456789101112131415161718192021222324252627282930313233343536373839import * as echarts from &#x27;echarts&#x27;import &#123; useEffect, useRef &#125; from &#x27;react&#x27;const Home = ()=&gt;&#123; const chartRef = useRef(null) useEffect(()=&gt;&#123; //1. 获取渲染图表的dom节点 const chartDom = chartRef.current //2. 图表初始化生成图表实例对象 const myChart = echarts.init(chartDom) //3. 准备图表参数 const option = &#123; xAxis: &#123; type: &#x27;category&#x27;, data: [&#x27;Vue&#x27;, &#x27;React&#x27;, &#x27;Angular&#x27;] &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [ &#123; data: [10,40,70], type: &#x27;bar&#x27; &#125; ] &#125;; //使用图表参数完成图表渲染 option &amp;&amp; myChart.setOption(option); &#125;,[]) return ( &lt;div&gt; //确保节点具有宽高 &lt;div ref=&#123;chartRef&#125; style=&#123;&#123;width:&#x27;500px&#x27;,height:&#x27;400px&#x27;&#125;&#125;&gt;&lt;/div&gt; &lt;/div&gt; ) apis文件夹封装函数1234567891011121314151617181920212223//user.js//用户相关的所有请求const &#123; request &#125; = require(&quot;@/utils&quot;);//1. 用户登录function loginAPI(formData)&#123; return request(&#123; url:&#x27;/authorizations&#x27;, method:&#x27;POST&#x27;, data:formData &#125;)&#125;function getProfileAPI()&#123; return request(&#123; url:&#x27;/user/profile&#x27;, method:&#x27;GET&#x27; &#125;)&#125;export &#123;loginAPI,getProfileAPI&#125; 富文本编辑器npm i &#x72;&#x65;&#x61;&#x63;&#116;&#45;&#x71;&#x75;&#x69;&#108;&#108;&#64;&#x32;&#46;&#48;&#x2e;&#x30;&#45;&#x62;&#101;&#x74;&#97;&#46;&#50; 123456789101112131415161718192021222324import ReactQuill from &#x27;react-quill&#x27;import &#x27;react-quill/dist/quill.snow.css&#x27;const Publish = () =&gt; &#123; return ( // ... &lt;Form labelCol=&#123;&#123; span: 4 &#125;&#125; wrapperCol=&#123;&#123; span: 16 &#125;&#125; &gt; &lt;Form.Item label=&quot;内容&quot; name=&quot;content&quot; rules=&#123;[&#123; required: true, message: &#x27;请输入文章内容&#x27; &#125;]&#125; &gt; &lt;ReactQuill className=&quot;publish-quill&quot; theme=&quot;snow&quot; placeholder=&quot;请输入文章内容&quot; /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )&#125; 刷新页面window.location.reload() 项目打包 npm run build serve -s build 路由懒加载12const Home = lazy(()=&gt;import(&quot;@/pages/Home&quot;))&lt;Suspense fallback=&#123;&#x27;加载中&#x27;&#125;&gt;&lt;Home/&gt;&lt;/Suspense&gt; 包体积可视化分析 npm i source-map-explore package.json中配置 1234567&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;, &quot;analyze&quot;:&quot;source-map-explorer &#x27;build/static/js/*.js&#x27;&quot;&#125;, npm run analyze CDN优化 CDN是一种内容分发网络服务，当用户请求网站内容时，由离用户最近的服务器将缓存的资源内容传递给用户 体积较大的非业务js文件，比如react、react-dom可以放到CDN服务器 体积较大，需要利用CDN文件在浏览器的缓存特性，加快加载时间 非业务JS文件，不需要经常做变动，CDN不用频繁更新缓存 具体做法 把需要做CDN缓存的文件排除在打包之外 以CDN的方式重新引入资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//craco.config.js// 添加自定义对于webpack的配置const path = require(&#x27;path&#x27;)const &#123; whenProd, getPlugin, pluginByName &#125; = require(&#x27;@craco/craco&#x27;)module.exports = &#123; // webpack 配置 webpack: &#123; // 配置别名 alias: &#123; // 约定：使用 @ 表示 src 文件所在路径 &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;) &#125;, // 配置webpack // 配置CDN configure: (webpackConfig) =&gt; &#123; let cdn whenProd(() =&gt; &#123; // key: 不参与打包的包(由dependencies依赖项中的key决定) // value: cdn文件中 挂载于全局的变量名称 为了替换之前在开发环境下 webpackConfig.externals = &#123; react: &#x27;React&#x27;, &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27; &#125; // 配置现成的cdn资源地址 // 实际开发的时候 用公司自己花钱买的cdn服务器 cdn = &#123; js: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/react/18.1.0/umd/react.production.min.js&#x27;, &#x27;https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.1.0/umd/react-dom.production.min.js&#x27;, ] &#125; &#125;) // 通过 htmlWebpackPlugin插件 在public/index.html注入cdn资源url const &#123; isFound, match &#125; = getPlugin( webpackConfig, pluginByName(&#x27;HtmlWebpackPlugin&#x27;) ) if (isFound) &#123; // 找到了HtmlWebpackPlugin的插件 match.options.files = cdn &#125; return webpackConfig &#125; &#125;&#125; 12345678//index.html&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- 加载第三发包的 CDN 链接 --&gt; &lt;% htmlWebpackPlugin.options.files.js.forEach(cdnURL =&gt; &#123; %&gt; &lt;script src=&quot;&lt;%= cdnURL %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125;) %&gt;&lt;/body&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react","slug":"react","date":"2024-09-16T02:24:16.000Z","updated":"2024-09-19T15:42:26.097Z","comments":true,"path":"2024/09/16/react/","permalink":"http://example.com/2024/09/16/react/","excerpt":"","text":"跨域代理配置 npm install http-proxy-middleware –save npm install axios 新建setupProxy.js文件 123456789101112const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;); module.exports = function (app) &#123; app.use( &#x27;/api1&#x27;, createProxyMiddleware(&#123; target: &#x27;http://localhost:5000&#x27;, changeOrigin: true, pathRewrite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125; &#125;) );&#125;; 发布订阅npm install pubsub-js –save 123456import PubSub from &#x27;pubsub-js&#x27;//引入PubSub.publish(&#x27;atguigu&#x27;,&#123;isFirst:false,isLoading:true&#125;)//发布this.token = PubSub.subscribe(&#x27;atguigu&#x27;,(_,data)=&gt;&#123; this.setState(data); &#125;)//订阅PubSub.unsubscribe(this.token);//取消订阅 fetch123456789async()=&gt;&#123; try&#123; const response = await fetch(`/api1/search/user2?q=$&#123;KeyWord&#125;`); const data = await response.json(); console.log(data); &#125;catch(error)&#123; console.log(&#x27;请求出错&#x27;,error); &#125;&#125; lodash（排序）12import _ from &#x27;lodash&#x27;_.orderBy(list,&#x27;key&#x27;,&#x27;desc&#x27;); classNames（高亮切换）123import classNames from &#x27;classnames&#x27;&lt;className=&#123;classNames(&#x27;normal-style&#x27;,&#123;&#x27;active&#x27;:type===item.type&#125;)&#125;&gt;&lt;className=&#123;classNames(&#x27;normal-style&#x27;,type===item.type&amp;&amp;&#x27;active&#x27;)&#125;&gt; uuid12import &#123; v4 as uuidv4 &#125; from &#x27;uuid&#x27;;uuidv4(); dayjs12import dayjs from &#x27;dayjs&#x27;dayjs().format(); useRef123456789import &#123;useRef&#125; from &#x27;react&#x27;const inputRef = useRef(null);&lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt;inputRef.current//拿到节点 跨级传递信息123456import &#123;createContext,useContext&#125;const MsgContext = createContext()&lt;MsgContext.Provider value=&#123;msg&#125;&gt; &lt;Component/&gt;&lt;/MsgContext.Provider&gt;const msg = useContext(MsgContext); useEffect 无参：初始和更新 空数组：初始 依赖项：初始和依赖项发生变化 返回的函数在组件销毁时调用 1234567891011121314151617import &#123;useEffect,useState&#125; from &#x27;react&#x27;const URL=&#x27;http://geek.itheima.net/v1_0/channels&#x27;const [list, setList] = useState([]); useEffect(()=&gt;&#123; async function getList() &#123; const res =await fetch(URL); const jsonRes =await res.json(); setList(jsonRes.data.channels); &#125; getList(); const timer = setInterval(()=&gt;&#123; console.log(&#x27;............&#x27;) &#125;,1000) return ()=&gt;&#123; clearInterval(timer) &#125; &#125;,[]); json-server npm install json-server 根目录下新建db.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;, &quot;list&quot;:[ &#123; &quot;rpid&quot;: 3, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;13258165&quot;, &quot;avatar&quot;: &quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.FY7sfLpXX6K8x4SfSxFA0gHaHa?w=200&amp;h=199&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;周杰伦&quot; &#125;, &quot;content&quot;: &quot;哎哟，不错哦&quot;, &quot;ctime&quot;: &quot;10-18 08:15&quot;, &quot;like&quot;: 99 &#125;, &#123; &quot;rpid&quot;: 2, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;36080105&quot;, &quot;avatar&quot;: &quot;https://tse4-mm.cn.bing.net/th/id/OIP-C.B7PjPsZql8BH1LLnLZawvgAAAA?w=195&amp;h=195&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;许嵩&quot; &#125;, &quot;content&quot;: &quot;我寻你千百度 日出到迟暮&quot;, &quot;ctime&quot;: &quot;11-13 11:29&quot;, &quot;like&quot;: 88 &#125;, &#123; &quot;rpid&quot;: 1, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;30009257&quot;, &quot;avatar&quot;: &quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.FY7sfLpXX6K8x4SfSxFA0gHaHa?w=200&amp;h=199&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;黑马前端&quot; &#125;, &quot;content&quot;: &quot;学前端就来黑马&quot;, &quot;ctime&quot;: &quot;10-19 09:00&quot;, &quot;like&quot;: 66 &#125; ]&#125; package.json 配置 1&quot;serve&quot;: &quot;json-server db.json --port 3004&quot; npm run serve Redux npm i @reduxjs&#x2F;toolkit react-redux Store（仓库）： Store 是应用程序状态的中央存储库。它包含了整个应用程序的状态树，即一个 JavaScript 对象。Redux 规定了应用程序状态只能通过 Store 来管理和修改，确保了状态的单一数据源。通过 createStore 函数来创建 Store。 Action（动作）： Action 是描述发生了什么事件的普通 JavaScript 对象。它们是将数据从应用程序传递到 Store 的唯一方式。每个 Action 都必须包含一个 type 属性，表示动作的类型，以及可选的 payload 属性，用于传递数据。Action 只用于描述事件，不进行状态的修改。 Reducer（归纳器）： Reducer 是一个纯函数，用于定义应用程序状态的修改方式。Reducer 接收当前状态和一个 Action，根据 Action 的类型来返回一个新的状态。Redux 应用程序通常包含多个 Reducer，每个 Reducer 负责管理状态树的一部分。Reducer 应当保持纯净，不应该产生副作用。 Dispatch（分发）： Dispatch 是一个函数，用于将 Action 发送到 Store，以便触发状态的修改。当组件需要修改应用程序的状态时，它会创建一个 Action 并将其分发到 Store。Dispatch 将 Action 发送给 Reducer，Reducer 根据 Action 的类型来更新状态。 Middleware（中间件）： Middleware 是 Redux 的一个扩展点，用于在 Action 发送到 Reducer 之前或之后执行额外的逻辑。例如，可以使用 Middleware 来处理异步操作、记录日志、路由导航等。Redux 提供了一些内置的 Middleware，也可以编写自定义 Middleware。 Selectors（选择器）： 选择器是用于从应用程序状态中提取数据的函数。它们可以帮助组件获取所需的状态，同时封装了状态的结构和访问方式。Selectors 有助于减少组件对状态的直接依赖，提高代码的可维护性。 在modules文件夹下创建不同的store切片，每个store有自己的name、initialState和reducers，reducers有管理状态的方法（与actions同名）。从store中解构出actions和reducer并导出 在index.js中导入reducer，配置store中的reducer &lt;Provider store=&#123;store&#125;&gt;包裹根节点 在App.js中用useSelector取出数据，用useDispatch产生dispatch函数，导入actions，需要时调用dispatch（action) antd-mobile npm install antd-mobile Ant Design Mobile useReducer123456789101112131415161718192021222324252627282930313233343536// 定义reducerimport &#123; useReducer &#125; from &#x27;react&#x27;// 1. 根据不同的action返回不同的新状态function reducer(state, action) &#123; console.log(&#x27;reducer执行了&#x27;) switch (action.type) &#123; case &#x27;INC&#x27;: return state + 1 case &#x27;DEC&#x27;: return state - 1 case &#x27;UPDATE&#x27;: return state + action.payload default: return state &#125;&#125;function App() &#123; // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( &lt;&gt; &#123;/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;DEC&#x27; &#125;)&#125;&gt;-&lt;/button&gt; &#123;state&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;INC&#x27; &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;UPDATE&#x27;, payload: 100 &#125;)&#125;&gt; update to 100 &lt;/button&gt; &lt;/&gt; )&#125;export default App useMemo使用场景：缓存性能消耗大的计算 1234567891011121314151617181920212223242526272829import &#123; useMemo, useState &#125; from &#x27;react&#x27;function fib (n) &#123; console.log(&#x27;计算函数执行了&#x27;) if (n &lt; 3) return 1 return fib(n - 2) + fib(n - 1)&#125;function App() &#123; const [count, setCount] = useState(0) // 计算斐波那契之和 // const sum = fib(count) // 通过useMemo缓存计算结果，只有count发生变化时才重新计算 const sum = useMemo(() =&gt; &#123; return fib(count) &#125;, [count]) const [num, setNum] = useState(0) return ( &lt;&gt; &#123;sum&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+count:&#123;count&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt;+num:&#123;num&#125;&lt;/button&gt; &lt;/&gt; )&#125;export default App React.memo作用：允许组件在props没有改变的情况下跳过重新渲染 机制：只有props发生变化时才重新渲染下面的子组件通过 memo 进行包裹之后，返回一个新的组件MemoSon, 只有传给MemoSon的props参数发生变化时才会重新渲染 12345678910111213141516171819import React, &#123; useState &#125; from &#x27;react&#x27;const MemoSon = React.memo(function Son() &#123; console.log(&#x27;子组件被重新渲染了&#x27;) return &lt;div&gt;this is span&lt;/div&gt;&#125;)function App() &#123; const [, forceUpdate] = useState() console.log(&#x27;父组件重新渲染了&#x27;) return ( &lt;&gt; &lt;MemoSon /&gt; &lt;button onClick=&#123;() =&gt; forceUpdate(Math.random())&#125;&gt;update&lt;/button&gt; &lt;/&gt; )&#125;export default App props变化重新渲染1234567891011121314151617181920import React, &#123; useState &#125; from &#x27;react&#x27;const MemoSon = React.memo(function Son() &#123; console.log(&#x27;子组件被重新渲染了&#x27;) return &lt;div&gt;this is span&lt;/div&gt;&#125;)function App() &#123; console.log(&#x27;父组件重新渲染了&#x27;) const [count, setCount] = useState(0) return ( &lt;&gt; &lt;MemoSon count=&#123;count&#125; /&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&#123;count&#125;&lt;/button&gt; &lt;/&gt; )&#125;export default App 对于props的比较，进行的是‘浅比较’，底层使用 Object.is 进行比较，针对于对象数据类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心对象中的具体属性 useCallback缓存函数 useCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用 12345678910111213141516171819202122232425// useCallBackimport &#123; memo, useCallback, useState &#125; from &#x27;react&#x27;const MemoSon = memo(function Son() &#123; console.log(&#x27;Son组件渲染了&#x27;) return &lt;div&gt;this is son&lt;/div&gt;&#125;)function App() &#123; const [, forceUpate] = useState() console.log(&#x27;父组件重新渲染了&#x27;) const onGetSonMessage = useCallback((message) =&gt; &#123; console.log(message) &#125;, []) return ( &lt;div&gt; &lt;MemoSon onGetSonMessage=&#123;onGetSonMessage&#125; /&gt; &lt;button onClick=&#123;() =&gt; forceUpate(Math.random())&#125;&gt;update&lt;/button&gt; &lt;/div&gt; )&#125;export default App forwardRef作用：允许组件使用ref将一个DOM节点暴露给父组件 12345678910111213141516171819202122import &#123; forwardRef, useRef &#125; from &#x27;react&#x27;const MyInput = forwardRef(function Input(props, ref) &#123; return &lt;input &#123;...props&#125; type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&#125;, [])function App() &#123; const ref = useRef(null) const focusHandle = () =&gt; &#123; console.log(ref.current.focus()) &#125; return ( &lt;div&gt; &lt;MyInput ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;focusHandle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default App useImperativeHandle作用：如果我们并不想暴露子组件中的DOM而是想暴露子组件内部的方法 12345678910111213141516171819202122232425262728293031import &#123; forwardRef, useImperativeHandle, useRef &#125; from &#x27;react&#x27;const MyInput = forwardRef(function Input(props, ref) &#123; // 实现内部的聚焦逻辑 const inputRef = useRef(null) const focus = () =&gt; inputRef.current.focus() // 暴露子组件内部的聚焦方法 useImperativeHandle(ref, () =&gt; &#123; return &#123; focus, &#125; &#125;) return &lt;input &#123;...props&#125; ref=&#123;inputRef&#125; type=&quot;text&quot; /&gt;&#125;)function App() &#123; const ref = useRef(null) const focusHandle = () =&gt; ref.current.focus() return ( &lt;div&gt; &lt;MyInput ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;focusHandle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default App ZustandZustand Documentation store&#x2F;index.js - 创建store1234567891011121314import &#123; create &#125; from &#x27;zustand&#x27;//1. 使用create方法创建store//2. 函数参数必须返回一个对象，包含状态数据和方法//3. set是用来修改数据的专门方法const useStore = create((set) =&gt; &#123; return &#123; count: 0, inc: () =&gt; &#123; set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125; &#125;&#125;)export default useStore app.js - 绑定组件12345678import useStore from &#x27;./store/useCounterStore.js&#x27;function App() &#123; const &#123; count, inc &#125; = useStore() return &lt;button onClick=&#123;inc&#125;&gt;&#123;count&#125;&lt;/button&gt;&#125;export default App 异步支持对于异步操作的支持不需要特殊的操作，直接在函数中编写异步逻辑，最后把接口的数据放到set函数中返回即可 store&#x2F;index.js - 创建store1234567891011121314151617181920import &#123; create &#125; from &#x27;zustand&#x27;const URL = &#x27;http://geek.itheima.net/v1_0/channels&#x27;const useStore = create((set) =&gt; &#123; return &#123; count: 0, ins: () =&gt; &#123; return set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125;, channelList: [], fetchChannelList: async () =&gt; &#123; const res = await fetch(URL) const jsonData = await res.json() set(&#123;channelList: jsonData.data.channels&#125;) &#125; &#125;&#125;)export default useStore app.js - 绑定组件1234567891011121314151617181920import &#123; useEffect &#125; from &#x27;react&#x27;import useChannelStore from &#x27;./store/channelStore&#x27;function App() &#123; const &#123; channelList, fetchChannelList &#125; = useChannelStore() useEffect(() =&gt; &#123; fetchChannelList() &#125;, [fetchChannelList]) return ( &lt;ul&gt; &#123;channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default App 切片模式场景：当我们单个store比较大的时候，可以采用一种切片模式进行模块拆分再组合 拆分并组合切片1234567891011121314151617181920212223242526272829import &#123; create &#125; from &#x27;zustand&#x27;// 创建counter相关切片const createCounterStore = (set) =&gt; &#123; return &#123; count: 0, setCount: () =&gt; &#123; set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125; &#125;&#125;// 创建channel相关切片const createChannelStore = (set) =&gt; &#123; return &#123; channelList: [], fetchGetList: async () =&gt; &#123; const res = await fetch(URL) const jsonData = await res.json() set(&#123; channelList: jsonData.data.channels &#125;) &#125; &#125;&#125;// 组合切片const useStore = create((...a) =&gt; (&#123; ...createCounterStore(...a), ...createChannelStore(...a)&#125;)) 组件使用123456789101112131415function App() &#123; const &#123;count, inc, channelList, fetchChannelList &#125; = useStore() return ( &lt;&gt; &lt;button onClick=&#123;inc&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;ul&gt; &#123;channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/&gt; )&#125;export default App 对接DevTools 简单的调试我们可以安装一个 名称为 simple-zustand-devtools 的调试工具 安装调试包1npm i simple-zustand-devtools -D 配置调试工具123456789101112131415import create from &#x27;zustand&#x27;// 导入核心方法import &#123; mountStoreDevtool &#125; from &#x27;simple-zustand-devtools&#x27;// 省略部分代码...// 开发环境开启调试if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; mountStoreDevtool(&#x27;channelStore&#x27;, useChannelStore)&#125;export default useChannelStore","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"landscape","slug":"landscape","date":"2024-09-15T13:50:48.000Z","updated":"2024-09-16T02:32:03.725Z","comments":true,"path":"2024/09/15/landscape/","permalink":"http://example.com/2024/09/15/landscape/","excerpt":"","text":"","categories":[{"name":"照片","slug":"照片","permalink":"http://example.com/categories/%E7%85%A7%E7%89%87/"}],"tags":[{"name":"风景","slug":"风景","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF/"}]},{"title":"我的第一篇博客","slug":"myFirstBlog","date":"2024-09-14T16:00:00.000Z","updated":"2024-09-15T10:22:39.218Z","comments":true,"path":"2024/09/15/myFirstBlog/","permalink":"http://example.com/2024/09/15/myFirstBlog/","excerpt":"","text":"2024.9.15,重新搭建博客网站，用来记录日常和学习笔记。。。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"},{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"},{"name":"照片","slug":"照片","permalink":"http://example.com/categories/%E7%85%A7%E7%89%87/"}],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"《我与地坛》","slug":"《我与地坛》","permalink":"http://example.com/tags/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B/"},{"name":"风景","slug":"风景","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF/"}]}