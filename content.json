{"meta":{"title":"hzx's blog","subtitle":"","description":"","author":"huangzhixin","url":"http://example.com","root":"/"},"pages":[{"title":"所有分类","date":"2024-09-15T09:45:48.795Z","updated":"2024-09-15T09:45:48.795Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2024-09-15T09:40:25.000Z","updated":"2024-09-15T09:40:25.154Z","comments":true,"path":"archives/index.html","permalink":"http://example.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2024-09-15T09:46:14.266Z","updated":"2024-09-15T09:46:14.266Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-09-15T09:45:11.683Z","updated":"2024-09-15T09:45:11.683Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"下面写关于自己的内容"}],"posts":[{"title":"Hadoop","slug":"Hadoop","date":"2024-10-22T12:13:21.000Z","updated":"2024-10-22T15:53:09.716Z","comments":true,"path":"2024/10/22/Hadoop/","permalink":"http://example.com/2024/10/22/Hadoop/","excerpt":"","text":"Hadoop Hadoop是一个由Apache基金会所开发的分布式系统基础架构。 主要解决:海量数据的存储和海量数据的分析计算问题。 优势 高可靠性：Hadoop底层维护多个数据副本，所以即使Hadoop某个计算元素或存储出现故障，也不会导致数据的丢失。 高扩展性：在集群间分配任务数据，可方便的扩展数以千计的节点。 高效性：在MapReduce的思想下，Hadoop是并行工作的，以加快任务处理速度。 高容错性：能够自动将失败的任务重新分配。 组成 MapReduce负责运算。 Yarn负责资源的调度。 HDFS负责数据存储。 Common辅助工具 HDFS架构Hadoop Distributed File System，简称 HDFS，是一个分布式文件系统。 NameNode（nn）：存储文件的元数据，如文件名，文件目录结构，文件属性（生成时间、副本数、 文件权限），以及每个文件的块列表和块所在的DataNode等。 DataNode(dn)：在本地文件系统存储文件块数据，以及块数据的校验和。 Secondary NameNode(2nn)：每隔一段时间对NameNode元数据备份。 YARNYet Another Resource Negotiator 简称 YARN ，另一种资源协调者，是 Hadoop 的资源管理器。 ResourceManager：整个集群资源的老大 NodeManager：单个节点服务器资源老大 ApplicationMaster：单个任务运行的老大 Container：容器，相当于一台独立运行的服务器，里面封装了任务运行所需要的资源，如内存、CPU、磁盘、网络等。 MapReduceMapReduce 将计算过程分为两个阶段：Map 和 Reduce Map 阶段并行处理输入数据 Reduce 阶段对 Map 结果进行汇总 配置配置hostname和ip hostnamectl set-hostname master","categories":[],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"}]},{"title":"api_server后端项目","slug":"api-server后端项目","date":"2024-10-17T02:43:35.000Z","updated":"2024-10-17T08:51:58.483Z","comments":true,"path":"2024/10/17/api-server后端项目/","permalink":"http://example.com/2024/10/17/api-server%E5%90%8E%E7%AB%AF%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"项目初始化安装依赖1npm i express cors mysql2 配置跨域、处理表单数据的中间件、路由 在项目根目录中，新建router文件夹，用来存放路由 在项目根目录中，新建router_handler文件夹，用来存放所有的路由处理函数模块 123456789// /router_handler/user.jsexports.regUser = (req, res) =&gt; &#123; res.send(&#x27;regUser ok&#x27;)&#125;exports.login = (req, res) =&gt; &#123; res.send(&#x27;login ok&#x27;)&#125; 12345678910// /router/user.jsconst express = require(&#x27;express&#x27;)const router = express.Router()const userHandler = require(&#x27;../router_handler/user&#x27;)router.post(&#x27;/reguser&#x27;, userHandler.regUser)router.post(&#x27;/login&#x27;, userHandler.login)module.exports = router 1234567891011121314151617// app.jsconst express = require(&#x27;express&#x27;)//创建服务器的实例对象const app = express()//配置cors跨域const cors = require(&#x27;cors&#x27;)app.use(cors())//配置解析application/x-www-form-urlencoded格式的表单数据的中间件app.use(express.urlencoded(&#123; extended: false &#125;))const useRouter = require(&#x27;./router/user.js&#x27;)app.use(&#x27;/api&#x27;, useRouter)app.listen(3007, () =&gt; &#123; console.log(&#x27;api server running at http://127.0.0.1:3007&#x27;);&#125;) 安装并配置mysql模块12345678910// /db/index.jsconst mysql = require(&#x27;mysql2&#x27;)const db = mysql.createPool(&#123; host: &#x27;127.0.0.1&#x27;, user: &#x27;root&#x27;, password: &#x27;123456&#x27;, database: &#x27;my_db_01&#x27;&#125;)module.exports = db 12345678910111213141516171819const db = require(&#x27;./db&#x27;)const bcrypt = require(&#x27;bcryptjs&#x27;)const userInfo = &#123; account: &#x27;sherlock&#x27;, password: &#x27;aptx4869&#x27;&#125;const sqlStr = &#x27;select * from rabbit_users where account=?&#x27;db.query(sqlStr, userInfo.account, (err, results) =&gt; &#123; if (err) &#123; console.log(err.message) &#125; if (results.length === 1 &amp;&amp; bcrypt.compareSync(userInfo.password, results[0].password)) &#123; console.log(&#x27;登录成功&#x27;) &#125; else &#123; res.cc(&#x27;登录失败！&#x27;) &#125;&#125;) 加密解密1npm i bcryptjs 12const bcrypt = require(&#x27;bcryptjs&#x27;)userinfo.password = bcrypt.hashSync(userinfo.password,10)","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://example.com/tags/node-js/"}]},{"title":"数据库","slug":"数据库","date":"2024-10-15T09:17:26.000Z","updated":"2024-10-22T12:14:50.545Z","comments":true,"path":"2024/10/15/数据库/","permalink":"http://example.com/2024/10/15/%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"数据库系统概论概述 四个基本概念 数据(data)：描述事物的符号记录称为数据 数据库(DB)：长期储存在计算机内的，有组织的、可共享的大量数据的集合。 数据库管理系统(DBMS)：计算机基础软件。具有 数据定义功能(DDL)，定义数据对象的组成和结构 数据组织存储和管理 数据操纵功能（DML），实现数据的增删改查 数据库的事务管理和运行管理 数据库的建立和维护功能 数据库系统（DBS）：由数据库（DB）、数据库管理系统（DBMS）、应用程序（APP）和数据库管理员（DBA）组成的存储、管理、处理和维护数据的系统。 数据库系统的特点 数据结构化 数据共享性高、冗余度低且易扩充 数据独立性高 物理独立性：应用程序与数据库中数据的物理存储相互独立。 逻辑独立性：应用程序与数据库的逻辑结构相互独立。 数据由数据库管理系统统一管理和控制 数据模型——数据库系统的核心和基础 两类数据模型 概念模型 按用户的观点来对数据和信息建模 逻辑模型和物理模型 逻辑模型：按计算机系统的观点对数据建模。包括层次模型、网状模型、关系模型、面向对象模型、对象关系数据类型、半结构化数据类型等 物理模型：数据在系统内部的表示方式和方法 逻辑模型到物理模型的转换，主要由数据库管理系统实现 概念模型 基本概念 实体：客观存在并可区分的事物 属性：实体具有的某一特性 码：唯一标志实体的属性 实体型：用实体名及其属性名集合来刻画和抽象同类实体。 联系： 实体之间的联系，通常指不同实体集之间的联系。 一种表示方法：实体-联系方法，也称为E-R模型 数据模型的组成要素 数据结构 数据操作 数据的完整性约束条件 关系模型 术语： 关系：对应一张表 元组：表中的一行 属性：表中的一列 码：某个属性组，唯一确定一个元组 域：一组具有相同数据类型是的集合 关系模式：对关系的描述 优点 与格式化模型不同，建立在严格的数学概念基础上 数据独立性保密性更高 概念单一、结构简单、清晰 存取路径对用户透明 缺点 查询效率不如格式化模型数据 数据库系统的结构 模式 模式是相对稳定的，实例是相对变动的 三级模式结构 模式，也称逻辑模式，是所有用户的公共数据视图，模式不涉及物理存储和硬件环境，与应用程序和开发环境无关。 外模式，也称子模式或用户模式，数据库用户的数据视图，外模式通常是模式的子集。 内模式，也称存储模式，是数据在数据库内部的组织方式 二级映象功能与数据独立性 数据独立性是指应用程序与数据库的数据结构之间相互独立 在物理结构改变时，尽量不影响应用程序，称为物理数据独立性 在逻辑结构改变时，尽量不影响应用程序，称为逻辑数据独立性 外模式&#x2F;模式映像 模式改变时，可使外模式保持不变，保证逻辑独立性 模式&#x2F;内模式映像 存储结构发生改变时，可使模式保持不变，保证物理独立性 数据库模式是数据库的中心与关键，应首先确定。 关系数据库结构及定义 在数据库中存储的是数据以及数据之间的联系。 定义 域 笛卡尔积 元组和分量 基数：一个域允许的不同取值的个数 关系 关系的度（单元关系，二元关系） 候选码（能唯一表示一个元组的属性集）——&gt;挑一个作为主码 主属性：候选码的诸属性其余——非主属性或非码属性 全码：关系模式的所有属性是这个关系模式的候选码 三种类型： 基本关系，又称基本表 查询表 视图表 六条性质： 行的顺序无所谓 列的顺序无所谓 列是同质的 不同列可出自同一域 任意两个元组候选码不同 分量必须取原子值（最基本的一条，满足即为第一范式） 关系模式 关系模式是静态的、稳定的，而关系是动态的 基本关系操作 查询操作 选择 投影 并 差 笛卡尔积&#x2F;&#x2F;以上5种基本数据操作 连接 除 交 插入、删除、修改操作 结构化查询语言SQL集 查询 数据定义语言 数据操纵语言 数据控制语言于一体的关系数据语言。 关系的完整性 实体完整性：若属性A是关系R的主属性，则A不能取空值。 参照完整性：若属性F是关系R的外码，它与基本关系S的主码相对应，则对于R上的每一个元组在F上的值应该或者取空值、或者取S中某个元组的主码值。 用户定义的完整性 实体完整性和参照完整性是关系的两个不变性。 关系代数 传统集合运算 并 差 交 笛卡尔积 关系运算象集：给定关系R（X,Z）,x在R中的象集为Zx，表示R中属性组X上的属性值为x的诸元组在Z上分量的集合，是属性组值的子集关系运算的定义： 选择 投影 连接常用： 等值连接 自然连接，一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。 外连接：保留悬浮元组 左外连接：只保留左边关系的悬浮元组 右外连接：只保留右边关系的悬浮元组 除：若T为R除以S的结果，则T包含所有在R中而不在S中的属性及其值，且T与S的所有组合均在R中。 SQL SQL的特点 综合统一 高度非过程化 面向集合的操作方式 以同一种语法结构提供多种使用方式：交互式和嵌入式 语言简洁，易学易用 SQL的基本概念 外模式包括视图和若干基本表，模式包括若干基本表，内模式包括若干存储文件。 在关系数据库管理系统中一个关系就对应一个基本表。一个或多个表对应一个存储文件，一个表可以带若干索引。索引也放在存储文件当中。 数据定义模式的定义与删除 建立模式12CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]; 删除模式1DROP SCHEMA &lt;CASCADE|RESRICT&gt;; 基本表的定义、删除与修改 创建表123456CREATE TABLE &lt;表名&gt; (&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;][,&lt;列名&gt;&lt;数据类型&gt;[&lt;列级完整性约束条件&gt;]]...[,&lt;表级完整性约束条件&gt;]); 模式与表 在表中给出模式名，如CREATE TABLE “&lt;模式名&gt;”.&lt;表名&gt; 创建模式语句同时创建表 设置所属模式，如下123SHOW search_path; #显示当前搜索路径SET search_path TO &quot;&lt;模式名&gt;&quot;,PUBLIC; #设置搜索路径CREATE TABLE &lt;表名&gt;(); 修改基本表123456ALTER TABLE &lt;表名&gt;[ADD [COLUMN] &lt;新列名&gt;&lt;数据类型&gt; [完整性约束]][ADD &lt;表级完整性约束&gt;][DROP[COLUMN]&lt;列名&gt;[CASCADE|RESCTICT]][DROP CONSTRAINT&lt;完整性约束名&gt;[CASCADE|RESTRICT]][ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;]; 删除表1DROP TABLE &lt;表名&gt; [RESTRICT|CASCADE]; 索引的建立与删除 建立索引12CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt;ON &lt;表名&gt;(&lt;列名&gt;[&lt;ASC|DESC&gt;][,&lt;列名&gt;[&lt;ASC|DESC&gt;]]...); 修改索引1ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;; 删除索引1DROP INDEX &lt;索引名&gt;; 数据操纵数据查询 SELECT语句 12345SELECT [ALL|DISTINCT]&lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]...FROM &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;...]|(SELECT语句)[AS](别名)[WHERE &lt;条件表达式&gt;][GROUP BY &lt;列名1&gt; [HAVING &lt;条件表达式&gt;]][ORDER BY &lt;列名2&gt; [ASC|DESC]]; tips SELECT * —-查询全部列 常用查询条件 &#x3D;,&gt;,&lt;,&gt;&#x3D;,&lt;&#x3D;,&lt;&gt;,!&gt;,!&lt;;NOT+ 上述比较符 [NOT] BETWEEN AND [NOT] IN [NOT] LIKE IS [NOT] NULL AND,OR,NOT 聚集函数 COUNT(*) ！！！不忽略空值NULL COUNT([DISTINCT|ALL]&lt;列名&gt;) SUM([DISTINCT|ALL]&lt;列名&gt;) AVG([DISTINCT|ALL]&lt;列名&gt;) MAX([DISTINCT|ALL]&lt;列名&gt;) MIN([DISTINCT|ALL]&lt;列名&gt;) GROUP BY子句 + HAVING子句 连接查询 等值与非等值连接查询 自身连接（要给表取两个别名） 外连接 多表连接 嵌套查询 相关定义： 一个SELECT-FROM-WHERE语句称为一个查询块，将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询 外层查询又称父查询，内层查询又称子查询 子查询不能使用ORDER BY语句 不相关子查询：子查询的查询条件不依赖于父查询 相关子查询：子查询的查询条件依赖于父查询，不能一次性将子查询的结果求解出来，而是反复求值 嵌套查询中维持ANY&#x2F;SOME表示任一，ALL表示所有（任意） 带有EXISTS谓词的子查询，产生ture或false。（！！！所有带有IN谓词，、比较运算符、ANY和ALL谓词的子查询都能用带EXISTS的子查询等价替代） 空值进行四则运算还是空值 集合查询–各查询结果列数必须相同，对应数据项的数据类型也必须相同 UNION–自动去掉重复元组，如要保留则用UNION ALL操作符。 INTERSECT EXCEPT 派生表查询：子查询嵌套于FROM子句中。（！！！AS关键字可以省略，但必须为派生关系指定别名） 插入数据12INSERT INTO &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]...)]VALUES(&lt;常量1&gt;[,&lt;常量2&gt;]...); 或 12INSERT INTO &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]...)]子查询; 修改数据123UPDATE &lt;表名&gt;SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]...[WHERE &lt;条件&gt;]; 删除数据12DELETE FROM &lt;表名&gt;[WHERE &lt;条件&gt;]; 视图——只存放定义，不存放数据 建立视图123CREATE VIEW &lt;视图名&gt; [&lt;列名&gt;[,&lt;列名&gt;]...]AS &lt;子查询&gt;[WITH CHECK OPTION]; 创建视图时并不执行SELECT语句，对视图查询时，才将数据查出。 删除视图1DROP VIEW &lt;视图名&gt; CASCADE; 视图的作用 视图能够简化用户操作 视图使用户能以多角度看待同一数据 视图对重构数据库提供了一定程度的逻辑独立性 视图能够对机密数据提供安全保护 更加清晰地表达查询 数据库安全授予与收回权限（控制类指令）–实现自主存取控制 用户权限由两要素组成：数据库对象和操作类型 GRANT：授予用户对列的操作权限1234GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION]; REVOKE1234REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]...FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE|RESTRINCT]; 创建数据库模式的权限1CREATE USER &lt;username&gt; [WITH][DBA|RESOURCE|CONNECT]; 数据库角色 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。 创建角色1CREATE ROLE &lt;角色名&gt;; 给角色授权123GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt; &lt;对象名&gt;TO &lt;角色&gt;[,&lt;角色&gt;]...; 将一个角色授权给其他角色或用户123GRANT &lt;角色1&gt;[,&lt;角色2&gt;]...TO &lt;角色3&gt;[,&lt;用户1&gt;]...[WITH ADMIN OPTION]; 角色权限的收回123REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;角色&gt;[,&lt;角色&gt;]... 强制存取控制敏感度标记：TS&gt;&#x3D;S&gt;&#x3D;C&gt;&#x3D;P规则： 仅当主体的许可证级别大于或者等于客体的密级时，改主体才能读取相应的客体。 仅当主体的许可证级别小于或者等于客体的密级时，改主体才能写相应的客体。 审计功能–一种事后检查的安全机制 记录一切成功和不成功的操作-AUDIT&#x2F;NOAUDIT12[NO]AUDIT &lt;操作名&gt;[,&lt;操作名&gt;]...ON &lt;表名&gt;; 数据加密 存储加密 传输加密 其他安全性保护 推理控制 隐蔽信道 数据隐私保护 数据库完整性——数据库的正确性和相容性 实体完整性 检查主码值是否唯一，如果不唯一则拒绝插入或修改 检查主码的各个属性是否为空，只要有一个空值就拒绝插入或修改。 参照完整性 （破坏参照完整性的）操作 违约处理 参照表插入元组 拒绝 参照表修改外码值 拒绝 被参照表删除元组 拒绝&#x2F;级联删除&#x2F;设置为空值 被参照表修改主码值 拒绝&#x2F;级联删除&#x2F;设置为空值 3. 用户自定义的完整性 1. 属性上的约束条件——不满足则拒绝执行 - NOT NULL - UNIQUE - CHECK短语 2. 元组上的约束条件——不满足则拒绝执行 完整性命令约束命名子句 完整性约束命名子句(新建表时)1CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;; 修改表中的完整性限制 删除完整性约束 12ALTER TABLE &lt;表名&gt;DROP CONSTRAINT &lt;完整性约束条件名&gt;; 增加完整性约束 12ALTER TABLE &lt;表名&gt;ADD CONSTRAINT &lt;完整性约束条件名&gt; &lt;完整性约束条件&gt;; 断言 通过声明断言来指定更具一般性的约束。可以定义涉及多个表或聚集操作的比较复杂的完整性约束，任何使断言不为真值的操作都会被拒绝执行。 创建断言语句1CREATE ASSERTION &lt;断言名&gt; &lt;CHECK 子句&gt;; 删除断言语句1DROP ASSERTION &lt;断言名&gt;; 触发器 定义触发器12345CREATE TRIGGER &lt;触发器名&gt;&#123;BEFORE|AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;REFERENCES NEW|OLD ROW AS &lt;变量&gt;FOR EACH &#123;ROW|STATEMENT&#125;[WHEN &lt;触发条件&gt;] &lt;触发动作体&gt;; 激活触发器， 多个触发器时： 执行该表上的BEFORE触发器 激活触发器的SQL语句 执行该表上的AFTER触发器 删除触发器1DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;; 关系数据理论 相关术语 函数依赖：R(U)是属性集U上的关系模式，X，Y是U的子集。对于R的任意一个可能关系r，r中不可能存在两个元组在X上的属性值相等，在Y上的属性值不等，称Y函数依赖于X，记作X-&gt;Y。 若Y$\\subseteqq$X，为平凡的函数依赖。 部分函数依赖：X-&gt;Y，若对于X的每一个真子集X’，X’-&#x2F;-&gt;Y，则称Y对X完全函数依赖，记作X$\\frac{F}{}$&gt;Y。否则称为部分函数依赖。 传递函数依赖：X-&gt;Y,Y-&#x2F;-&gt;X，Y-&gt;Z(Z$\\subsetneqq$Y，Y$\\subsetneqq$X)，称Z传递函数依赖于X，记作X$\\frac{传递}{}$&gt;Z。 超码：K为R&lt;U,F&gt;中的属性或属性组合，K-&gt;U，称K为超码。 候选码：K$\\frac{F}{}$&gt;U,称K为候选码。(特殊的超码) 主码：选定的一个候选码。 全码：整个属性组是码。 主属性：包含在任何一个候选码中的属性。 非主属性&#x2F;非码属性：不包含在任何候选码中的属性。 多值依赖：X，Y，Z是U的子集，且Z&#x3D;U-X-Y，若给定一对(x,z)值，有一组Y值，这组值仅仅决定于x值而与z无关。称Y多值依赖于X，记作X-&gt;-&gt;Y。 闭包：$X^{+}{F}$&#x3D;{A|X-&gt;A能由F导出}，$X^{+}{F}$称为属性集X关于函数依赖集F的闭包。 最小依赖集&#x2F;最小覆盖： 任一函数依赖右部仅含一个属性。 函数依赖个数精简到最少 函数依赖的左部精简到最少 范式 第一范式（1NF）：每一个分量都是不可分的数据项 第二范式（2NF）：1NF&amp;不存在非主属性对任一候选码的部分函数依赖。 第三范式（3NF）：2NF&amp;不存在非主属性对任一候选码的传递函数依赖。 所有属性都是主属性的模式最高一定可以达到 BC范式（BCNF）:每一个决定因素都包含码，消除了插入、删除的异常。满足： 3NF 所有主属性对于任一不包含它的码也是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性。 (全码组成的关系模式最高一定可以到达||3NF+唯一候选码||二元模式最高一定可以到达) 4NF：属性之间不允许有非平凡且非函数依赖的多值依赖 判断范式 求候选码 如果有属性只在函数依赖集的左边出现，则该属性一定包含在候选码中（继续求它的闭包，如果他的闭包是属性全集，则为候选码，如果不是，则需要结合其他属性求闭包，继而判断是否是候选码） 只在函数依赖集右边出现的属性，一定不属于候选码 对于左右都出现过的属性：（1）先结合只在左边出现的属性求闭包，看看是否包括所有属性，如果他的闭包是属性全集，则为候选码；（2）如果没有包括所有属性，就结合其他左右都出现的求闭包，看看是否包括所有属性，如果他的闭包是属性全集，则为候选码 如果有属性不在函数依赖集中出现（外部属性），那么一定包含在候选码中（继续求它的闭包，如果他的闭包是属性全集，则为候选码，如果不是，则需要结合其他属性求闭包，继而判断是否是候选码） 分主属性、非主属性 判断范式。 规范化1NF$\\frac{消除非主属性对码的部分函数依赖}{}$&gt;2NF$\\frac{消除非主属性对码的传递函数依赖}{}$&gt;3NF$\\frac{消除主属性对码的部分和传递函数依赖}{}$&gt;BCNF$\\frac{消除非平凡且非函数依赖的多值依赖}{}$&gt;4NF 函数依赖的公理系统 推理规则——Armstrong公理系统 自反率：若Y$\\subseteqq$X$\\subseteqq$U，则X——&gt;Y被F所蕴含 增广率：若X——&gt;Y被F所蕴含，且Z$\\subseteqq$U，则XZ——&gt;YZ被F所蕴含 传递率：若X——&gt;Y及Y——&gt;Z被F所蕴含，则X——&gt;Z被F所蕴含 模式的分解无损连接性 保证不丢失信息 判断无损连接 保持函数依赖性 减轻或解决各种异常情况 判断保持函数依赖： 求投影F’&#x3D;F1∪F2∪…Fn是否包含全部函数依赖。 对于缺少的函数依赖，求左侧属性在判断F’中的闭包是否蕴含右侧。（$F’^{+}$&#x3D;&#x3D;$F^{+}$?） 模式分解算法 保持函数依赖，最多可以达到3NF。 保持无损连接性，最多可以达到4NF。 保持函数依赖和无损连接性，最多可以达到3NF 数据库恢复技术 事务的基本概念 事务的定义：用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。 事务通常以BEGIN TRANSACTION开始，以COMMIT（提交）或ROLLBACK（回滚）结束。 事务的ACID特性： 原子性：事务是数据库的逻辑工作单位，事务中所包括的诸操作要么都做，要么都不做。 一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。 隔离性：对于并发执行而言，一个事务的执行不能被其他事务干扰。 持久性：也称永久性，一个事务一旦提交，它对数据库中数据的改变就应该是永久的。 故障的种类 事务内部的故障：非预期的，不能由应用程序处理的。 常见原因： 运算溢出 并发进程发生死锁而被选中撤销该事务 违反了某些完整性限制 恢复操作：事务撤销（UNDO）：反向扫描日志文件，查找事务的更新操作执行逆操作 系统故障：称为软故障，指造成系统停止运转的任何事件，使得系统要重新启动 常见原因 特定类型的硬件错误 操作系统故障 DBMS代码错误 系统断电 恢复策略 正向扫描日志文件 发生系统故障时，事务未提交：强行撤销所有未完成的事务 发生系统故障时，事务已提交，但缓冲区的信息未完全写回到磁盘上：重做所有已提交的事务。 介质故障：称为硬故障，指外存故障。 常见原因 磁盘损坏 磁头碰撞 操作系统的某种潜在错误 瞬时强磁场干扰 恢复策略 装入数据库发生介质故障前某个时刻的数据副本 重做此时起的所有成功事务，将这些事务已提交的结果重新记入数据库。 使用检查点改善恢复效率 数据库镜像 计算机病毒 人为故障或破坏的计算机程序，可以繁殖和传播，等同于介质故障。 恢复的实现技术 基本原理：冗余——利用存储在系统其他地方的冗余数据来重建数据库中已被破坏或不正确的那部分数据。 如何建立冗余数据？数据转储和登记日志文件 数据转储 转储方式分类 海量转储 增量转储 转储状态分类 动态转储 静态转储 登记日志文件——用来记录事务对数据库的更新操作的文件 登记内容（每个登记内容作为日志文件的一个日志记录）： 各个事务开始标记 各个事务结束登记 各个事务的所有更新操作 日志记录内容 事务标识 操作类型 操作对象 更新前数据的旧值 更新后数据的新值 作用： 进行事务故障和系统故障恢复 协助后备副本对介质故障进行恢复 登记日志文件时必须遵循两条原则： 登记的次序严格按并发事务执行的时间次序。 必须先写日志文件，后写数据库。 并发控制 概述 事务是并发控制的基本单位 并发操作带来的数据不一致性 丢失修改 读“脏”数据 不可重复读&#x2F;幻影现象 主要方法 封锁 时间戳 乐观控制法 多版本控制 封锁 排他锁&#x2F;写锁（X锁） 共享锁（S锁） 封锁协议： 一级封锁协议：修改数据之前必须加X锁，直到事务结束才释放——解决丢失修改 二级封锁协议：读数据之前必须加S锁，读完后释放——解决读脏数据 三级封锁协议：读数据之前必须加S锁，直到事务结束才释放——解决不可重复读 活锁和死锁 当两个（或多个）并发的事务分别等待对方释放封锁的资源，而使事务处于长期等待状态的现象称为死锁。 解决活锁的方法：先来先服务策略 解决死锁的两种方法： 预防： 一次封锁法:为了完成一个事务，一次性封锁所需要的全部表 顺序封锁法:所有的事务约定都按相同的顺序来封锁表 诊断与解除 超时法 事务等待图法 并发调度的可串行性——并发事务正确调度的准则 冲突可串行化是可串行化的充分条件 两段锁协议 事务分为两个阶段 扩展阶段，获得封锁 收缩阶段，释放封锁 事务遵守两段锁协议是可串行化的充分条件 封锁的粒度 封锁对象的大小称为封锁粒度，封锁对象可以是逻辑对象，也可以是物理对象 封锁粒度越大、数据库所能封锁的数据单元就越少，并发度就越小，系统开销越小；反之，封锁粒度越小、数据库所能封锁的数据单元就越多，并发度就越大，系统开销越大 多粒度封锁 显示封锁：应事务要求直接加到数据对象上的锁 隐式封锁：由于上级对象加锁而导致该数据对象加上了锁","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"node.js","slug":"node-js","date":"2024-10-12T13:31:48.000Z","updated":"2024-10-17T07:03:04.934Z","comments":true,"path":"2024/10/12/node-js/","permalink":"http://example.com/2024/10/12/node-js/","excerpt":"","text":"fs文件系统读取文件内容12345678910111213141516171819202122232425const fs = require(&quot;fs&quot;);// 异步读取fs.readFile(&#x27;input.txt&#x27;,&#x27;utf8&#x27;, function (err, data) &#123; //如果读取成功，则err的值为null //如果读取失败，则err的值为错误对象，dataStr的值为undefined if (err) &#123; return console.error(err); &#125; console.log(&quot;异步读取: &quot; + data.toString());&#125;);// 同步读取var data = fs.readFileSync(&#x27;input.txt&#x27;);console.log(&quot;同步读取: &quot; + data.toString());console.log(&quot;程序执行完毕。&quot;);//执行结果同步读取: 文件读取实例程序执行完毕。异步读取: 文件读取实例 写入文件内容1234567const fs = require(&quot;fs&quot;);fs.writeFile(&#x27;input.txt&#x27;, &#x27;我是通 过fs.writeFile 写入文件的内容&#x27;, function(err) &#123; if (err) &#123; return console.error(err); &#125;&#125;) 处理路径问题__dirname表示当前文件所处目录 path路径模块1const path = require(&quot;path&quot;) 方法 描述 path.join([path1][, path2][, …]) 用于连接路径。 path.basename() 获取路径中的文件名 path.extname(p) 获取文件的扩展名 path.dirname(p) 返回路径中代表文件夹的部分 path.resolve([from …], to) 将 to 参数解析为绝对路径 path.relative(from, to) xxxxxxxxxx import requestInstance from ‘.&#x2F;http’​export { requestInstance as http }typescript http创建服务器123456789const http = require(&#x27;http&#x27;)const server = http.createServer()server.on(&#x27;request&#x27;, function (req, res) &#123; console.log(&#x27;Someone visit our web server.&#x27;)&#125;)server.listen(8080, function () &#123; console.log(&#x27;服务器启动了，运行在http://127.0.0.1:8080&#x27;)&#125;) req请求对象属性 描述 req.url 客户端请求的url地址 req.method 客户端请求方式 req.session 访问和使用session对象，需要配置express-session中间件 req.session.destroy() 清空session对象 res响应对象属性 描述 res.end() 向客户端响应内容 res.writeHead(200, { “Content-Type”: “text&#x2F;html; charset&#x3D;utf-8” }) 写入响应头 res.setHeader(“Content-Type”,”text&#x2F;html; charset&#x3D;utf-8”) 设置响应头的内容类型，解决中文乱码 模块化模块作用域自定义模块中定义的方法、变量等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。 module对象在每一个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息 module.exports可以将模块内的成员共享出去，供外界使用。外界用require()方法导入自定义模块时，得到的就是module.exports所指向的对象（也可写成exports） npm命令 npm init -y：新建包管理配置文件 npm uninstall：卸载包 npm install -D：安装包到开发环境中，这些包只在项目开发环境中用到，如sass,记录在devDependencies节点中 npm install：安装到开发和生产环境中，记录在dependencies节点中 npm install -g：安装为全局包 Express封装的http模块 安装1npm i express 创建基本的Web服务器1234567891011121314//1.导入 expressconst express = require(&#x27;express&#x27;)//2.创建 web 服务器const app = express()app.get(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#123; name: &#x27;hzx&#x27;, age: 20, gender: &#x27;男&#x27; &#125;)&#125;)app.post(&#x27;/user&#x27;, (req, res) =&gt; &#123; res.send(&#x27;请求成功&#x27;)&#125;)//3. 启动 web 服务器app.listen(80, () =&gt; &#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 获取请求参数req.query 通过?匹配到的参数 req.params 通过:匹配到的动态参数 req.body 请求体数据，需要调用express.json()和express.urlencoded({extended:false})中间件 托管静态资源app.use(express.static(‘public’)) 如果要托管多个静态资源目录，多次调用express.static()函数，访问静态资源函数时，根据目录的添加顺序查找所需的文件 挂载路径前缀：app.use(“&#x2F;public”,express.static(‘public’)) nodemonnodemon能够监听项目文件的变动，当代码被修改后，nodemon会自动帮我们重启项目。 安装npm install -g nodemon 使用nodemon test.js 路由Express中的路由分3部分组成，分别是请求的类型、请求的URL地址、处理函数 1app.METHOD(PATH,HANDLER(req,res)) 模块化路由为了方便对路由进行模块化的管理，推荐将路由抽离为单独的模块 创建路由模块对应的.js文件 调用express.Router()函数创建路由对象 向路由对象上挂载具体的路由 module.exports向外共享路由对象 使用app.use()函数注册路由模块 示例代码12345678910//router.jsconst express = require(&#x27;express&#x27;)const router = express.Router()router.get(&#x27;/user/list&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Get user list.&#x27;)&#125;)router.post(&#x27;/user/add&#x27;, (req, res) =&gt; &#123; res.send(&#x27;Add new user.&#x27;)&#125;)module.exports = router 123456789101112//index.js//1.导入 expressconst express = require(&#x27;express&#x27;)//2.创建 web 服务器const app = express()//注册路由模块const router = require(&#x27;./router&#x27;)app.use(router)//3. 启动 web 服务器app.listen(80, () =&gt; &#123; console.log(&#x27;express server running at http://127.0.0.1&#x27;)&#125;) 中间件作用：对请求进行预处理 中间件的格式123app.get(&#x27;/&#x27;,function(req,res,next)&#123;next()//把流转关系转交给下一个中间件或者路由&#125;) 全局生效的中间件123456789101112const app = express()const mw = function (req,res,next)&#123; console.log(&#x27;这是最简单的中间件函数&#x27;) next()&#125;app.use(mw)app.get(&#x27;/&#x27;,(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;)app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.send(&quot;User Page&quot;)&#125;) 局部生效的中间件12345678const app = express()const mw = function (req,res,next)&#123; console.log(&#x27;这是最简单的中间件函数&#x27;) next()&#125;app.get(&#x27;/&#x27;,mw,(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;) 多个局部生效的中间件123456app.get(&#x27;/&#x27;,mw1,mw2,(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;)app.get(&#x27;/&#x27;,[mw1,mw2],(req,res)=&gt;&#123; res.send(&#x27;Home Page.&#x27;)&#125;) 注意事项 在路由之前注册中间件 客户端发送的请求，可以连续调用多个中间件进行处理 执行完中间件后，要调用next()函数 调用next()函数后，不要再写业务逻辑 多个中间件共享req、res对象 中间件的分类 应用级别：app.use(),app.get(),app.post() 路由级别：绑定在express.Router()实例上 错误级别：function处理函数中必须有4个形参，分别是(err,req,res,next)。必须注册在所有路由之后！ Express内置 express.static快速托管静态资源的内置中间件 express.json解析JSON格式的请求体数据 12345app.use(express.json())app.post(&#x27;/user&#x27;, function (req, res) &#123; console.log(req.body) res.send(&#x27;ok&#x27;)&#125;) express.urlencoded({extended:false})解析URL-encoded格式的请求体数据 第三方 1234567891011121314151617//定义中间件const bodyParser = (req, res, next) =&gt; &#123; let str = &#x27;&#x27; req.on(&#x27;data&#x27;, (chunk) =&gt; &#123; str += chunk &#125;) req.on(&#x27;end&#x27;, () =&gt; &#123; req.body = querystring.parse(str) &#125;) next()&#125;module.exports = bodyParser------------------------------------//使用中间件const bodyParser = require(&#x27;./bodyParser&#x27;)app.use(bodyParser) 基于CORS解决跨域问题安装1npm install cors 导入并配置12const cors = require(&#x27;cors&#x27;)app.use(cors()) 注意：先配置cors（跨域资源共享）再配置路由 原理：CORS由一系列HTTP响应头组成，这些响应头决定浏览器是否阻止前端JS代码跨域获取资源。浏览器的同源安全策略（协议、ip地址、端口号必须相同）默认会阻止网页”跨域“获取资源。但是如果接口服务器配置了CORS相关的HTTP响应头，就可以解除浏览器端的跨域访问限制。 CORS响应头部 描述 res.setHeader(‘Access-Control-Allow-Origin’,’*’) 设置允许访问该资源的外域URL res.setHeader(‘Access-Control-Allow-Headers’,’X-Custom-Header’) 对额外的请求头进行声明 res.setHeader(‘Access-Control-Allow-Methods’,’*’) 设置实际请求所允许使用的HTTP方法 预检请求只要符合以下任何条件之一，都需要进行遇见请求： 请求方式为GET、POST、HEAD之外的请求Method类型 请求头中包含自定义头部字段 向服务器发送了application&#x2F;json格式的数据 在浏览器与服务器正式通信之前，浏览器会先发送OPTION请求进行预检，以获知服务器是否允许该实际请求，所以这一次的OPTION请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并携带真实数据。 JSONP接口浏览器通过&lt;script&gt;标签的src属性，请求服务器上的数据，同时，服务器返回一个函数的调用。这种请求数据的方式叫做JSONP JSONP不属于真正的Ajax请求，没有使用XMLHttpRequest这个对象。JSONP仅支持GET请求，不支持POST、PUT、DELETE请求。 JSONP接口要声明在CORS接口之前 操作MySQL 安装mysql2模块 1npm i mysql2 配置mysql模块 1234567const mysql = require(&#x27;mysql2&#x27;)const db = mysql.createPool(&#123; host: &#x27;127.0.0.1&#x27;, user: &#x27;root&#x27;, password: &#x27;123456&#x27;, database: &#x27;my_db_01&#x27;&#125;) 测试mysql模块是否正常工作 1234db.query(&#x27;SELECT 1&#x27;,(err,results)=&gt;&#123;if(err) return console.log(err.message)console.log(results)&#125;) 增删改查123456789101112131415const user = &#123; username:&#x27;spider-man&#x27;, password:&#x27;pcc123&#x27;&#125;const sqlStr = &#x27;insert into users (username,password) values (?,?)&#x27;db.query(sqlStr,[user.username,user.password],(err,results)=&gt;&#123; if(err) return console.log(err.message) //insert into 的返回结果为对象,select 的结果为数组 if(results.affectedRows === 1) console.log(&#x27;数据插入成功！&#x27;)&#125;)//若对象的属性值与数据表的字段一一对应const sqlStr = &#x27;insert into users set ?&#x27;db.query(sqlStr, user, (err, results) =&gt; &#123; if (err) return console.log(err.message) if (results.affectedRows === 1) console.log(&#x27;数据插入成功！&#x27;)&#125;) 12345678910111213141516const user = &#123; id: 5, username: &#x27;aaa&#x27;, password: &#x27;000123&#x27; &#125;const sqlStr = &#x27;update users set username=?,password=? where id=?&#x27;db.query(sqlStr, [user.username, user.password, user.id], (err, results) =&gt; &#123; if (err) return console.log(err.message) //update 的返回结果为对象 if (results.affectedRows === 1) console.log(&#x27;数据修改成功！&#x27;)&#125;)//若对象的属性值与数据表的字段一一对应const sqlStr = &#x27;update users set ? where id=?&#x27;db.query(sqlStr, [user, user.id], (err, results) =&gt; &#123; if (err) return console.log(err.message) //update 的返回结果为对象 if (results.affectedRows === 1) console.log(&#x27;数据修改成功！&#x27;)&#125;) 123456const sqlStr = &#x27;delete from users where id=?&#x27;db.query(sqlStr, 5, (err, results) =&gt; &#123; if (err) return console.log(err.message) //update 的返回结果为对象 if (results.affectedRows === 1) console.log(&#x27;数据删除成功！&#x27;)&#125;) 前后端的身份认证Session认证机制http的无状态性客户端的每次HTTP请求都是独立的，服务器不会主动保留每次HTTP请求的状态 突破http的无状态性设置cookie CookieCookie是存储在用户浏览器中一段不超过4KB的字符串。它由一个名称、一个值和其他几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。 客户端第一次请求服务器时，服务器通过响应头的形式，向客户端发送一个身份认证的Cookie。当客户端每次请求服务器时，浏览器自动将身份认证相关的Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份。 使用1npm install express-session 12345678const express = require(&#x27;express&#x27;)const session = require(&#x27;express-session&#x27;)const app = express()app.use(session(&#123; secret: &#x27;keyboard cat&#x27;,//可以为任意字符串 resave: false, saveUninitialized: true&#125;)) JWT认证机制session不支持跨域访问，当前端请求后端接口不跨域时，推荐使用session。当前端请求后端接口跨域时，推荐使用JWT（JSON Web Token) JWT组成成分Header.Payload.Signature Payload是真正的用户信息，是用户信息经过加密后生成的字符串 Header和Signature是安全性相关的部分，只是为了保证Token的安全性 JWT使用方式客户端收到服务器返回的JWT后，通常将它存储在localStorage和sessionStorage中 客户端把JWT放在HTTP请求头的Authorization字段中，此后每次通信都要带上这个JWT的字符串，格式如下 1Authorization: Bear &lt;token&gt; 安装及使用1npm install jsonwebtoken express-jwt 1234567891011121314151617181920212223// 1.导入用于生成JWT字符串的包const jwt = require(&#x27;jsonwebtoken&#x27;)// 2.导入将JWT字符串还原成JSON对象的包const &#123;expressjwt&#125; = require(&#x27;express-jwt&#x27;)//错误级别的中间件app.use((err, req, res, next) =&gt; &#123; //token解析失败 if (err.name === &quot;UnauthorizedError&quot;) &#123; return res.send(&#123; status: 401, message: &quot;无效的token&quot;, &#125;) &#125; res.send(&#123; status: 500, message: &quot;服务端错误&quot;, &#125;)&#125;)//.unless(&#123;&#125;)用来指定哪一些接口不需要访问权限，以下匹配/api/开头的路径const secretKey = &#x27;Sherlock Holmes ^_^&#x27;app.use(expressjwt(&#123;secret:secretKey,algorithms:[&#x27;HS256&#x27;]&#125;).unless(&#123;path:[/^\\/api\\//]&#125;)) 123456789//登录获取tokenapp.post(&#x27;/api/login&#x27;,function(req,res)&#123; res.send(&#123; status:200, message:&#x27;登录成功！&#x27;, //参数1：用户的信息对象，参数2：加密的密钥，参数3：配置对象：可以配置当前token的有效期 token:jwt.sign(&#123;username:userinfo.username&#125;,secretKey,&#123;expiresIn:&#x27;30s&#x27;&#125;) &#125;)&#125;) 12345678app.get(&#x27;/admin/getinfo&#x27;, function (req, res) &#123; res.send(&#123; status: 200, message: &quot;获取用户信息成功!&quot;, data: req.auth &#125;)&#125;) 密码加密1npm i bcryptjs 123const bcrypt = require(&#x27;bcryptjs&#x27;)// bcrypt.hashSync(明文密码，随机盐的长度)userinfo.password = bcrypt.hashSync(userinfo.password,10)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"http://example.com/tags/node-js/"}]},{"title":"设计模式","slug":"设计模式","date":"2024-10-11T16:00:44.000Z","updated":"2024-10-13T07:26:27.896Z","comments":true,"path":"2024/10/12/设计模式/","permalink":"http://example.com/2024/10/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式的分类 模式 &amp; 描述 包括 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 结构型模式 这些模式关注对象之间的组合和关系，旨在解决如何构建灵活且可复用的类和对象结构。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 行为型模式 这些模式关注对象之间的通信和交互，旨在解决对象之间的责任分配和算法的封装。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 工厂模式意图定义一个创建对象的接口，让其子类决定实例化哪一个具体的类。工厂模式使对象的创建过程延迟到子类。 主要解决接口选择的问题。 何时使用当我们需要在不同条件下创建不同实例时。 如何解决通过让子类实现工厂接口，返回一个抽象的产品。 关键代码对象的创建过程在子类中实现。 应用实例 汽车制造：你需要一辆汽车，只需从工厂提货，而不需要关心汽车的制造过程及其内部实现。 Hibernate：更换数据库时，只需更改方言（Dialect）和数据库驱动（Driver），即可实现对不同数据库的切换。 优点 调用者只需要知道对象的名称即可创建对象。 扩展性高，如果需要增加新产品，只需扩展一个工厂类即可。 屏蔽了产品的具体实现，调用者只关心产品的接口。 缺点每次增加一个产品时，都需要增加一个具体类和对应的工厂，使系统中类的数量成倍增加，增加了系统的复杂度和具体类的依赖。 使用场景 日志记录：日志可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志的位置。 数据库访问：当用户不知道最终系统使用哪种数据库，或者数据库可能变化时。 连接服务器的框架设计：需要支持 “POP3”、”IMAP”、”HTTP” 三种协议，可以将这三种协议作为产品类，共同实现一个接口。 注意事项工厂模式适用于生成复杂对象的场景。如果对象较为简单，通过 new 即可完成创建，则不必使用工厂模式。使用工厂模式会引入一个工厂类，增加系统复杂度。 结构工厂模式包含以下几个主要角色： 抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。它可以是具体产品类的父类或接口，规定了产品对象的共同方法。 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。 具体工厂（Concrete Factory）：负责实际创建具体产品的对象。 示例代码1234//抽象产品接口public interface Shape &#123; void draw();&#125; 1234567891011121314151617181920212223//具体产品public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 1234567891011121314151617//具体工厂public class ShapeFactory &#123; //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125;&#125; 12345678910111213141516171819202122232425//使用实例public class FactoryPatternDemo &#123; public static void main(String[] args) &#123; ShapeFactory shapeFactory = new ShapeFactory(); //获取 Circle 的对象，并调用它的 draw 方法 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取 Rectangle 的对象，并调用它的 draw 方法 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取 Square 的对象，并调用它的 draw 方法 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); &#125;&#125; 抽象工厂模式意图提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。 主要解决接口选择的问题。 适用场景当系统需要创建多个相关或依赖的对象，而不需要指定具体类时。 解决方案在一个产品族中定义多个产品，由具体工厂实现创建这些产品的方法。 关键代码在一个工厂中聚合多个同类产品的创建方法。 应用实例假设有不同类型的衣柜，每个衣柜（具体工厂）只能存放一类衣服（成套的具体产品），如商务装、时尚装等。每套衣服包括具体的上衣和裤子（具体产品）。所有衣柜都是衣柜类（抽象工厂）的具体实现，所有上衣和裤子分别实现上衣接口和裤子接口（抽象产品）。 优点 确保同一产品族的对象一起工作。 客户端不需要知道每个对象的具体类，简化了代码。 缺点扩展产品族非常困难。增加一个新的产品族需要修改抽象工厂和所有具体工厂的代码。 使用场景 QQ 换皮肤时，整套皮肤一起更换。 创建跨平台应用时，生成不同操作系统的程序。 注意事项增加新的产品族相对容易，而增加新的产品等级结构比较困难。 结构抽象工厂模式包含以下几个主要角色： 抽象工厂（Abstract Factory）：声明了一组用于创建产品对象的方法，每个方法对应一种产品类型。抽象工厂可以是接口或抽象类。 具体工厂（Concrete Factory）：实现了抽象工厂接口，负责创建具体产品对象的实例。 抽象产品（Abstract Product）：定义了一组产品对象的共同接口或抽象类，描述了产品对象的公共方法。 具体产品（Concrete Product）：实现了抽象产品接口，定义了具体产品的特定行为和属性。 示例代码123456789101112131415161718192021222324252627//为形状创建一个接口public interface Shape &#123; void draw();&#125;//实现接口的实体类public class Rectangle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle implements Shape &#123; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 12345678910111213141516171819202122232425//为颜色创建一个接口public interface Color &#123; void fill();&#125;//实现接口的实体类public class Red implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Red::fill() method.&quot;); &#125;&#125;public class Green implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Green::fill() method.&quot;); &#125;&#125;public class Blue implements Color &#123; @Override public void fill() &#123; System.out.println(&quot;Inside Blue::fill() method.&quot;); &#125;&#125; 12345//创建抽象工厂public abstract class AbstractFactory &#123; public abstract Color getColor(String color); public abstract Shape getShape(String shape);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142//创建具体工厂public class ShapeFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; if(shapeType == null)&#123; return null; &#125; if(shapeType.equalsIgnoreCase(&quot;CIRCLE&quot;))&#123; return new Circle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;RECTANGLE&quot;))&#123; return new Rectangle(); &#125; else if(shapeType.equalsIgnoreCase(&quot;SQUARE&quot;))&#123; return new Square(); &#125; return null; &#125; @Override public Color getColor(String color) &#123; return null; &#125;&#125;public class ColorFactory extends AbstractFactory &#123; @Override public Shape getShape(String shapeType)&#123; return null; &#125; @Override public Color getColor(String color) &#123; if(color == null)&#123; return null; &#125; if(color.equalsIgnoreCase(&quot;RED&quot;))&#123; return new Red(); &#125; else if(color.equalsIgnoreCase(&quot;GREEN&quot;))&#123; return new Green(); &#125; else if(color.equalsIgnoreCase(&quot;BLUE&quot;))&#123; return new Blue(); &#125; return null; &#125;&#125; 1234567891011//工厂创造器public class FactoryProducer &#123; public static AbstractFactory getFactory(String choice)&#123; if(choice.equalsIgnoreCase(&quot;SHAPE&quot;))&#123; return new ShapeFactory(); &#125; else if(choice.equalsIgnoreCase(&quot;COLOR&quot;))&#123; return new ColorFactory(); &#125; return null; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//使用实例public class AbstractFactoryPatternDemo &#123; public static void main(String[] args) &#123; //获取形状工厂 AbstractFactory shapeFactory = FactoryProducer.getFactory(&quot;SHAPE&quot;); //获取形状为 Circle 的对象 Shape shape1 = shapeFactory.getShape(&quot;CIRCLE&quot;); //调用 Circle 的 draw 方法 shape1.draw(); //获取形状为 Rectangle 的对象 Shape shape2 = shapeFactory.getShape(&quot;RECTANGLE&quot;); //调用 Rectangle 的 draw 方法 shape2.draw(); //获取形状为 Square 的对象 Shape shape3 = shapeFactory.getShape(&quot;SQUARE&quot;); //调用 Square 的 draw 方法 shape3.draw(); //获取颜色工厂 AbstractFactory colorFactory = FactoryProducer.getFactory(&quot;COLOR&quot;); //获取颜色为 Red 的对象 Color color1 = colorFactory.getColor(&quot;RED&quot;); //调用 Red 的 fill 方法 color1.fill(); //获取颜色为 Green 的对象 Color color2 = colorFactory.getColor(&quot;GREEN&quot;); //调用 Green 的 fill 方法 color2.fill(); //获取颜色为 Blue 的对象 Color color3 = colorFactory.getColor(&quot;BLUE&quot;); //调用 Blue 的 fill 方法 color3.fill(); &#125;&#125; 单例模式意图确保一个类只有一个实例，并提供一个全局访问点来访问该实例。 主要解决频繁创建和销毁全局使用的类实例的问题。 何时使用当需要控制实例数目，节省系统资源时。 如何解决检查系统是否已经存在该单例，如果存在则返回该实例；如果不存在则创建一个新实例。 关键代码构造函数是私有的。 应用实例 一个班级只有一个班主任。 Windows 在多进程多线程环境下操作文件时，避免多个进程或线程同时操作一个文件，需要通过唯一实例进行处理。 设备管理器设计为单例模式，例如电脑有两台打印机，避免同时打印同一个文件。 优点 内存中只有一个实例，减少内存开销，尤其是频繁创建和销毁实例时（如管理学院首页页面缓存）。 避免资源的多重占用（如写文件操作）。 缺点 没有接口，不能继承。 与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心实例化方式。 使用场景 生成唯一序列号。 WEB 中的计数器，避免每次刷新都在数据库中增加计数，先缓存起来。 创建消耗资源过多的对象，如 I&#x2F;O 与数据库连接等。 注意事项 线程安全：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成实例被多次创建。 延迟初始化：实例在第一次调用 getInstance() 方法时创建。 序列化和反序列化：重写 readResolve 方法以确保反序列化时不会创建新的实例。 反射攻击：在构造函数中添加防护代码，防止通过反射创建新实例。 类加载器问题：注意复杂类加载环境可能导致的多个实例问题。 结构单例模式包含以下几个主要角色： 单例类：包含单例实例的类，通常将构造函数声明为私有。 静态成员变量：用于存储单例实例的静态成员变量。 获取实例方法：静态方法，用于获取单例实例。 私有构造函数：防止外部直接实例化单例类。 线程安全处理：确保在多线程环境下单例实例的创建是安全的。 示例代码1234567891011121314151617181920212223242526public class SingleObject &#123; //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject()&#123;&#125; //获取唯一可用的对象 public static SingleObject getInstance()&#123; return instance; &#125; public void showMessage()&#123; System.out.println(&quot;Hello World!&quot;); &#125;&#125;public class SingletonPatternDemo &#123; public static void main(String[] args) &#123; //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); &#125;&#125; 示例代码采用饿汉方式，这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 建造者模式意图将一个复杂的构建过程与其表示相分离，使得同样的构建过程可以创建不同的表示。 主要解决在软件系统中，一个复杂对象的创建通常由多个部分组成，这些部分的组合经常变化，但组合的算法相对稳定。 何时使用当一些基本部件不变，而其组合经常变化时。 如何解决将变与不变的部分分离开。 关键代码 建造者：创建并提供实例。 导演：管理建造出来的实例的依赖关系和控制构建过程。 应用实例 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出不同的”套餐”。 Java 中的 StringBuilder。 优点 分离构建过程和表示，使得构建过程更加灵活，可以构建不同的表示。 可以更好地控制构建过程，隐藏具体构建细节。 代码复用性高，可以在不同的构建过程中重复使用相同的建造者。 缺点 如果产品的属性较少，建造者模式可能会导致代码冗余。 增加了系统的类和对象数量。 使用场景 需要生成的对象具有复杂的内部结构。 需要生成的对象内部属性相互依赖。 注意事项与工厂模式的区别是：建造者模式更加关注于零件装配的顺序。 结构建造者模式包含以下几个主要角色： 产品（Product）：要构建的复杂对象。产品类通常包含多个部分或属性。 抽象建造者（Builder）：定义了构建产品的抽象接口，包括构建产品的各个部分的方法。 具体建造者（Concrete Builder）：实现抽象建造者接口，具体确定如何构建产品的各个部分，并负责返回最终构建的产品。 指导者（Director）：负责调用建造者的方法来构建产品，指导者并不了解具体的构建过程，只关心产品的构建顺序和方式。 示例代码 123456789//食品条目和食品包装的接口public interface Item &#123; public String name(); public Packing packing(); public float price(); &#125;public interface Packing &#123; public String pack();&#125; 12345678910111213//实现Packing接口的实体类public class Wrapper implements Packing &#123; @Override public String pack() &#123; return &quot;Wrapper&quot;; &#125;&#125;public class Bottle implements Packing &#123; @Override public String pack() &#123; return &quot;Bottle&quot;; &#125;&#125; 123456789101112131415161718192021//实现Item接口的抽象类public abstract class Burger implements Item &#123; @Override public Packing packing() &#123; return new Wrapper(); &#125; @Override public abstract float price();&#125;public abstract class ColdDrink implements Item &#123; @Override public Packing packing() &#123; return new Bottle(); &#125; @Override public abstract float price();&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//扩展了 Burger 和 ColdDrink 的实体类public class VegBurger extends Burger &#123; @Override public float price() &#123; return 25.0f; &#125; @Override public String name() &#123; return &quot;Veg Burger&quot;; &#125;&#125;public class ChickenBurger extends Burger &#123; @Override public float price() &#123; return 50.5f; &#125; @Override public String name() &#123; return &quot;Chicken Burger&quot;; &#125;&#125;public class Coke extends ColdDrink &#123; @Override public float price() &#123; return 30.0f; &#125; @Override public String name() &#123; return &quot;Coke&quot;; &#125;&#125;public class Pepsi extends ColdDrink &#123; @Override public float price() &#123; return 35.0f; &#125; @Override public String name() &#123; return &quot;Pepsi&quot;; &#125;&#125; 123456789101112131415161718192021222324252627//Meal 类，带有上面定义的 Item 对象import java.util.ArrayList;import java.util.List; public class Meal &#123; private List&lt;Item&gt; items = new ArrayList&lt;Item&gt;(); public void addItem(Item item)&#123; items.add(item); &#125; public float getCost()&#123; float cost = 0.0f; for (Item item : items) &#123; cost += item.price(); &#125; return cost; &#125; public void showItems()&#123; for (Item item : items) &#123; System.out.print(&quot;Item : &quot;+item.name()); System.out.print(&quot;, Packing : &quot;+item.packing().pack()); System.out.println(&quot;, Price : &quot;+item.price()); &#125; &#125; &#125; 1234567891011121314151617//建造者public class MealBuilder &#123; public Meal prepareVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal; &#125; public Meal prepareNonVegMeal ()&#123; Meal meal = new Meal(); meal.addItem(new ChickenBurger()); meal.addItem(new Pepsi()); return meal; &#125;&#125; 123456789101112131415public class BuilderPatternDemo &#123; public static void main(String[] args) &#123; MealBuilder mealBuilder = new MealBuilder(); Meal vegMeal = mealBuilder.prepareVegMeal(); System.out.println(&quot;Veg Meal&quot;); vegMeal.showItems(); System.out.println(&quot;Total Cost: &quot; +vegMeal.getCost()); Meal nonVegMeal = mealBuilder.prepareNonVegMeal(); System.out.println(&quot;\\n\\nNon-Veg Meal&quot;); nonVegMeal.showItems(); System.out.println(&quot;Total Cost: &quot; +nonVegMeal.getCost()); &#125;&#125; 原型模式意图使用原型实例指定要创建对象的种类，并通过拷贝这些原型创建新的对象。 主要解决在运行时动态建立和删除原型。 何时使用 系统应独立于产品的创建、构成和表示。 需要在运行时指定实例化的类，例如通过动态加载。 避免创建与产品类层次平行的工厂类层次。 类的实例只能有几种不同状态组合，克隆原型比手工实例化更方便。 如何解决通过已有的一个原型对象，快速生成与原型对象相同的实例。 关键代码 实现克隆操作： 在 Java 中，实现 Cloneable 接口，重写 clone() 方法。 在 .NET 中，使用 Object 类的 MemberwiseClone() 方法实现浅拷贝，或通过序列化实现深拷贝。 隔离类对象的使用者和具体类型之间的耦合关系，要求”易变类”拥有稳定的接口。 应用实例 细胞分裂 Java 中的 Object.clone() 方法 优点 性能提高 避免构造函数的约束 缺点 配备克隆方法需要全面考虑类的功能，对已有类可能较难实现，特别是处理不支持串行化的间接对象或含有循环结构的引用时。 必须实现 Cloneable 接口。 使用场景 资源优化 类初始化需要消耗大量资源（如数据、硬件资源） 性能和安全要求高的场景 通过 new 创建对象需要复杂的数据准备或访问权限时 一个对象需要多个修改者 对象需提供给其他对象访问并可能被各个调用者修改时 通常与工厂方法模式一起使用，通过 clone 创建对象，然后由工厂方法提供给调用者 注意事项与直接实例化类创建新对象不同，原型模式通过拷贝现有对象生成新对象。浅拷贝通过实现 Cloneable 实现，深拷贝通过实现 Serializable 读取二进制流实现。 结构原型模式包含以下几个主要角色： 原型接口（Prototype Interface）：定义一个用于克隆自身的接口，通常包括一个 clone() 方法。 具体原型类（Concrete Prototype）：实现原型接口的具体类，负责实际的克隆操作。这个类需要实现 clone() 方法，通常使用浅拷贝或深拷贝来复制自身。 客户端（Client）：使用原型实例来创建新的对象。客户端调用原型对象的 clone() 方法来创建新的对象，而不是直接使用构造函数。 示例代码123456789101112131415161718192021222324252627282930//实现了Cloneable接口的抽象类public abstract class Shape implements Cloneable &#123; private String id; protected String type; abstract void draw(); public String getType()&#123; return type; &#125; public String getId() &#123; return id; &#125; public void setId(String id) &#123; this.id = id; &#125; public Object clone() &#123; Object clone = null; try &#123; clone = super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return clone; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334//扩展了Shape的实体类public class Rectangle extends Shape &#123; public Rectangle()&#123; type = &quot;Rectangle&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Rectangle::draw() method.&quot;); &#125;&#125;public class Square extends Shape &#123; public Square()&#123; type = &quot;Square&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Square::draw() method.&quot;); &#125;&#125;public class Circle extends Shape &#123; public Circle()&#123; type = &quot;Circle&quot;; &#125; @Override public void draw() &#123; System.out.println(&quot;Inside Circle::draw() method.&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829import java.util.Hashtable; public class ShapeCache &#123; private static Hashtable&lt;String, Shape&gt; shapeMap = new Hashtable&lt;String, Shape&gt;(); public static Shape getShape(String shapeId) &#123; Shape cachedShape = shapeMap.get(shapeId); return (Shape) cachedShape.clone(); &#125; // 对每种形状都运行数据库查询，并创建该形状 // shapeMap.put(shapeKey, shape); // 例如，我们要添加三种形状 public static void loadCache() &#123; Circle circle = new Circle(); circle.setId(&quot;1&quot;); shapeMap.put(circle.getId(),circle); Square square = new Square(); square.setId(&quot;2&quot;); shapeMap.put(square.getId(),square); Rectangle rectangle = new Rectangle(); rectangle.setId(&quot;3&quot;); shapeMap.put(rectangle.getId(),rectangle); &#125;&#125; 1234567891011121314public class PrototypePatternDemo &#123; public static void main(String[] args) &#123; ShapeCache.loadCache(); Shape clonedShape = (Shape) ShapeCache.getShape(&quot;1&quot;); System.out.println(&quot;Shape : &quot; + clonedShape.getType()); Shape clonedShape2 = (Shape) ShapeCache.getShape(&quot;2&quot;); System.out.println(&quot;Shape : &quot; + clonedShape2.getType()); Shape clonedShape3 = (Shape) ShapeCache.getShape(&quot;3&quot;); System.out.println(&quot;Shape : &quot; + clonedShape3.getType()); &#125;&#125; 适配器模式目的将一个类的接口转换为另一个接口，使得原本不兼容的类可以协同工作。 主要解决的问题在软件系统中，需要将现有的对象放入新环境，而新环境要求的接口与现有对象不匹配。 使用场景 需要使用现有类，但其接口不符合系统需求。 希望创建一个可复用的类，与多个不相关的类（包括未来可能引入的类）一起工作，这些类可能没有统一的接口。 通过接口转换，将一个类集成到另一个类系中。 实现方式 继承或依赖：推荐使用依赖关系，而不是继承，以保持灵活性。 关键代码适配器通过继承或依赖现有对象，并实现所需的目标接口。 应用实例 电压适配器：将 110V 电压转换为 220V，以适配不同国家的电器标准。 接口转换：例如，将 Java JDK 1.1 的 Enumeration 接口转换为 1.2 的 Iterator 接口。 跨平台运行：在Linux上运行Windows程序。 数据库连接：Java 中的 JDBC 通过适配器模式与不同类型的数据库进行交互。 优点 促进了类之间的协同工作，即使它们没有直接的关联。 提高了类的复用性。 增加了类的透明度。 提供了良好的灵活性。 缺点 过度使用适配器可能导致系统结构混乱，难以理解和维护。 在Java中，由于只能继承一个类，因此只能适配一个类，且目标类必须是抽象的。 使用建议 适配器模式应谨慎使用，特别是在详细设计阶段，它更多地用于解决现有系统的问题。 在考虑修改一个正常运行的系统接口时，适配器模式是一个合适的选择。 通过这种方式，适配器模式可以清晰地表达其核心概念和应用，同时避免了不必要的复杂性。 结构适配器模式包含以下几个主要角色： 目标接口（Target）：定义客户需要的接口。 适配者类（Adaptee）：定义一个已经存在的接口，这个接口需要适配。 适配器类（Adapter）：实现目标接口，并通过组合或继承的方式调用适配者类中的方法，从而实现目标接口。 1234//适配者类public interface MediaPlayer &#123; public void play(String audioType, String fileName);&#125; 12345//目标接口public interface AdvancedMediaPlayer &#123; public void playVlc(String fileName); public void playMp4(String fileName);&#125; 123456789101112131415161718192021222324//实现了 AdvancedMediaPlayer 接口的实体类public class VlcPlayer implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; System.out.println(&quot;Playing vlc file. Name: &quot;+ fileName); &#125; @Override public void playMp4(String fileName) &#123; //什么也不做 &#125;&#125;public class Mp4Player implements AdvancedMediaPlayer&#123; @Override public void playVlc(String fileName) &#123; //什么也不做 &#125; @Override public void playMp4(String fileName) &#123; System.out.println(&quot;Playing mp4 file. Name: &quot;+ fileName); &#125;&#125; 12345678910111213141516171819202122//实现了 MediaPlayer 接口的适配器类public class MediaAdapter implements MediaPlayer &#123; AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType)&#123; if(audioType.equalsIgnoreCase(&quot;vlc&quot;) )&#123; advancedMusicPlayer = new VlcPlayer(); &#125; else if (audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123; advancedMusicPlayer = new Mp4Player(); &#125; &#125; @Override public void play(String audioType, String fileName) &#123; if(audioType.equalsIgnoreCase(&quot;vlc&quot;))&#123; advancedMusicPlayer.playVlc(fileName); &#125;else if(audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123; advancedMusicPlayer.playMp4(fileName); &#125; &#125;&#125; 1234567891011121314151617181920212223//实现了 MediaPlayer 接口的实体类public class AudioPlayer implements MediaPlayer &#123; MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) &#123; //播放 mp3 音乐文件的内置支持 if(audioType.equalsIgnoreCase(&quot;mp3&quot;))&#123; System.out.println(&quot;Playing mp3 file. Name: &quot;+ fileName); &#125; //mediaAdapter 提供了播放其他文件格式的支持 else if(audioType.equalsIgnoreCase(&quot;vlc&quot;) || audioType.equalsIgnoreCase(&quot;mp4&quot;))&#123; mediaAdapter = new MediaAdapter(audioType); mediaAdapter.play(audioType, fileName); &#125; else&#123; System.out.println(&quot;Invalid media. &quot;+ audioType + &quot; format not supported&quot;); &#125; &#125; &#125; 1234567891011//使用audioPlayerpublic class AdapterPatternDemo &#123; public static void main(String[] args) &#123; AudioPlayer audioPlayer = new AudioPlayer(); audioPlayer.play(&quot;mp3&quot;, &quot;beyond the horizon.mp3&quot;); audioPlayer.play(&quot;mp4&quot;, &quot;alone.mp4&quot;); audioPlayer.play(&quot;vlc&quot;, &quot;far far away.vlc&quot;); audioPlayer.play(&quot;avi&quot;, &quot;mind me.avi&quot;); &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"}]},{"title":"linux","slug":"linux","date":"2024-10-11T15:25:06.000Z","updated":"2024-10-14T08:47:45.124Z","comments":true,"path":"2024/10/11/linux/","permalink":"http://example.com/2024/10/11/linux/","excerpt":"","text":"linux常用命令处理目录的常用命令 ls（英文全拼：list files）: 列出目录及文件名 cd（英文全拼：change directory）：切换目录 pwd（英文全拼：print work directory）：显示目前的目录 mkdir（英文全拼：make directory）：创建一个新的目录 rmdir（英文全拼：remove directory）：删除一个空的目录 cp（英文全拼：copy file）: 复制文件或目录 rm（英文全拼：remove）: 删除文件或目录 mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称 可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。 ls (列出目录)语法： 123[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称[root@www ~]# ls [--full-time] 目录名称 选项与参数： -a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用) -d ：仅列出目录本身，而不是列出目录内的文件数据(常用) -l ：长数据串列出，包含文件的属性与权限等等数据；(常用) 将目录下的所有文件列出来(含属性与隐藏档) 1[root@www ~]# ls -al ~ ~为根目录 cd (切换目录)cd是Change Directory的缩写，这是用来变换工作目录的命令。 pwd (显示目前所在的目录)pwd 是 Print Working Directory 的缩写，也就是显示目前所在目录的命令。 1[root@www ~]# pwd [-P] 选项与参数： -P ：显示出确实的路径，而非使用链接 (link) 路径。 mkdir (创建新目录)语法： 1mkdir [-mp] 目录名称 选项与参数： -m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～ -p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！ 123456[root@www ~]# cd /tmp[root@www tmp]# mkdir test &lt;==创建一名为 test 的新目录[root@www tmp]# mkdir test1/test2/test3/test4mkdir: cannot create directory `test1/test2/test3/test4&#x27;: No such file or directory &lt;== 没办法直接创建此目录啊！[root@www tmp]# mkdir -p test1/test2/test3/test4 加了这个 -p 的选项，可以自行帮你创建多层目录！ 实例：创建权限为 rwx–x–x 的目录。 12345[root@www tmp]# mkdir -m 711 test2[root@www tmp]# ls -ldrwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2 上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。 如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。 rmdir (删除空的目录)语法： 1rmdir [-p] 目录名称 选项与参数： -p ：从该目录起，一次删除多级空目录 删除 runoob 目录 1[root@www tmp]# rmdir runoob/ 将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！ 12345678910[root@www tmp]# ls -l &lt;==看看有多少目录存在？drwxr-xr-x 3 root root 4096 Jul 18 12:50 testdrwxr-xr-x 3 root root 4096 Jul 18 12:53 test1drwx--x--x 2 root root 4096 Jul 18 12:54 test2[root@www tmp]# rmdir test &lt;==可直接删除掉，没问题[root@www tmp]# rmdir test1 &lt;==因为尚有内容，所以无法删除！rmdir: `test1&#x27;: Directory not empty[root@www tmp]# rmdir -p test1/test2/test3/test4[root@www tmp]# ls -l &lt;==您看看，底下的输出中test与test1不见了！drwx--x--x 2 root root 4096 Jul 18 12:54 test2 利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。 要注意的是，这个 rmdir 仅能删除空的目录，可以使用 rm 命令来删除非空目录。 cp (复制文件或目录)cp 即拷贝文件和目录。 语法: 12[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)[root@www ~]# cp [options] source1 source2 source3 .... directory 选项与参数： -a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用) -d：若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身； -f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次； -i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用) -l：进行硬式链接(hard link)的链接档创建，而非复制文件本身； -p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)； -r：递归持续复制，用于目录的复制行为；(常用) -s：复制成为符号链接档 (symbolic link)，亦即『捷径』文件； -u：若 destination 比 source 旧才升级 destination ！ 用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc 123[root@www ~]# cp ~/.bashrc /tmp/bashrc[root@www ~]# cp -i ~/.bashrc /tmp/bashrccp: overwrite `/tmp/bashrc&#x27;? n &lt;==n不覆盖，y为覆盖 rm (移除文件或目录)语法： 1rm [-fir] 文件或目录 选项与参数： -f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息； -i ：互动模式，在删除前会询问使用者是否动作 -r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！ mv (移动文件与目录，或修改名称)语法： 12[root@www ~]# mv [-fiu] source destination[root@www ~]# mv [options] source1 source2 source3 .... directory 选项与参数： -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会升级 (update) 复制一文件，创建一目录，将文件移动到目录中 1234[root@www ~]# cd /tmp[root@www tmp]# cp ~/.bashrc bashrc[root@www tmp]# mkdir mvtest[root@www tmp]# mv bashrc mvtest 查看文件cat由第一行开始显示文件内容 语法： 1cat [-AbEnTv] 选项与参数： -A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已； -b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！ -E ：将结尾的断行字节 $ 显示出来； -n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同； -T ：将 [tab] 按键以 ^I 显示出来； -v ：列出一些看不出来的特殊字符 检看 &#x2F;etc&#x2F;issue 这个文件的内容： 123[root@www ~]# cat /etc/issueCentOS release 6.4 (Final)Kernel \\r on an \\m 创建文件touchtouch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 语法1touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…] 参数说明： a 改变档案的读取时间记录。 m 改变档案的修改时间记录。 c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。 f 不使用，是为了与其他 unix 系统的相容性而保留。 r 使用参考档的时间记录，与 –file 的效果一样。 d 设定时间与日期，可以使用各种不同的格式。 t 设定档案的时间记录，格式与 date 指令相同。 –no-create 不会建立新档案。 –help 列出指令格式。 –version 列出版本讯息。 vim","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"2024-10-9","slug":"2024-10-9","date":"2024-10-09T15:58:54.000Z","updated":"2024-10-09T16:11:22.592Z","comments":true,"path":"2024/10/09/2024-10-9/","permalink":"http://example.com/2024/10/09/2024-10-9/","excerpt":"","text":"好累好累，每天高强度学习，脑子转不过来了555，明天应该可以把vue3项目做完吧","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"vue3","slug":"vue3","date":"2024-10-02T15:00:05.000Z","updated":"2024-10-17T09:14:24.879Z","comments":true,"path":"2024/10/02/vue3/","permalink":"http://example.com/2024/10/02/vue3/","excerpt":"","text":"组合式API - reactive和ref函数1. reactive 接受对象类型数据的参数传入并返回一个响应式的对象 1234567891011121314151617&lt;script setup&gt; // 导入 import &#123; reactive &#125; from &#x27;vue&#x27; // 执行函数 传入参数 变量接收 const state = reactive(&#123; msg:&#x27;this is msg&#x27; &#125;) const setSate = ()=&gt;&#123; // 修改数据更新视图 state.msg = &#x27;this is new msg&#x27; &#125;&lt;/script&gt;&lt;template&gt; &#123;&#123; state.msg &#125;&#125; &lt;button @click=&quot;setState&quot;&gt;change msg&lt;/button&gt;&lt;/template&gt; 2. ref 接收简单类型或者对象类型的数据传入并返回一个响应式的对象 1234567891011121314&lt;script setup&gt; // 导入 import &#123; ref &#125; from &#x27;vue&#x27; // 执行函数 传入参数 变量接收 const count = ref(0) const setCount = ()=&gt;&#123; // 修改数据更新视图必须加上.value count.value++ &#125;&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;setCount&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/button&gt;&lt;/template&gt; 3. reactive 对比 ref 都是用来生成响应式数据 不同点 reactive不能处理简单类型的数据 ref参数类型支持更好，但是必须通过.value做访问修改 ref函数内部的实现依赖于reactive函数 组合式API - computed 计算属性基本思想和Vue2保持一致，组合式API下的计算属性只是修改了API写法 12345678910111213&lt;script setup&gt;// 导入import &#123;ref, computed &#125; from &#x27;vue&#x27;// 原始数据const count = ref(0)// 计算属性const doubleCount = computed(()=&gt;count.value * 2)// 原始数据const list = ref([1,2,3,4,5,6,7,8])// 计算属性listconst filterList = computed(item=&gt;item &gt; 2)&lt;/script&gt; 组合式API - watch 侦听一个或者多个数据的变化，数据变化时执行回调函数，俩个额外参数 immediate控制立刻执行，deep开启深度侦听 1. 侦听单个数据123456789&lt;script setup&gt; // 1. 导入watch import &#123; ref, watch &#125; from &#x27;vue&#x27; const count = ref(0) // 2. 调用watch 侦听变化 watch(count, (newValue, oldValue)=&gt;&#123; console.log(`count发生了变化，老值为$&#123;oldValue&#125;,新值为$&#123;newValue&#125;`) &#125;)&lt;/script&gt; 2. 侦听多个数据 侦听多个数据，第一个参数可以改写成数组的写法 12345678910&lt;script setup&gt; // 1. 导入watch import &#123; ref, watch &#125; from &#x27;vue&#x27; const count = ref(0) const name = ref(&#x27;cp&#x27;) // 2. 调用watch 侦听变化 watch([count, name], ([newCount, newName],[oldCount,oldName])=&gt;&#123; console.log(`count或者name变化了，[newCount, newName],[oldCount,oldName]) &#125;)&lt;/script&gt; 3. immediate 在侦听器创建时立即出发回调，响应式数据变化之后继续执行回调 1234567891011&lt;script setup&gt; // 1. 导入watch import &#123; ref, watch &#125; from &#x27;vue&#x27; const count = ref(0) // 2. 调用watch 侦听变化 watch(count, (newValue, oldValue)=&gt;&#123; console.log(`count发生了变化，老值为$&#123;oldValue&#125;,新值为$&#123;newValue&#125;`) &#125;,&#123; immediate: true &#125;)&lt;/script&gt; 4. deep 通过watch监听的ref对象默认是浅层侦听的，直接修改嵌套的对象属性不会触发回调执行，需要开启deep 12345678910111213141516171819202122232425262728&lt;script setup&gt; // 1. 导入watch import &#123; ref, watch &#125; from &#x27;vue&#x27; const state = ref(&#123; count: 0 &#125;) // 2. 监听对象state watch(state, ()=&gt;&#123; console.log(&#x27;数据变化了&#x27;) &#125;) const changeStateByCount = ()=&gt;&#123; // 直接修改不会引发回调执行 state.value.count++ &#125;&lt;/script&gt;&lt;script setup&gt; // 1. 导入watch import &#123; ref, watch &#125; from &#x27;vue&#x27; const state = ref(&#123; count: 0 &#125;) // 2. 监听对象state 并开启deep watch(state, ()=&gt;&#123; console.log(&#x27;数据变化了&#x27;) &#125;,&#123;deep:true&#125;) const changeStateByCount = ()=&gt;&#123; // 此时修改可以触发回调 state.value.count++ &#125;&lt;/script&gt; 组合式API - 生命周期函数1. API setup() onBeforemount() onMounted() onBeforeUpdate() onUpdated() onBeforeUnMount() onUnMounted() 2. 生命周期函数基本使用 导入生命周期函数 执行生命周期函数，传入回调 123456&lt;scirpt setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;onMounted(()=&gt;&#123; // 自定义逻辑&#125;)&lt;/script&gt; 3. 执行多次 生命周期函数执行多次的时候，会按照顺序依次执行 12345678910&lt;scirpt setup&gt;import &#123; onMounted &#125; from &#x27;vue&#x27;onMounted(()=&gt;&#123; // 自定义逻辑&#125;)onMounted(()=&gt;&#123; // 自定义逻辑&#125;)&lt;/script&gt; 组合式API - 父子通信1. 父传子 基本思想 父组件中给子组件绑定属性 子组件内部通过props选项接收数据 123456789101112131415161718192021222324//App.vue&lt;template&gt; &lt;div&gt; &lt;SonCom message=&quot;this is a message&quot;&gt;&lt;/SonCom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import SonCom from &#x27;./SonCom.vue&#x27;&lt;/script&gt;//SonCom.vue&lt;template&gt; &lt;div&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const props = defineProps(&#123; message:String&#125;)&lt;/script&gt; 2. 子传父 基本思想 父组件中给子组件标签通过@绑定事件 子组件内部通过 emit 方法触发事件 12345678910111213141516171819202122232425262728//App.vue&lt;template&gt; &lt;div&gt; &lt;SonCom @get-message=&quot;messageHandler&quot;&gt;&lt;/SonCom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import SonCom from &#x27;./SonCom.vue&#x27;const messageHandler = (message)=&gt;&#123; console.log(message)&#125;&lt;/script&gt;//SonCom.vue&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;sendMsg&quot;&gt;点我发送信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;const emit = defineEmits([&#x27;get-message&#x27;])const sendMsg = ()=&gt;&#123; emit(&#x27;get-message&#x27;,&quot;this is son message&quot;)&#125;&lt;/script&gt; 组合式API - 模版引用 概念：通过 ref标识 获取真实的 dom对象或者组件实例对象 1. 基本使用 实现步骤： 调用ref函数生成一个ref对象 通过ref标识绑定ref对象到标签 12345678910&lt;template&gt; &lt;div&gt; &lt;h1 ref=&quot;h1Ref&quot;&gt;我是dom标签对象h1&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const h1Ref = ref(null)&lt;/script&gt; 2. defineExpose 默认情况下在 语法糖下组件内部的属性和方法是不开放给父组件访问的，可以通过defineExpose编译宏指定哪些属性和方法容许访问说明：指定testMsg属性可以被访问到 1234567&lt;script setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;;const testMsg = ref(&quot;this is a test message&quot;)defineExpose(&#123; testMsg&#125;)&lt;/script&gt; 组合式API - provide和inject顶层组件向任意的底层组件传递数据和方法，实现跨层组件通信 1234//顶层组件provide(&#x27;key&#x27;,refObj)//底层组件const refObj = inject(&#x27;key&#x27;) 12345//顶层组件const func = ()=&gt;&#123;&#125;provide(&#x27;key&#x27;,func)//底层组件const func = inject(&#x27;key&#x27;) piniaPinia 是 Vue 的专属状态管理库，可以实现跨组件或页面共享状态，是 vuex 状态管理工具的替代品，和 Vuex相比，具备以下优势 提供更加简单的API （去掉了 mutation ） 提供符合组合式API风格的API （和 Vue3 新语法统一） 去掉了modules的概念，每一个store都是一个独立的模块 搭配 TypeScript 一起使用提供可靠的类型推断 创建空Vue项目并安装Pinia1. 创建空Vue项目1npm init vue@latest 2. 安装Pinia并注册1npm i pinia 1234567import &#123; createPinia &#125; from &#x27;pinia&#x27;const app = createApp(App)// 以插件的形式注册app.use(createPinia())app.use(router)app.mount(&#x27;#app&#x27;) 实现counter 核心步骤： 定义store 组件使用store 1- 定义store 12345678910111213141516171819import &#123; defineStore &#125; from &#x27;pinia&#x27;import &#123; ref &#125; from &#x27;vue&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, ()=&gt;&#123; // 数据 （state） const count = ref(0) // 修改数据的方法 （action） const increment = ()=&gt;&#123; count.value++ &#125; // 以对象形式返回 return &#123; count, increment &#125;&#125;) 2- 组件使用store 123456789101112&lt;script setup&gt; // 1. 导入use方法 import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27; // 2. 执行方法得到store store里有数据和方法 const counterStore = useCounterStore()&lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;counterStore.increment&quot;&gt; &#123;&#123; counterStore.count &#125;&#125; &lt;/button&gt;&lt;/template&gt; 实现getters getters直接使用计算属性即可实现 1234// 数据（state）const count = ref(0)// getter (computed)const doubleCount = computed(() =&gt; count.value * 2) 异步action 思想：action函数既支持同步也支持异步，和在组件中发送网络请求写法保持一致步骤： store中定义action 组件中触发action 1- store中定义action 12345678910111213141516const API_URL = &#x27;http://geek.itheima.net/v1_0/channels&#x27;export const useCounterStore = defineStore(&#x27;counter&#x27;, ()=&gt;&#123; // 数据 const list = ref([]) // 异步action const loadList = async ()=&gt;&#123; const res = await axios.get(API_URL) list.value = res.data.data.channels &#125; return &#123; list, loadList &#125;&#125;) 2- 组件中调用action 123456789101112&lt;script setup&gt; import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27; const counterStore = useCounterStore() // 调用异步action counterStore.loadList()&lt;/script&gt;&lt;template&gt; &lt;ul&gt; &lt;li v-for=&quot;item in counterStore.list&quot; :key=&quot;item.id&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt; storeToRefs保持响应式解构 直接基于store进行解构赋值，响应式数据（state和getter）会丢失响应式特性，使用storeToRefs辅助保持响应式 12345678910111213141516&lt;script setup&gt; import &#123; storeToRefs &#125; from &#x27;pinia&#x27; import &#123; useCounterStore &#125; from &#x27;@/stores/counter&#x27; const counterStore = useCounterStore() // 使用它storeToRefs包裹之后解构保持响应式 const &#123; count &#125; = storeToRefs(counterStore) const &#123; increment &#125; = counterStore &lt;/script&gt;&lt;template&gt; &lt;button @click=&quot;increment&quot;&gt; &#123;&#123; count &#125;&#125; &lt;/button&gt;&lt;/template&gt; Pinia持久化存储1npm i pinia-plugin-persistedstate 1234567//main.jsimport &#123; createPinia &#125; from &#x27;pinia&#x27;import piniaPluginPersistedstate from &#x27;pinia-plugin-persistedstate&#x27;const pinia = createPinia()pinia.use(piniaPluginPersistedstate) 12345678910111213//定义store时import &#123; defineStore &#125; from &#x27;pinia&#x27;export const useStore = defineStore( &#x27;main&#x27;, () =&gt; &#123; const someState = ref(&#x27;hello pinia&#x27;) return &#123; someState &#125; &#125;, &#123; persist: true, &#125;,) 全局组件统一插件化插件化开发1234567891011// 把components中的所组件都进行全局化注册// 通过插件的方式import ImageView from &#x27;./ImageView/index.vue&#x27;import Sku from &#x27;./XtxSku/index.vue&#x27;export const componentPlugin = &#123; install (app) &#123; // app.component(&#x27;组件名字&#x27;，组件配置对象) app.component(&#x27;XtxImageView&#x27;, ImageView) app.component(&#x27;XtxSku&#x27;, Sku) &#125;&#125; 插件注册1234// 引入全局组件插件import &#123; componentPlugin &#125; from &#x27;@/components&#x27;app.use(componentPlugin)","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"}]},{"title":"vue3-rabbit小兔鲜电商项目","slug":"vue3-rabbit小兔鲜电商项目","date":"2024-10-01T14:48:11.000Z","updated":"2024-10-09T02:06:19.398Z","comments":true,"path":"2024/10/01/vue3-rabbit小兔鲜电商项目/","permalink":"http://example.com/2024/10/01/vue3-rabbit%E5%B0%8F%E5%85%94%E9%B2%9C%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE/","excerpt":"","text":"技术栈vue3+JavaScript+vue-router+pinia+element-plus+axios+echarts+vueuse 创建项目并整理目录1npm init vue@latest 目录结构 文件夹 作用 apis 接口 assets 静态资源 components 通用组件 composables 组合函数 directives 全局指令 router 路由Router stores Pinia仓库 styles 全局样式文件夹 utils 工具函数 views 页面级组件 关联远程github项目git init git add . git commit -m “init” git remote add origin … git push –set-upstream origin master jsconfig.json配置别名路径 配置别名路径可以在写代码时联想提示路径 12345678&#123; &quot;compilerOptions&quot; : &#123; &quot;baseUrl&quot; : &quot;./&quot;, &quot;paths&quot; : &#123; &quot;@/*&quot;:[&quot;src/*&quot;] &#125; &#125;&#125; elementPlus引入安装elementPlus和自动导入插件12npm install element-plusnpm install -D unplugin-vue-components unplugin-auto-import 配置自动按需导入1234567891011121314151617// 引入插件import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;export default defineConfig(&#123; plugins: [ // 配置插件 AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver()], &#125;), ]&#125;) 测试组件123&lt;template&gt; &lt;el-button type=&quot;primary&quot;&gt;i am button&lt;/el-button&gt;&lt;/template&gt; 定制elementPlus主题安装sass 基于vite的项目默认不支持css预处理器，需要开发者单独安装 1npm i sass -D 准备定制化的样式文件12345678910111213141516171819202122232425/* 只需要重写你需要的即可 */@forward &#x27;element-plus/theme-chalk/src/common/var.scss&#x27; with ( $colors: ( &#x27;primary&#x27;: ( // 主色 &#x27;base&#x27;: #27ba9b, ), &#x27;success&#x27;: ( // 成功色 &#x27;base&#x27;: #1dc779, ), &#x27;warning&#x27;: ( // 警告色 &#x27;base&#x27;: #ffb302, ), &#x27;danger&#x27;: ( // 危险色 &#x27;base&#x27;: #e26237, ), &#x27;error&#x27;: ( // 错误色 &#x27;base&#x27;: #cf4444, ), )) 自动导入配置 这里自动导入需要深入到elementPlus的组件中，按照官方的配置文档来 自动导入定制化样式文件进行样式覆盖 按需定制主题配置 （需要安装 unplugin-element-plus） 1234567891011121314151617181920212223242526272829303132import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import AutoImport from &#x27;unplugin-auto-import/vite&#x27;import Components from &#x27;unplugin-vue-components/vite&#x27;import &#123; ElementPlusResolver &#125; from &#x27;unplugin-vue-components/resolvers&#x27;export default defineConfig(&#123; plugins: [ vue(), AutoImport(&#123; resolvers: [ElementPlusResolver()], &#125;), Components(&#123; resolvers: [ElementPlusResolver(&#123;importStyle: &quot;sass&quot;&#125;)], &#125;), ], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&#x27;./src&#x27;, import.meta.url)) &#125; &#125;, css: &#123; preprocessorOptions: &#123; scss: &#123; // 自动导入定制化样式文件进行样式覆盖 additionalData: ` @use &quot;@/styles/element/index.scss&quot; as *; `, &#125; &#125; &#125;&#125;) axios安装并简单封装安装axios1npm i axios 基础配置 官方文档地址：https://axios-http.com/zh/docs/intro基础配置通常包括： 实例化 - baseURL + timeout 拦截器 - 携带token 401拦截等 1234567891011121314151617181920212223242526272829303132333435363738import router from &#x27;@/router&#x27;import &#123; useUserStore &#125; from &#x27;@/stores/user&#x27;import axios from &#x27;axios&#x27;import &#123; ElMessage &#125; from &#x27;element-plus&#x27;import &#x27;element-plus/theme-chalk/el-message.css&#x27;// 创建axios实例const httpInstance = axios.create(&#123; baseURL: &#x27;http://pcapi-xiaotuxian-front-devtest.itheima.net&#x27;, timeout: 5000&#125;)// axios请求拦截器httpInstance.interceptors.request.use(config =&gt; &#123; const userStore = useUserStore() const token = userStore.userInfo.token if (token) &#123; config.headers.Authorization = `Bearer $&#123;token&#125;` &#125; return config&#125;, e =&gt; Promise.reject(e))// axios响应式拦截器httpInstance.interceptors.response.use(res =&gt; res.data, e =&gt; &#123; const userStore = useUserStore() ElMessage(&#123; type: &#x27;warning&#x27;, message: e.response.data.message &#125;) //401token失效处理 if (e.response.status === 401) &#123; userStore.clearUserInfo() router.push(&#x27;/login&#x27;) &#125; return Promise.reject(e)&#125;)export default httpInstance 封装请求函数并测试1234567import http from &#x27;@/utils/http&#x27;export function getCategoryAPI () &#123; return http(&#123; url: &#x27;home/category/head&#x27; &#125;)&#125; 路由整体设计路由设计原则：找页面的切换方式，如果是整体切换，则为一级路由，如果是在一级路由的内部进行的内容切换，则为二级路由 123&lt;template&gt; 我是登录页&lt;/template&gt; 123&lt;template&gt; 我是首页&lt;/template&gt; 123&lt;template&gt; 我是home&lt;/template&gt; 123&lt;template&gt; 我是分类&lt;/template&gt; 1234567891011121314151617181920212223242526272829303132333435// createRouter：创建router实例对象// createWebHistory：创建history模式的路由import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;import Login from &#x27;@/views/Login/index.vue&#x27;import Layout from &#x27;@/views/Layout/index.vue&#x27;import Home from &#x27;@/views/Home/index.vue&#x27;import Category from &#x27;@/views/Category/index.vue&#x27;const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), // path和component对应关系的位置 routes: [ &#123; path: &#x27;/&#x27;, component: Layout, children: [ &#123; path: &#x27;&#x27;, component: Home &#125;, &#123; path: &#x27;category&#x27;, component: Category &#125; ] &#125;, &#123; path: &#x27;/login&#x27;, component: Login &#125; ]&#125;)export default router 静态资源引入和Error Lens安装静态资源引入 图片资源 - 把 images 文件夹放到 assets 目录下 样式资源 - 把 common.scss 文件放到 styles 目录下 Error Lens插件安装scss变量自动导入123456// src/styles/var.scss$xtxColor: #27ba9b;$helpColor: #e26237;$sucColor: #1dc779;$warnColor: #ffb302;$priceColor: #cf4444; 1234567891011css: &#123; preprocessorOptions: &#123; scss: &#123; // 自动导入scss文件 additionalData: ` @use &quot;@/styles/element/index.scss&quot; as *; @use &quot;@/styles/var.scss&quot; as *; `, &#125; &#125;&#125; 懒加载指令实现封装全局指令123456789101112131415161718192021import &#123; useIntersectionObserver &#125; from &#x27;@vueuse/core&#x27;export const lazyPlugin = &#123; install(app) &#123; app.directive(&#x27;img-lazy&#x27;, &#123; mounted(el, binding) &#123; // el: 指令绑定的那个元素 img // binding: binding.value 指令等于号后面绑定的表达式的值 图片url const &#123; stop &#125; = useIntersectionObserver( el, ([&#123; isIntersecting &#125;]) =&gt; &#123; if (isIntersecting) &#123; el.src = binding.value stop() &#125; &#125;, ) &#125; &#125;) &#125;&#125; 注册全局指令123// 全局指令注册import &#123; lazyPlugin &#125; from &#x27;@/directives&#x27;app.use(lazyPlugin) 图片懒加载123456789101112131415161718&lt;div class=&quot;home-product&quot;&gt; &lt;HomePanel :title=&quot;cate.name&quot; v-for=&quot;cate in goodsProduct&quot; :key=&quot;cate.id&quot;&gt; &lt;div class=&quot;box&quot;&gt; &lt;RouterLink class=&quot;cover&quot; to=&quot;/&quot;&gt; &lt;!-- 指令替换 --&gt; &lt;img v-img-lazy=&quot;cate.picture&quot; /&gt; &lt;/RouterLink&gt; &lt;ul class=&quot;goods-list&quot;&gt; &lt;li v-for=&quot;goods in cate.goods&quot; :key=&quot;goods.id&quot;&gt; &lt;RouterLink to=&quot;/&quot; class=&quot;goods-item&quot;&gt; &lt;!-- 指令替换 --&gt; &lt;img v-img-lazy=&quot;goods.picture&quot; alt=&quot;&quot; /&gt; &lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/HomePanel&gt;&lt;/div&gt; 路由缓存路由缓存问题：路由只有参数变化时，会复用组件实例，导致页面不更新 解决方法： 不在意性能，在RouterView标签里加key属性 选择路由的onBeforeRouteUpdate方法 123onBeforeRouteUpdate((to)=&gt;&#123; &#125;) 路由切换自动滚动至顶部12345678910const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [... ], scrollBehavior()&#123; return &#123; top:0 &#125; &#125;&#125;) Pinia持久化存储12345678910111213141516171819202122import &#123; loginAPI &#125; from &quot;@/apis/user&quot;import &#123; defineStore &#125; from &quot;pinia&quot;import &#123; ref &#125; from &quot;vue&quot;export const useUserStore = defineStore(&#x27;user&#x27;, () =&gt; &#123; let userInfo = ref(&#123;&#125;) const getUserInfo = async (&#123; account, password &#125;) =&gt; &#123; const res = await loginAPI(&#123; account, password &#125;) userInfo.value = res.result &#125; const clearUserInfo = () =&gt; &#123; userInfo.value = &#123;&#125; &#125; return &#123; userInfo, getUserInfo, clearUserInfo &#125;&#125;, &#123; persist: true, &#125;,)","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"}]},{"title":"2024-9-30","slug":"2024-9-30","date":"2024-09-30T12:56:07.000Z","updated":"2024-10-09T16:09:43.468Z","comments":true,"path":"2024/09/30/2024-9-30/","permalink":"http://example.com/2024/09/30/2024-9-30/","excerpt":"","text":"😀😀 发财了发财了！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"JavaScript","slug":"JavaScript","date":"2024-09-28T03:21:13.000Z","updated":"2024-10-17T09:43:53.703Z","comments":true,"path":"2024/09/28/JavaScript/","permalink":"http://example.com/2024/09/28/JavaScript/","excerpt":"","text":"输入输出语句 prompt(info) alert(msg) console.log(msg) undefined与null undefined表示没有赋值，未定义数据类型 null表示值为空，空数据类型。如果一个变量里面确定存放的是对象，如果还没准备好对象，可以放一个null 类型转换隐式转换 +号两边只要有一个是字符串，都会把另外一个转成字符串 -，*，&#x2F;，%：字符串转数字型后计算、 +作为正号解析可以转换成数字型 显示转换 +|Number()|parseInt()|parseFloat():转换为数字型 数组 方法&#x2F;属性 作用 arr.length 获取数组长度 arr.at() 接收一个整数值并返回该索引对应的元素，允许正数和负数。负整数从数组中的最后一个元素开始倒数。 arr.concat() 合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。可以用来拷贝数组 arr.every() 测试一个数组内的所有元素是否都能通过指定函数的测试。它返回一个布尔值。 arr.fill(element,i,j) 用一个固定值填充一个数组中从起始索引（默认为 0）到终止索引（默认为 array.length）内的全部元素。它返回修改后的数组。 arr.filter() 创建给定数组一部分的浅拷贝，其包含通过所提供函数实现的测试的所有元素。 arr.find() 返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 arr.findIndex() 返回数组中满足提供的测试函数的第一个元素的索引。若没有找到对应元素则返回 -1。 arr.findLast() 反向迭代数组，并返回满足提供的测试函数的第一个元素的值。如果没有找到对应元素，则返回 undefined。 arr.findLastIndex() 反向迭代数组，并返回满足所提供的测试函数的第一个元素的索引。若没有找到对应元素，则返回 -1。 arr.flat(Infinity) 创建一个新的数组，并根据指定深度递归地将所有子数组元素拼接到新的数组中。 arr.forEach() 对数组的每个元素执行一次给定的函数。 arr.includes() 判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 arr.indexOf() 返回数组中第一次出现给定元素的下标，如果不存在则返回 -1。 arr.join() 将一个数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串，用逗号或指定的分隔符字符串分隔。 arr.findLastIndexOf(element,fromIndex) 返回数组中给定元素最后一次出现的索引，如果不存在则返回 -1。该方法从 fromIndex 开始向前搜索数组。 arr.map() 创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 arr.pop() 数组中删除最后一个元素，并返回该元素的值。 arr.push() 将指定的元素添加到数组的末尾，并返回新的数组长度。 arr.reduce((pre,current)&#x3D;&gt;func,initial) 对数组中的每个元素按序执行一个提供的 reducer 函数，每一次运行 reducer 会将先前元素的计算结果作为参数传入，最后将其结果汇总为单个返回值。 arr.reverse() 就地反转数组中的元素，并返回同一数组的引用。 arr.toReversed() 不改变原始数组的情况下反转数组中的元素。 arr.shift() 从数组中删除第一个元素，并返回该元素的值。 arr.slice(start,end) 返回一个新的数组对象，这一对象是一个由 start 和 end 决定的原数组的浅拷贝（包括 start，不包括 end），其中 start 和 end 代表了数组元素的索引。原始数组不会被改变。 arr.some() 测试数组中是否至少有一个元素通过了由提供的函数实现的测试。如果在数组中找到一个元素使得提供的函数返回 true，则返回 true；否则返回 false arr.sort((a,b)&#x3D;&gt;a-b) 就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。 arr.toSorted() 对数组的元素进行排序，不改变原数组，并返回新的数组。 arr.splice(splice(start, deleteCount, item1,……)) 就地移除或者替换已存在的元素和&#x2F;或添加新的元素。 arr.toSpliced() 创建一个删除和&#x2F;或替换部分内容而不改变原数组的新数组。 arr.unShift() 将指定元素添加到数组的开头，并返回数组的新长度。 对象 属性&#x2F;方法 描述 Object.keys(obj) 获得所有的属性名（数组） Object.values(obj) 获得所有的属性值（数组） Object.assign(copyObj,obj) 拷贝对象（浅拷贝） for(let key in obj) obj[key] 遍历对象 Math.random() 生成0-1之间的随机数 Math.ceil() 向上取整 Math.floor() 向下取整 Math.max() 找最大值 Math.min() 找最小值 Math.pow() 幂运算 Math.abs() 绝对值 date.getfullYear() 以四位数字返回年份。 date.getMonth() 返回月份 (0 ~ 11)。 date.getDate() 返回一个月中的某一天 (1 ~ 31)。 date.getDay() 返回一周中的某一天 (0 ~ 6)。 date.getHours() 返回小时 (0 ~ 23)。 date.getMinutes() 返回分钟 (0 ~ 59)。 date.getSeconds() 返回秒数 (0 ~ 59)。 date.getTime()|+new Date()|Date.now() 获取时间戳 str.length 字符串的长度 str.concat(s) 连接两个或更多字符串，并返回新的字符串 str.endsWith(s[,检测位置索引号]) 判断当前字符串是否是以指定的子字符串结尾的（区分大小写） str.indexOf(s) 返回某个指定的字符串值在字符串中首次出现的位置 str.lastIndexOf(s) 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。 str.includes(s[,检测位置索引号]) 查找字符串中是否包含指定的子字符串 str.match(reg) 查找找到一个或多个正则表达式的匹配 str.split(‘分隔符’) 把字符串分割为字符串数组 str.substring(from,to) 提取字符串中两个指定的索引号[form,to)之间的字符 str.startsWith(s[,检测位置索引号]) 查看字符串是否以指定的子字符串开头 str.toLowerCase() 把字符串转换为小写 str.toUpperCase() 把字符串转换为大写 str.substr(startIndex,n) 从起始索引号提取字符串中指定数目的字符。 str.replace() 在字符串中查找匹配的子串，并替换与正则表达式匹配的子串 str.replaceAll() 在字符串中查找匹配的子串，并替换与正则表达式匹配的所有子串 str.search() 查找与正则表达式相匹配的值,返回匹配的起始位置 str.trim() 去除字符串两边的空白 正则表达式定义正则表达式1const reg = /表达式/修饰符 匹配字符 字符 描述 . 匹配任意字符，除了\\n、\\r abc 匹配对应的字符串 [abc] 查找方括号之间的任何字符 [^abc] 匹配除了括号内的字符以外的任意一个字符 [0-9] 查找任何从 0 至 9 的数字 (x|y) 查找任何以|分隔的选项，匹配不同模式 \\d 查找数字 \\s 查找空白字符,等于[\\t\\r\\n\\v\\f] \\w 匹配数字、字母、下划线，等价于[0-9a-zA-Z_] \\D \\S \\W 与对应的小写形式相反 \\b 匹配单词边界 \\uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符 ^ 匹配字符串的开头 $ 匹配字符串的结尾 量词 *：匹配前面的模式零次或一次或多次。 +：匹配前面的模式一次或多次。 ?：匹配前面的模式零次或一次。 &#123;n&#125;：匹配前面的模式恰好 n 次。 &#123;n,&#125;：匹配前面的模式至少 n 次。 &#123;n,m&#125;：匹配前面的模式至少 n 次且不超过 m 次。 分组和捕获 ( )：用于分组和捕获子表达式。 (?: )：用于分组但不捕获子表达式。 修饰符 i:执行对大小写不敏感的匹配。 g:全局匹配 m:多行匹配 匹配123456const reg = /she/string str = &#x27;sherlock-holmes&#x27;reg.test(str)//返回true|falsereg.exec(str)//返回数组|nullstr.replace(reg,&#x27;substitute&#x27;)str.search(reg) test() 方法用于检测一个字符串是否匹配某个模式。 exec() 方法用于检索字符串中的正则表达式的匹配。 search() 方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。 replace() 方法用于在字符串中用一些字符串替换另一些字符串，或替换一个与正则表达式匹配的子串。 DOM对象document对象 属性&#x2F;方法 描述 document.querySelector() 返回文档中匹配指定的CSS选择器的第一元素 document.querySelectorAll() 返回文档中匹配的CSS选择器的所有元素节点列表 document.write() 向文档写 HTML 表达式 或 JavaScript 代码 document.createElement() 创建元素节点。 document.body 返回文档的body元素 document.documentElement 返回文档的根节点 document.title 返回当前文档的标题 DOM元素对象 属性&#x2F;方法 描述 element.innerHTML 设置或者返回元素的内容（解析标签）。 element.innerText 设置或者返回元素的文字内容（不解析标签）。 element.style 设置或返回元素的样式属性。 element.src|title|value|type 设置或返回元素的源|标题|值|类型。 element.className 设置或返回元素的类名。 element.classList.add()|remove()|toggle() 追加类名|移除类名|切换类名 element.dataset 获取data-属性 element.addEventListener(‘事件类型’,Func，是否使用捕获机制)|on事件 添加事件 element.removeEventListener(‘事件类型’,Func，是否使用捕获机制) 解绑事件（匿名函数无法解绑） element.parentNode 返回元素的父节点 element.children 返回元素的子元素的集合 element.nextElementSibling 返回元素的下一个兄弟节点 element.previousElementSibling 返回元素的上一个兄弟节点 element.appendChild(ele) 为元素添加一个新的子元素 element.insertBefore(insertEle,ele) 现有的子元素之前插入一个新的子元素 element.cloneNode(false|true) 克隆某个元素,参数为true时，同时克隆子元素 element.removeChild(ele) 删除一个子元素 事件对象 属性&#x2F;方法 描述 e.target 返回触发此事件的元素（事件的目标节点）。 e.type 返回当前 Event 对象表示的事件的名称。 e.currentTarget 返回其事件监听器触发该事件的元素。 e.timeStamp 返回事件生成的日期和时间。 e.preventDefault() 通知浏览器不要执行与事件关联的默认动作。 e.stopPropagation() 阻止冒泡。 BOM对象 window对象是一个全局对象，也可以说是JavaScript中的顶级对象 document、alert()、console都是window的属性和方法 所有通过var定义在全局作用域中的变量、函数都会变成window对象的属性和方法 window对象下的属性和方法调用时可以省略window location对象 属性&#x2F;方法 描述 location.href 返回完整的URL,可以用来跳转页面 location.hostname 返回URL的主机名 location.port 返回一个URL服务器使用的端口号 location.protocol 返回一个URL协议 location.search 返回一个URL的查询部分(?后部分) location.hash 返回一个URL的锚部分(#后部分) location.reload(true) 刷新页面 navigator对象12345678!(function()&#123; const userAgent = navigator.userAgent const android = userAgent.match(/(Android);?[\\s\\/]+([\\d.]+)?/) const iphone = userAgent.match(/(iPhone\\sOS)\\s([\\d_]+)/) if(android||iphone)&#123; location.href = &#x27;http://m.itcast.cn&#x27; &#125;&#125;)() history对象 属性方法 作用 history.length 返回历史列表中的网址数 history.back() 加载 history 列表中的前一个 URL history.forword() 加载 history 列表中的下一个 URL history.go(n) 加载 history 列表中的某个具体页面,正数前进、负数后退 localStorage对象 属性&#x2F;方法 描述 localStorage.length 返回存储对象中包含多少条数据 localStorage.key(n) 返回存储对象中第 n 个键的名称 localStorage.getItem(keyname) 返回指定键的值 localStorage.setItem(keyname,value) 添加键和值，如果对应的值存在，则更新该键对应的值 localStorage.removeItem(keyname) 移除键 localStorage.clear() 清除存储对象中所有的键 JSON.stringfy(复杂数据类型) JSON.parse(json数据) 定时器 const timer &#x3D; setInterval(function(){},ms) clearInterval(timer) const timer &#x3D; setTimeout(Func,ms) clearTimeout(timer)","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"}]},{"title":"2024-9-26","slug":"2024-9-26","date":"2024-09-26T14:20:07.000Z","updated":"2024-10-09T16:11:04.056Z","comments":true,"path":"2024/09/26/2024-9-26/","permalink":"http://example.com/2024/09/26/2024-9-26/","excerpt":"","text":"学生证发啦 学校里随机刷新的🐱学长 今天把css的基础课程看完了，做了一个名侦探柯南旋转海报的网页 名侦探柯南旋转海报 明天看一下flex布局还有学一下组合数学和cpp。 唉，感觉翘课自学效率比较高，但是软院又发文件要求上课点名，被23科憨害惨了。。。 下学期要不要翘课出去实习呢？如果厦门没有合适的实习岗怎么办呢？ 本以为考上可以休息一会儿，发现事情好像没有变少， 高中同学，大学同学有的已经工作了，有的还在谋出路， 我又要走去哪呢？","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"css","slug":"css","date":"2024-09-23T05:03:55.000Z","updated":"2024-09-28T03:20:02.244Z","comments":true,"path":"2024/09/23/css/","permalink":"http://example.com/2024/09/23/css/","excerpt":"","text":"通配符选择器1234* &#123; margin:0; padding:0;&#125; 字体属性 font-family:字体系列 font-size:字体大小 默认16px font-weight:字体粗细 normal|bold|bolder|lighter|number(默认400) font-style:字体样式 normal|italic font: font-style font-weight font-size&#x2F;line-height font-family; font-size:14px&#x2F;1.5 1.5倍行高 文本属性 color:文本颜色 text-align:对齐方式 left|center|right text-decoration:添加&#x2F;删除一条线none|underline|overline|line-through text-index:首行缩进 em为1个文字的大小 line-height:行间距 要比font-size大 xxxxxxxxxx import requestInstance from ‘.&#x2F;http’​export { requestInstance as http }typescript text-shadow:h-shadow v-shadow blur color 复合选择器 div a 后代选择器 div&gt;a 子元素选择器 div,span 并集选择器 a:link|a:visited|a:hover|a:active 链接伪类选择器（LoVe HaTe顺序编写） input:focus focus伪类选择器 E:first-child E:last-child E:nth-child(n|even|odd|5n|n+3|-n+5) E:first-of-type E:last-of-type E:nth-of-type(n|even|odd|5n|n+3|-n+5) 显示模式 块元素 自己独占一行 高度、宽度、外边距、内边距都可以控制 默认宽度是父级宽度的100% （除了文字类块元素）里面可以放行内或块级元素 行内元素 相邻行内元素在一行上 设置宽高无效 默认宽度为内容宽度 行内元素只能容纳文本或者行内元素 行内块元素：&lt;img/&gt;&lt;input/&gt;&lt;td/&gt; 相邻行内块元素在一行上 默认宽度为内容宽度 高度、宽度、外边距、内边距都可以控制 显示模式切换： display:none|block|inline 设置居中 类别 居中方法 块级元素 margin-left:auto;margin-right auto; 行内元素 父级元素添加text-align:center; 行内块元素 父级元素添加text-align:center; 所有元素的垂直居中 line-height:height 行内块（图片）和文字居中对齐 vertical-align:middle background background-image:url() background-repeat:repeat|no-repeat|repeat-x|repeat-y background-attachment:scroll|fixed background-position: x y|left center right|top center down background-size:x y|x|cover|contain cover可能显示不全，contain可能无法完全覆盖而显示空白 background:bg-color bg-image position&#x2F;bg-size bg-repeat bg-origin bg-attachment; 默认值为 transparent none 0% 0%&#x2F;auto repeat padding-box scroll; 选择器优先级 选择器 选择器权重 继承或者* 0，0，0，0 元素选择器，伪元素选择器 0，0，0，1 类选择器，伪类选择器 0，0，1，0 ID选择器 0，1，0，0 行内样式 1，0，0，0 !important ∞ 边框 border-width:5px border-style:none|solid|dashed|dotted border-color: border-top|down|left|down: border-collapse:separate|collapse 控制边框合并 border-radius:圆角边框 border:border-width||border-style||border-color 盒子模型由内至外(均会影响盒子大小)： padding border margin：设置左右边距为auto居中盒子 盒子阴影 box-shadow: h-shadow v-shadow blur spread color inset; 嵌套块元素的塌陷问题对于两个父子关系的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷比较大的外边距值 解决方案： 为父元素定义上边框 为父元素定义内边距 为父元素添加overflow:hidden 传统网页布局方式 标准流 浮动：多个块级元素横向排列 定位 float:none|left|right 浮动特性 脱离标准流浮动到指定位置，不再保留原先位置 如果多个盒子设置了浮动，则它们会按照属性值一行内显示并且顶端对齐排列 浮动元素具有行内块元素特性 流程： 先用标准流的父元素排列上下位置，之后内部元素采取浮动排列左右位置 浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流 清除浮动父元素未指定高度，子元素全部浮动，导致父元素高度为0的问题，解决方法： 额外标签法 最后一个元素后添加块级元素清除浮动&lt;div style=&quot;clear:both&quot;&gt;&lt;/div&gt; 父元素添加overflow:hidden|auto|scroll; 缺点：无法显示溢出部分 :after伪元素法 1234567.clearfix:after&#123; content:&quot;&quot;; display:block; height:0; clear:both; visibility:hidden;&#125; 父元素添加类名clearfix 双伪元素法 12345678.clearfix:before,.clearfix:after&#123; content:&quot;&quot;; display:table;&#125;.clearfix:after&#123; clear:both;&#125; 定位定位&#x3D;定位模式+边偏移 定位模式 position:static|relative|absolute|fixed|sticky 边偏移 top|bottom|left|right 静态定位默认方式，没有边偏移。 相对定位相对原来位置，原来的位置继续保留。 绝对定位相对最近一级祖先元素位置，若祖先元素无定位（静态定位）或无祖先元素，则相对浏览器。若要固定与祖先元素的某个位置，祖先元素应添加相对定位。原来的位置不保留。 固定定位固定于浏览器可视区的位置，不随滚动条滚动，原来的位置不保留，特殊的绝对定位。 粘性定位相对定位+固定定位 以浏览器窗口为参照点移动元素，占有原来位置。 定位叠放次序z-index:取值越大越靠上 定位的其他特性绝对定位和固定定位也和浮动类似。 行内元素添加绝对或者固定定位，可以直接设置宽度和高度。 块级元素添加绝对或者固定定位，不给宽度和高度，默认大小为内容的大小。 浮动、定位的盒子不会引起外边距合并的问题。 浮动的元素不会压住下面标准流的文字（可以用来做文字环绕），而绝对定位和固定定位会。 元素的显示与隐藏 display:none|block 不保留位置 visibility:hidden|visible 保留位置 overflow:visible|auto|hidden|scroll （内容溢出元素框时，会发生什么。有定位的盒子慎用） 精灵图将小背景图片整合到一张大图中，减少服务器接收和发送请求的次数，提高页面加载速度 background-position: -x -y; 字体图标 文件小 放大缩小不失真 灵活，可以改变颜色、产生阴影、透明效果、旋转等 iconfont-阿里巴巴矢量图标库 三角形123456.box&#123; width:0; height:0; border:50px solid transparent; border-left-color:pink;//朝右的三角形&#125; 鼠标样式&amp;表单轮廓线&amp;f防止拖拽文本域cursor:default|pointer|move|text|no-allowed outline:none textarea{ ​ resize:none; } 行内块和文字垂直居中对齐image{ ​ vertical-align:top|bottom|middle 可以解决图片底部默认空白的问题 } 文字省略号显示1234div &#123; white-space:norap; text-overflow:ellipsis;&#125; 视频&#x2F;音频播放器12&lt;video src=&quot;&quot; autoplay=&quot;autoplay&quot; muted=&quot;muted&quot; controls=&quot;controls&quot; loop=&quot;loop&quot; poster=&quot;&quot;&gt;&lt;/video&gt;&lt;audio src=&quot;&quot; autoplay=&quot;autoplay&quot; controls=&quot;controls&quot; loop=&quot;loop&quot;&gt;&lt;/audio&gt; 属性选择器 选择符 简介 E[att&#x3D;”val”] 选择具有att属性的E元素 E[att&#x3D;”val”]] 选择具有att属性且属性值等于val的E元素 E[att^&#x3D;”val”]] 选择具有att属性且值以val开头的E元素 E[att$&#x3D;”val”]] 选择具有att属性且值以val结尾的E元素 E[att*&#x3D;”val”]] 选择具有att属性且值中含有val的E元素 伪元素选择器 before和after创建一个元素，但是属于行内元素 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素 语法： element::before{} before和after必须有content属性 before在父元素内容前面创建元素，after在父元素内容后面插入元素 伪元素选择器与标签选择器权重一样 切换盒子模型 box-sizing:content-box 盒子大小为width+padding+border box-sizing:border-box 盒子大小为width CSS3过度鼠标悬浮时触发 transition:要过度的属性 花费时间(2s) 运动曲线(ease|liner) 何时开始(1s),要过度的属性 花费时间(2s) 运动曲线(ease) 何时开始(1s)； 全部变化，填all 2D转换 tranform:translate(x,y); tranform:translateX(x); tranform:translateY(y); transform:rotate(45deg); transform:scale(x,y) transform-origin: x y; 设置中心点 3D转换 transform:translate3d(x,y,z); tranform:translateX(x); tranform:translateY(y); transform:translateZ(z); perspective: px; &#x2F;&#x2F;透视写在观察元素的父元素上 transform-style:preserve-3d; &#x2F;&#x2F;子元素开启立体空间 动画 定义动画 12345678@keyframes move &#123; 0%(from) &#123; transform: translate(0px); &#125; 100%(to) &#123; transform: translate(100px); &#125;&#125; 调用动画 1animation: name duration timing-function delay iteration-count(1|infinite) direction(normal|alternate) fill-mode(backwords|forwords); 移动端常见布局 单独制作移动端页面 流式布局(百分比布局) flex弹性布局 less+rem+媒体查询布局 混合布局 响应式页面兼容移动端 媒体查询 bootstrap 流式布局 max-width: px;&#x2F;&#x2F;页面拉抻最大宽度 min-width: px;&#x2F;&#x2F;页面拉抻最小宽度 width:x% flex布局与浮动效果相似,但默认不换行，装不下时自动缩小子元素宽度 给父元素添加 display:flex; 给子元素设置宽高或分配比例 flex:1; 父元素属性 flex-direction:row|row-reverse|column|column-reverse 设置主轴 justify-content:flex-start|flex-end|center|space-around|space-between 设置主轴子元素排列方式 flex-wrap:nowrap|wrap 是否换行 align-items:flex-start|flex-end|center|stretch 设置侧轴子元素排列方式(单行) align-content:flex-start|flex-end|center|space-around|space-between|stretch 设置侧轴子元素排列方式(多行) flex-flow: flex-direction flex-wrap; 子元素属性 flex: 分配比例，可实现拉伸效果 align-self: 控制自己在侧轴的排列方式 order: 控制项目的排列顺序，越小越靠前，默认为0 rem适配方案通过修改html里面的文字大小来改变页面中元素的大小 媒体查询1234567891011121314151617181920212223//从小到大写，后面覆盖前面 &lt;link rel=&quot;stylesheet&quot; href=&quot;style320.css&quot; media=&quot;screen and (max-width:320px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style640.css&quot; media=&quot;screen and (min-width:640px)&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style960.css&quot; media=&quot;screen and (min-width:960px)&quot;&gt;//或@media screen and (max-width:539px) &#123; html&#123; &#125;&#125;@media screen and (min-width:540px) &#123; html &#123; &#125;&#125;@media screen and (min-width:970px) &#123; html &#123; &#125;&#125; lessvscode插件：easy less，cssrem 基本语法 @变量名:变量值 后代——嵌套 伪类&#x2F;伪元素选择器 &amp;: &amp;:: 运算符+-*&#x2F; 空格隔开 除法运算要加 () 单位不同则取第一个值的单位 @import “” 导入less文件 元素大小取值方法页面元素的rem值&#x3D;页面元素值（px)&#x2F;font-size字体大小","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"}]},{"title":"面试八股","slug":"面试八股","date":"2024-09-21T12:28:26.000Z","updated":"2024-10-18T09:15:31.191Z","comments":true,"path":"2024/09/21/面试八股/","permalink":"http://example.com/2024/09/21/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/","excerpt":"","text":"作用域 局部作用域 函数作用域：函数内部声明的变量只能在函数内部访问 块作用域：使用{}包裹的代码块内部声明的变量外部有可能无法访问 let和const产生块作用域 var不会产生块作用域 全局作用域：&lt;script&gt;标签和js文件的最外层，声明的变量在其他任何作用域都能访问 window对象动态添加的属性也是全局的 函数中未使用任何关键字声明的变量也是全局的 作用域链：优先查找当前，依次查找父级作用域 闭包 闭包 &#x3D; 内层函数+外层函数的变量 作用：外部可以访问函数内部的变量 闭包可能会引起内存泄漏 变量和函数提升代码执行前，所有var声明的变量被提升到当前作用域的最前面。只提升声明，不提升赋值。 代码执行前，所有函数声明被提升到当前作用域的最前面。 函数动态&#x2F;剩余参数与展开运算符 动态参数：arguments（伪数组）动态获取函数实参，箭头函数没有arguments 剩余参数：…arr（真数组）获取剩余参数至arr数组 展开运算符：…将一个数组展开 求数组最大值、合并数组 构造函数执行过程 创建新对象 构造函数this指向新对象 执行构造函数代码，修改this，添加新的属性 返回新对象 原型对象 每个构造函数都有一个prototype属性，指向原型对象 这个对象可以挂载函数，对象实例化不会多次创建原型上的函数，节约内存 构造函数通过原型分配的函数是所有对象所共享的，可以将不变的方法直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法 构造函数和原型对象中的this都指向实例化的对象 constructor原型对象上的构造器，指向构造函数 对象原型实例对象的__proto__属性,指向构造函数的原型对象 原型链 当访问一个对象的属性和方法时，首先查找这个对象自身有没有该属性。 如果没有就查找它的原型（就是__proto__指向的prototype原型对象。 如果还没有就继续查找原型对象的原型，直至查找到null 可以用 instanceof 运算符检测构造函数的prototype属性是否出现在某个实例对象的原型链上。 直接赋值、浅拷贝和深拷贝 直接赋值：传递的是地址，修改操作影响原对象 浅拷贝：创建一个新的对象，但只复制原始对象的基本数据类型的字段或引用（地址），而不复制引用指向的对象 深拷贝：创建一个新的对象，并且递归地复制原始对象的所有字段和引用指向的对象，而不仅仅是复制引用本身。深拷贝会递归复制整个对象结构，包括对象内部的对象，确保新对象和原始对象之间的所有关系都是独立的。 深拷贝实现123456789101112131415161718192021222324252627282930const obj = &#123; uname: &#x27;pink&#x27;, age: 18, hobby: [&#x27;乒乓球&#x27;, &#x27;足球&#x27;], family: &#123; baby: &#x27;小pink&#x27; &#125; &#125; const o = &#123;&#125;; function deepCopy(newObj, oldObj) &#123; for (let k in oldObj) &#123; if (oldObj[k] instanceof Array) &#123; newObj[k] = [] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj instanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; newObj[k] = oldObj[k] &#125; &#125; &#125; deepCopy(o, obj) o.uname = &#x27;hzx&#x27; o.hobby[0] = &#x27;篮球&#x27; o.family.baby = &#x27;小zx&#x27; console.log(obj) console.log(o) lodash 12import _ from &#x27;lodash&#x27;o = _.cloneDeep(obj) JSON 1o = JSON.parse(JSON.stringfy(obj)) 确定this的值在非严格模式下，总是指向同一个对象，在严格模式下可以是任意值 非严格模式 严格模式 全局环境 window window 直接调用 window undefined 对象方法调用 调用者 调用者 开启严格模式 1&#x27;use strict&#x27; 指定this的值 调用时指定 call方法 1func.call(thisArg,arg1,arg2...) apply方法 1func.apply(thisArg,[arg1,arg2...]) 创建时指定 bind方法 1const bindFunc = func.bind(thisArg,arg1,arg2...) 箭头函数 12345678const dog = &#123; name:&#x27;ason&#x27;, eat()&#123; setTimeout(()=&gt;&#123; console.log(this)//输出eat()的调用者dog &#125;) &#125;&#125; 面试回答: call与apply,bind都可以改变函数内部this指向 call和apply传递的参数形式不一样 bind不会立即调用函数，而是返回一个新函数 箭头函数:创建时会绑定上一级作用域中的this 手写call方法与apply方法1234567891011121314151617181920212223242526272829303132333435363738Function.prototype.myCall = function(thisArg,...args)&#123; const key = Symbol(&#x27;key&#x27;) thisArg[key] = this const res = thisArg[key](...args) delete thisArg[key] return res&#125;Function.prototype.myApply = function(thisArg,args)&#123; const key = Symbol(&#x27;key&#x27;) thisArg[key] = this const res = thisArg[key](args) delete thisArg[key] return res&#125;const person = &#123; name:&#x27;hzx&#x27;&#125;function func(numA,numB) &#123; console.log(this) console.log(numA,numB) return numA+numB&#125;function func2([numA,numB]) &#123; console.log(this) console.log(numA,numB) return numA+numB&#125;const res = func.myCall(person,2,8)console.log(&#x27;myCall返回值为：&#x27;,res)const res2 = func2.myApply(person,[2,8])console.log(&#x27;myApply的返回值为：&#x27;,res2) 面试回答：手写call方法的步骤为 在function的原型上添加myCall方法,保证所有函数都可以调用 方法内部,通过动态为对象添加方法的形式来指定this指向 调用完毕之后通过delete关键字删除上一步动态增加的方法 方法的名字通过Symbol进行设置,避免和默认名重复 使用剩余参数的形式传递参数2-参数n(函数参数) 手写apply方法 在function的原型上添加myApply方法,保证所有函数都可以调用 方法内部,通过动态为对象添加方法的形式来指定this指向 调用完毕之后通过delete关键字删除上一步动态增加的方法 方法的名字通过Symbol进行设置,避免和默认名重复 直接使用数组传递函数的参数,内部调用时结合...运算符展开数组 手写bind方法12345678910111213141516171819Function.prototype.myBind = function(thisArg,...args1)&#123; return (...args2)=&gt;&#123; return this.call(thisArg,...args1,...args2) &#125;&#125;const person = &#123; name:&#x27;hzx&#x27;&#125;function func(numA,numB,numC,numD) &#123; console.log(this) console.log(numA,numB,numC,numD) return numA+numB+numC+numD&#125;const bindFunc = func.myBind(person,1,2)const res = bindFunc(3,4)console.log(&#x27;myBind返回值为：&#x27;,res) 面试回答:手写bind方法 function原型上添加myBind函数,参数1为绑定的this,参数2-参数2为绑定的参数 内部返回一个新箭头函数,目的是绑定作用域中的this 返回的函数内部,通过call进行this和参数绑定 通过call的参数2和参数3指定绑定的参数,和调用时传递的参数 防抖防抖：单位时间内频繁触发事件，只执行最后一次 12import _ from &#x27;lodash&#x27;触发函数时调用的函数=_.debounce(func, [wait=0], [options=]) 手写防抖函数1234567891011function debounce(fn, t) &#123; // 1. 声明定时器变量 let timber; return function()&#123; // 2. 每次事件触发时先判断是否有定时器，如果有先清除以前的定时器 if(timber) clearTimeout(timber) // 3. 如果没有定时器，则开启定时器，存入到定时器变量里 // 4. 定时器里面写函数调用 timber = setTimeout(fn, t) &#125;&#125; 节流单位时间内频繁触发事件，只执行一次 12import _ from &#x27;lodash&#x27;触发函数时调用的函数=_.throttle(func, [wait=0], [options=]) 123456789101112131415function throttle(fn, t) &#123; // 1. 声明定时器变量 let timber = null; return function () &#123; if (!timber) &#123; // 2. 如果没有定时器，则开启定时器，存入到定时器变量里 // 3. 定时器里面写函数调用,并删除定时器 timber = setTimeout(function () &#123; fn() timber = null &#125;, t) &#125; &#125;&#125; JavaScript静态属性和私有属性面试回答:class实现继承 子类通过extends继承继承父类 子类如果需要重新定义构造函数,必须在内部通过super关键字调用父类的构造函数 静态：类通过static关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。 私有：类属性默认共有，可以使用增加哈希前缀#的方法来定义私有类字段，声明和访问时也需要加上,只能在类的内部访问。 123456789101112131415class Test &#123; static 静态属性 static 静态方法() &#123;&#125; #私有属性 #私有方法() &#123; &#125; info() &#123; this.#私有属性 this.#私有方法() &#125;&#125;Test.静态属性Test.静态方法() 面试回答:class语法补充 class中私有属性&#x2F;方法 定义和使用时需要使用关键字# 私有属性只能在类的内部使用,外部无法使用(代码中) Chrome的控制台中为了方便调试,可以直接访问 class中静态属性&#x2F;方法 定义和使用时需要使用关键字static 通过类访问 静态方法中的this是类 寄生组合继承123456789101112131415function Person(name) &#123; this.name = name&#125;Person.prototype.sayHi = function()&#123; console.log(`你好，我叫$&#123;this.name&#125;`)&#125;function Student(name) &#123; Person.call(this,name)&#125;Student.prototype = Object.create(Person,&#123; constructor:&#123; value:Student &#125;&#125;) 面试回答:ES5-寄生组合式继承 寄生组合式继承的核心步骤是:通过构造函数来继承属性,通过原型链来继承方法 寄生组合式继承和组合式继承的区别是:原型链的继承并没有调用父类的构造函数,而是直接基于父类的原型创建一个新副本实现继承 fetch方法123const res = await fetch(URL);res.statusconst data = await res.json(); 生成查询字符串： 12const p = new URLSearchParams(&#123;pname:&#x27;广东省&#x27;,cname:&#x27;深圳市&#x27;&#125;)p.toString() 1234567891011121314&lt;input type=&quot;file&quot; class=&quot;file&quot; accept=&quot;image/*&quot;&gt; &lt;script&gt; document.querySelector(&#x27;.file&#x27;).addEventListener(&#x27;change&#x27;, async function (e) &#123; // 生成FormData对象并添加数据 const data = new FormData() data.append(&#x27;img&#x27;, this.files[0]) const res = await fetch(&#x27;http://hmajax.itheima.net/api/uploadimg&#x27;, &#123; method: &#x27;post&#x27;, body: data &#125;) const json = await res.json() console.log(json) &#125;) &lt;/script&gt; 12345678910111213141516async function () &#123; // 通过headers设置请求头 const headers = new Headers() // 通过 content-type指定请求体数据格式 headers.append(&#x27;content-type&#x27;, &#x27;application/json&#x27;) // 参数1 url // 参数2 请求配置 const res = await fetch(&#x27;http://hmajax.itheima.net/api/register&#x27;, &#123; method: &#x27;post&#x27;,// 请求方法 headers, // 请求头 // 请求体 body: JSON.stringify(&#123; username: &#x27;itheima9876&#x27;, password: &#x27;123456&#x27; &#125;) &#125;) const json = await res.json() console.log(json) &#125; GeneratorGenerator-核心语法核心语法: 如何定义生成器函数: 如何获取generator对象 yield表达式的使用 通过for of获取每一个yield的值 12345678910111213141516171819202122232425262728293031// 1. 通过function* 创建生成器函数 function* foo() &#123; // 遇到yield表达式时会暂停后续的操作 yield &#x27;a&#x27; yield &#x27;b&#x27; yield &#x27;c&#x27; return &#x27;d&#x27;&#125;// 2. 调用函数获取生成器const f = foo()// 3. 通过next方法获取yield 之后的表达式结果，会被包装到一个对象中// 执行一次next 即可获取一次 yield之后的表达式结果const res1 = f.next()console.log(res1)// &#123;value: &#x27;a&#x27;, done: false&#125;const res2 = f.next()console.log(res2)// &#123;value: &#x27;b&#x27;, done: false&#125;const res3 = f.next()console.log(res3)// &#123;value: &#x27;c&#x27;, done: false&#125;// 最后一次可以拿到return的结果const res4 = f.next()console.log(res4)// &#123;value: &#x27;d&#x27;, done: true&#125; // done 为true之后，获取到的value为undefinedconst res5 = f.next()console.log(res5)// &#123;value: undefined, done: true&#125; // 4. 通过for of 获取每一个yield之后的值，const f2 = foo()for (const iterator of f2) &#123; console.log(iterator)&#125; 面试回答:Generator-核心语法 可以通过生成器函数(function* xxx()&#123;&#125;)来生成Generator对象: 通过Generator对象的next方法可以获取yield表达式之后的结果 Generator-id生成器**需求:**使用Generator实现一个id生成器id 12345678910function* idGenerator() &#123; // 逻辑略&#125;const idMaker = idGenerator()// 调用next方法,获取id(每次累加1)const &#123; value: id1 &#125; = idMaker.next()console.log(id1)const &#123; value: id2 &#125; = idMaker.next()console.log(id2) 核心步骤: 定义生成器函数 内部使用循环,通过yield返回id并累加 12345678910111213141516// 1. 通过function* 创建生成器函数 function* generator() &#123; let id = 0 // 无限循环 while (true) &#123; // id累加并返回 yield id++ &#125;&#125;// 2. 调用函数获取生成器const idMaker = generator()// 3. 需要id的时候 通过next获取即可const &#123; value: id1 &#125; = idMaker.next()console.log(id1)const &#123; value: id2 &#125; = idMaker.next()console.log(id2) 面试回答:Generator-id生成器 生成器函数内部的代码会在调用next方法时执行,利用这一特点,可以实现任意的生成器,需要时调用next即可获取结果 Generator-流程控制遇到yield表达式时会暂停后续的操作 **需求:**使用Generator实现流程控制 12345678function* weatherGenerator() &#123; // 逻辑略 yield axios()&#125;// 获取Generator实例const weather = weatherGenerator()// 依次获取 北上广深的天气 (axios)weather.next() 123456789101112131415161718192021222324252627282930&lt;button class=&quot;getWeather&quot;&gt;天气查询&lt;/button&gt;&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/axios/1.3.6/axios.js&quot;&gt;&lt;/script&gt;&lt;script&gt; /** * 需求：流程控制，依次查询，北上广深的天气预报 * 参考code: 北京 110100 上海 310100 广州 440100 深圳 440300 * 接口文档: https://apifox.com/apidoc/project-1937884/api-49760220 * */ function* weatherGenerator() &#123; // 北京 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=110100&#x27;) // 上海 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=310100&#x27;) // 广州 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=440100&#x27;) // 深圳 yield axios(&#x27;http://hmajax.itheima.net/api/weather?city=440300&#x27;) &#125; const cityWeather = weatherGenerator() document.querySelector(&#x27;.getWeather&#x27;).addEventListener(&#x27;click&#x27;,() =&gt; &#123; cityWeather.next().value.then(res=&gt;&#123; console.log(res) return cityWeather.next().value &#125;).then(res=&gt;&#123; console.log(res) return cityWeather.next().value &#125;) &#125;)&lt;/script&gt; 面试回答:Generator-流程控制 使用Generator控制流程的本质是利用yield关键字来分隔逻辑比如示例中依次调用了多个接口,通过yield分隔,通过next来触发调用 函数柯里化柯里化是把接收多个参数的函数变换成接收一个单一参数的函数，并返回接收剩余参数而且返回结果的新函数的技术。 1234567891011function sum(a,b)&#123; return a + b&#125;sum(a,b)function sum(a)&#123; return function(b)&#123; return a + b &#125;&#125;sum(a)(b) 123456789101112//改写函数sum实现：参数传递到5个即可实现累加const nums = []function sum(...args)&#123; nums.push(..args) if(nums.length&gt; = 5)&#123; const res = nums.slice(0,5).reduce((p,c)=&gt;p+c,0) nums = [] return res &#125;else&#123; return sum &#125;&#125; 1234567891011121314function sumMaker(length)&#123; const nums = [] function sum(...args)&#123; nums.push(..args) if(nums.length&gt; = length)&#123; const res = nums.slice(0,length).reduce((p,c)=&gt;p+c,0) nums = [] return res &#125;else&#123; return sum &#125; &#125; return sum&#125; 12345const typeofTest = function (type) &#123; return (thing)=&gt;&#123; return typeof thing === type &#125;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"}]},{"title":"2024-9-21","slug":"2024-9-21","date":"2024-09-21T11:48:00.000Z","updated":"2024-09-30T12:56:51.687Z","comments":true,"path":"2024/09/21/2024-9-21/","permalink":"http://example.com/2024/09/21/2024-9-21/","excerpt":"","text":"高新区的晚霞，我想我会想念这里的 今天状态不错 学信网档案更新啦","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"git","slug":"git","date":"2024-09-20T13:23:00.000Z","updated":"2024-09-21T05:18:35.327Z","comments":true,"path":"2024/09/20/git/","permalink":"http://example.com/2024/09/20/git/","excerpt":"","text":"常用命令 git reset –hard (commitId) 版本回退 git-log&#x2F;git log 查看版本 git add (file) 添加工作区到暂存区 git commit -m (“message”) 提交暂存区到本地仓库 git branch 查看分支 git branch (dev) 创建分支 git checkout (dev) 切换分支 git checkout -b (dev) 创建并切换分支 git merge (dev) 将某分支合并到当前分支 git branch -d (dev) 删除分支 -D 强制删除 git push [-f] [–set-upstream] [远端仓库名称 [本地分支名] [:远端分支名]] 推送到远程分支（同名可省略远端分支名） –set-upstream 推送的同时建立起和远程分支的关联关系 git branch -vv 查看本地分支和远程分支的对应关系 git clone [本地目录] 克隆仓库到本地 git fetch [remote name] [branch name] 抓取仓库里的更新到本地，不会进行合并 git pull [remote name] [branch name] 抓取仓库里的更新到本地,自动进行合并 常见分支 master分支 线上运行分支，主分支 dev分支 从master创建的分支，开发分支，开发完成后合并到master分支 feature分支 从dev创建的分支，同期并行开发一些功能，完成后合并到dev分支 hotfix分支 master派生的分支，线上bug修复使用，修复完成后合并到master、test、develop分支 配置公&#x2F;私钥 用户（hzx）目录下 12ssh-keygen -t rsacat .ssh/id_rsa.pub 到代码托管平台粘贴公钥 1ssh -T git@github.com 关联远程仓库 创建仓库时README,.gitignore，liscence都不要添加 1git remote add origin(远端仓库名称) git@github.com:hzx-bit/git_test.git(远程仓库地址) git remote 查看远程仓库 git push origin master 本地仓库推送到远程仓库 同步远程仓库，远程解决冲突 git fetch+git merge git pull","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"}]},{"title":"react-jike-mobile","slug":"react-jike-mobile","date":"2024-09-19T15:21:56.000Z","updated":"2024-09-20T07:20:03.521Z","comments":true,"path":"2024/09/19/react-jike-mobile/","permalink":"http://example.com/2024/09/19/react-jike-mobile/","excerpt":"","text":"初始化项目 npm create vite@latest react-jike-mobile – –template react-ts 精简项目结构 git init git commit -m “初始化项目” git add origin https://github.com/hzx-bit/react-jike-mobile.git git branch -M main git push -u origin main 安装依赖12npm i antd-mobile react-router-dom axiosnpm i sass @types/node -D 配置路径别名修改vite配置123456789101112131415//vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import react from &#x27;@vitejs/plugin-react&#x27;import path from &#x27;path&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [react()], resolve: &#123; alias: &#123; &#x27;@&#x27;: path.resolve(__dirname, &#x27;./src&#x27;), &#125;, &#125;,&#125;) 安装node类型包1npm i @types/node -D 修改tsconfig.app.json文件12345678&#123; &quot;baseUrl&quot;: &quot;.&quot;, &quot;paths&quot;: &#123; &quot;@/*&quot;: [ &quot;src/*&quot; ] &#125;,&#125; axios安装配置安装axios1npm i axios 简易封装123456789101112131415161718192021222324252627282930313233import axios from &#x27;axios&#x27;//1.根域名配置//2.超时时间//3.请求拦截器 响应拦截器const requestInstance = axios.create(&#123; baseURL: &#x27;http://geek.itheima.net/v1_0&#x27;, timeout: 5000,&#125;)// 添加请求拦截器//在请求发送之前 做拦截 处理参数requestInstance.interceptors.request.use( (config) =&gt; &#123; return config &#125;, (error) =&gt; &#123; return Promise.reject(error) &#125;)//添加响应拦截器requestInstance.interceptors.response.use( (response) =&gt; &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response &#125;, (error) =&gt; &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 return Promise.reject(error) &#125;)export default requestInstance 123import requestInstance from &#x27;./http&#x27;export &#123; requestInstance as http &#125;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"《我与地坛》文摘","slug":"《我与地坛》文摘","date":"2024-09-18T06:02:32.000Z","updated":"2024-09-19T14:10:12.589Z","comments":true,"path":"2024/09/18/《我与地坛》文摘/","permalink":"http://example.com/2024/09/18/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B%E6%96%87%E6%91%98/","excerpt":"","text":"一个人，出生了，这就不再是一个可以辩论的问题，而只是上帝交给他的一个事实；上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。这样想过之后我安心多了，眼前的一切不再那么可怕。比如你起早熬夜准备考试的时候，忽然想起有一个长长的假期在前面等待你，你会不会觉得轻松一点儿？并且庆幸并且感激这样的安排？ 有一年，十月的风又翻动起安详的落叶，我在园中读书，听见两个散步的老人说：“没想到这园子有这么大。”我放下书，想，这么大一座园子，要在其中找到她的儿子，母亲走过了多少焦灼的路。多年来我头一次意识到，这园中不单是处处都有过我的车辙，有过我的车辙的地方也都有过母亲的脚印。 谁又能把这世界想个明白呢？世上的很多事是不堪说的。你可以抱怨上帝何以要降诸多苦难给这人间，你也可以为消灭种种苦难而奋斗，并为此享有崇高与骄傲，但只要你再多想一步你就会坠入深深的迷茫了：假如世界上没有了苦难，世界还能够存在么？要是没有愚钝，机智还有什么光荣呢？要是没了丑陋，漂亮又怎么维系自己的幸运？要是没有了恶劣和卑下，善良与高尚又将如何界定自己又如何成为美德呢？要是没有了残疾，健全会否因其司空见惯而变得腻烦和乏味呢？我常梦想着在人间彻底消灭残疾，但可以相信，那时将由患病者代替残疾人去承担同样的苦难。如果能够把疾病也全数消灭，那么这份苦难又将由(比如说)相貌丑陋的人去承担了。就算我们连丑陋，连愚昧和卑鄙和一切我们所不喜欢的事物和行为，也都可以统统消灭掉，所有的人都一样健康、漂亮、聪慧、高尚，结果会怎样呢？怕是人间的剧目就全要收场了，一个失去差别的世界将是一潭死水，是一块没有感觉没有肥力的沙漠。 看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。 于是就有一个最令人绝望的结论等在这里：由谁去充任那些苦难的角色？又有谁去体现这世间的幸福、骄傲和快乐？只好听凭偶然，是没有道理好讲的。 就命运而言，休论公道。 那么，一切不幸命运的救赎之路在哪里呢？ 设若智慧或悟性可以引领我们去找到救赎之路，难道所有的人都能够获得这样的智慧和悟性吗？ 我常以为是丑女造就了美人。我常以为是愚氓举出了智者。我常以为是懦夫衬照了英雄。我常以为是众生度化了佛祖。 这下好了，您不再恐慌了不再是个人质了，您自由了。算了吧你，我怎么可能自由呢？别忘了人真正的名字是：欲望。所以您得知道，消灭恐慌的最有效的办法就是消灭欲望。可是我还知道，消灭人性的最有效的办法也是消灭欲望。那么，是消灭欲望同时也消灭恐慌呢？还是保留欲望同时也保留人生？ 我在这园子里坐着，我听见园神告诉我：每一个有激情的演员都难免是一个人质。每一个懂得欣赏的观众都巧妙地粉碎了一场阴谋。每一个乏味的演员都是因为他老以为这戏剧与自己无关。每一个倒霉的观众都是因为他总是坐得离舞台太近了。我在这园子里坐着，园神成年累月地对我说：孩子，这不是别的，这是你的罪孽和福祉。 要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，也不能想，却又不能忘。它们不能变成语言，它们无法变成语言，一旦变成语言就不再是它们了。它们是一片朦胧的温馨与寂寥，是一片成熟的希望与绝望，它们的领地只有两处：心与坟墓。比如说邮票，有些是用于寄信的，有些仅仅是为了收藏。 我说不好我想不想回去。我说不好是想还是不想，还是无所谓。我说不好我是像那个孩子，还是像那个老人，还是像一个热恋中的情人。很可能是这样：我同时是他们三个。我来的时候是个孩子，他有那么多孩子气的念头所以才哭着喊着闹着要来，他一来一见到这个世界便立刻成了不要命的情人，而对一个情人来说，不管多么漫长的时光也是稍纵即逝，那时他便明白，每一步每一步，其实一步步都是走在回去的路上。当牵牛花初开的时节，葬礼的号角就已吹响。 但是太阳，它每时每刻都是夕阳也都是旭日。当它熄灭着走下山去收尽苍凉残照之际，正是它在另一面燃烧着爬上山巅布散烈烈朝辉之时。那一天，我也将沉静着走下山去，扶着我的拐杖。有一天，在某一处山洼里，势必会跑上来一个欢蹦的孩子，抱着他的玩具。 当然，那不是我。 但是，那不是我吗？ 宇宙以其不息的欲望将一个歌舞炼为永恒。这欲望有怎样一个人间的姓名，大可忽略不计。 因此偶尔有人说我是活在世外桃源，语气中不免流露了一点儿讥讽，仿佛这全是出于我的自娱甚至自欺。我颇不以为然。我既非活在世外桃源，也从不相信有什么世外桃源。但我相信世间桃源，世间确有此源，如果没有恐怕谁也就不想再活；倘此源有时弱小下去，依我看，至少讥讽并不能使其强大。千万年来它作为现实，更作为信念，这才不断。它源于心中再流入心中，它施于心又由于心，这才不断。欲其强大，舍心之虔诚又向何求呢？ 也有人说我是不是一直活在童话里？语气中既有赞许又有告诫。赞许并且告诫，这很让我信服。赞许既在，告诫并不意指人们之间应该加固一条防线，而只是提醒我：童话的缺憾不在于它太美，而在于它必要走进一个更为纷繁而且严酷的世界，那时只怕它太娇嫩。 我想，倘有来世，我先要占住几项先天的优越：聪明、漂亮和一副好身体。命运从一开始就不公平，人一生下来就有走运的和不走运的。譬如说一个人很笨，这该怨他自己吗？然而由此所导致的一切后果却完全要由他自己负责——他可能因此在兄弟姐妹之中是最不被父母喜爱的一个，他可能因此常受教师的斥责和同学们的嘲笑，他于是便更加自卑、更加委顿，饱受了轻蔑终也不知这事到底该怨谁。再譬如说，一个人生来就丑，相当丑，再怎么想办法去美容都无济于事，这难道是他的错误是他的罪过？不是，好，不是。那为什么就该他难得姑娘们的喜欢呢？因而婚事就变得格外困难，一旦有个漂亮姑娘爱上他却又赢得多少人的惊诧和不解，终于有了孩子，不要说别人就连他自己都希望孩子千万别长得像他自己。为什么就该他是这样呢？为什么就该他常遭取笑，常遭哭笑不得的外号，或者常遭怜悯，常遭好心人小心翼翼地对待呢？再说身体，有的人生来就肩宽腿长潇洒英俊（或者婀娜妩媚娉娉婷婷），生来就有一身好筋骨，跑得也快跳得也高，气力足耐力又好，精力旺盛，而且很少生病，可有的人却与此相反生来就样样都不如人。对于身体，我的体会尤甚。譬如写文章，有的人写一整天都不觉得累，可我连续写上三四个钟头眼前就要发黑。譬如和朋友们一起去野游，满心欢喜妙想联翩地到了地方，大家的热情正高雅趣正浓，可我已经累得只剩了让大家扫兴的份儿了。所以我真希望来世能有一副好身体。今生就不去想它了，只盼下辈子能够谨慎投胎，有健壮优美如卡尔·刘易斯一般的身材和体质，有潇洒漂亮如周恩来一般的相貌和风度，有聪明智慧如阿尔伯特·爱因斯坦一般的大脑和灵感。 既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？我便如醉如痴并且极端自私自利地梦想下去。 其实秘密就已经是墙了。肚皮和眼皮都是墙，假笑和伪哭都是墙，只因这样的墙嫌软嫌累，要弄些坚实耐久的来加密。就算这心灵之墙可以轻易拆除，但山和水都是墙，天和地都是墙，时间和空间都是墙，命运是无穷的限制，上帝的秘密是不尽的墙。真要把这秘密之墙也都拆除，虽然很像是由来已久的理想接近了实现，但是等着瞧吧，满地球都怕要因为失去趣味而响起昏昏欲睡的鼾声，梦话亦不知从何说起。 趣味是要紧而又要紧的。秘密要好好保存。 探秘的欲望终于要探到意义的墙下。 真是神奇。很可能，生和死都不过取决于观察，取决于观察的远与近。比如，当一颗距离我们数十万光年的星星实际早已熄灭，它却正在我们的视野里度着它的青年时光。 时间限制了我们，习惯限制了我们，谣言般的舆论让我们陷于实际，让我们在白昼的魔法中闭目塞听不敢妄为。白昼是一种魔法，一种符咒，让僵死的规则畅行无阻，让实际消磨掉神奇。所有的人都在白昼的魔法之下扮演着紧张、呆板的角色，一切言谈举止，一切思绪与梦想，都仿佛被预设的程序所圈定。 因而我盼望夜晚，盼望黑夜，盼望寂静中自由的到来。 甚至盼望站到死中，去看生。","categories":[{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"}],"tags":[{"name":"《我与地坛》","slug":"《我与地坛》","permalink":"http://example.com/tags/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B/"}]},{"title":"中秋","slug":"中秋","date":"2024-09-17T12:20:02.000Z","updated":"2024-09-17T12:39:04.124Z","comments":true,"path":"2024/09/17/中秋/","permalink":"http://example.com/2024/09/17/%E4%B8%AD%E7%A7%8B/","excerpt":"","text":"但愿人长久，千里共婵娟独在异乡为异客，每逢佳节倍思亲 感谢老姐拍来老家的月亮（合肥刮台风看不到）","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"react-jike","slug":"react-jike","date":"2024-09-16T04:05:55.000Z","updated":"2024-10-14T08:48:33.695Z","comments":true,"path":"2024/09/16/react-jike/","permalink":"http://example.com/2024/09/16/react-jike/","excerpt":"","text":"目录结构 文件夹 作用 apis 接口 assets 静态资源 components 通用组件 pages 页面级组件 router 路由Router store Redux状态 utils 工具函数 安装依赖12npm i sass @craco/craco -Dnpm i antd react-router-dom axios @reduxjs/toolkit react-redux normalize.css xxxxxxxxxx import requestInstance from ‘.&#x2F;http’​export { requestInstance as http }typescript12345678910111213//index.jsimport &#x27;normalize.css&#x27;//index.scsshtml,body &#123; margin: 0; height: 100%;&#125;#root &#123; height: 100%;&#125; 配置别名路径 项目根目录创建craco.config.js，添加路径解析配置 123456789const path = require(&#x27;path&#x27;)module.exports = &#123; webpack:&#123; alias:&#123; &#x27;@&#x27;:path.resolve(__dirname,&#x27;src&#x27;) &#125; &#125;&#125; package.json中配置启动和打包配置 123456&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; &#125;, 根目录下创建jsconfig.json 12345678910&#123; &quot;compilerOptions&quot;:&#123; &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;:&#123; &quot;@/*&quot;:[ &quot;src/*&quot; ] &#125; &#125;&#125; 配置路由 page文件夹放置路由组件&lt;Outlet/&gt;,或navigate&#x3D;useNavigate()，调用navigate()函数 router文件夹配置路由 createBrowserRouter index.js 提供路由 &lt;RouterProvider router=&#123;router&#125;/&gt; 获取parameter 123456789navigate(&#x27;/article?id=1001&#x27;)const [params] = useSearchParams()let id = params.get(&#x27;id&#x27;)path:&#x27;/article/:id/:name&#x27;navigate(&#x27;/article/1001/jack&#x27;)const params = useParams()let id = params.id 关联远程github项目git init git add . git commit -m “项目初始化” git remote add origin https://github.com/hzx-bit/react-jike.git git push –set-upstream origin master 封装request请求模块 在utils文件夹中新建request.js文件 12345678910111213141516171819202122232425262728293031323334353637383940//axios封装处理import axios from &quot;axios&quot;;//1.根域名配置//2.超时时间//3.请求拦截器 响应拦截器const request = axios.create(&#123; baseURL: &#x27;http://geek.itheima.net/v1_0&#x27;, timeout: 5000&#125;)// 添加请求拦截器//在请求发送之前 做拦截 处理参数request.interceptors.request.use((config)=&gt; &#123; const token = getToken() if(token)&#123; config.headers.Authorization = `Bearer $&#123;token&#125;` &#125; return config &#125;, (error)=&gt; &#123; return Promise.reject(error)&#125;)// 添加响应拦截器request.interceptors.response.use((response)=&gt; &#123; // 2xx 范围内的状态码都会触发该函数。 // 对响应数据做点什么 return response.data &#125;, (error)=&gt; &#123; // 超出 2xx 范围的状态码都会触发该函数。 // 对响应错误做点什么 //监控401 token失效 if(error.response.status === 401)&#123; removeToken() router.navigate(&#x27;/login&#x27;) window.location.reload() &#125; return Promise.reject(error)&#125;)export &#123;request&#125; 在utils文件夹中新建index.js文件，统一中转工具模块函数 1234import &#123; request &#125; from &quot;./request&quot;;export&#123; request&#125; 使用Redux管理token12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//token.jsconst TOKENKEY = &#x27;token_key&#x27;function setToken(token)&#123; localStorage.setItem(TOKENKEY,token)&#125;function getToken()&#123; return localStorage.getItem(TOKENKEY)&#125;function removeToken()&#123; localStorage.removeItem(TOKENKEY)&#125;export&#123; setToken, getToken, removeToken&#125;//user.js//和用户相关的状态管理import &#123; request &#125; from &quot;@/utils&quot;;import &#123; createSlice &#125; from &quot;@reduxjs/toolkit&quot;;import &#123; setToken as _setToken,getToken &#125; from &quot;@/utils&quot;;const userStore = createSlice(&#123; name:&#x27;user&#x27;, initialState:&#123; token:getToken()||&#x27;&#x27; &#125;, reducers:&#123; setToken(state,action)&#123; state.token = action.payload _setToken(action.payload) &#125; &#125;&#125;)//解构出actionCreaterconst &#123;setToken&#125; = userStore.actionsconst reducer = userStore.reducerconst fetchLogin = (loginForm)=&gt;&#123; return async(dispatch)=&gt;&#123; const res = await request.post(&#x27;/authorizations&#x27;,loginForm) dispatch(setToken(res.data.token)) &#125;&#125;export &#123;fetchLogin&#125;export default reducer 根据Token控制路由跳转123456789101112131415161718192021//AuthRoute.jsimport &#123; getToken &#125; from &quot;@/utils&quot;import &#123; Navigate &#125; from &quot;react-router-dom&quot;function AuthRoute(&#123;children&#125;)&#123; const token = getToken() if(token)&#123; return &lt;&gt;&#123;children&#125;&lt;/&gt; &#125; else return &lt;Navigate to=&#123;&#x27;/login&#x27;&#125; replace/&gt;&#125;export default AuthRoute//配置router&#123; path:&#x27;/&#x27;, element:&lt;AuthRoute&gt;&lt;Layout/&gt;&lt;/AuthRoute&gt;&#125; echartsnpm i echarts 123456789101112131415161718192021222324252627282930313233343536373839import * as echarts from &#x27;echarts&#x27;import &#123; useEffect, useRef &#125; from &#x27;react&#x27;const Home = ()=&gt;&#123; const chartRef = useRef(null) useEffect(()=&gt;&#123; //1. 获取渲染图表的dom节点 const chartDom = chartRef.current //2. 图表初始化生成图表实例对象 const myChart = echarts.init(chartDom) //3. 准备图表参数 const option = &#123; xAxis: &#123; type: &#x27;category&#x27;, data: [&#x27;Vue&#x27;, &#x27;React&#x27;, &#x27;Angular&#x27;] &#125;, yAxis: &#123; type: &#x27;value&#x27; &#125;, series: [ &#123; data: [10,40,70], type: &#x27;bar&#x27; &#125; ] &#125;; //使用图表参数完成图表渲染 option &amp;&amp; myChart.setOption(option); &#125;,[]) return ( &lt;div&gt; //确保节点具有宽高 &lt;div ref=&#123;chartRef&#125; style=&#123;&#123;width:&#x27;500px&#x27;,height:&#x27;400px&#x27;&#125;&#125;&gt;&lt;/div&gt; &lt;/div&gt; ) apis文件夹封装函数1234567891011121314151617181920212223//user.js//用户相关的所有请求const &#123; request &#125; = require(&quot;@/utils&quot;);//1. 用户登录function loginAPI(formData)&#123; return request(&#123; url:&#x27;/authorizations&#x27;, method:&#x27;POST&#x27;, data:formData &#125;)&#125;function getProfileAPI()&#123; return request(&#123; url:&#x27;/user/profile&#x27;, method:&#x27;GET&#x27; &#125;)&#125;export &#123;loginAPI,getProfileAPI&#125; 富文本编辑器npm i &#x72;&#x65;&#x61;&#99;&#116;&#45;&#113;&#117;&#105;&#x6c;&#108;&#x40;&#x32;&#x2e;&#48;&#x2e;&#x30;&#45;&#98;&#101;&#x74;&#x61;&#46;&#50; 123456789101112131415161718192021222324import ReactQuill from &#x27;react-quill&#x27;import &#x27;react-quill/dist/quill.snow.css&#x27;const Publish = () =&gt; &#123; return ( // ... &lt;Form labelCol=&#123;&#123; span: 4 &#125;&#125; wrapperCol=&#123;&#123; span: 16 &#125;&#125; &gt; &lt;Form.Item label=&quot;内容&quot; name=&quot;content&quot; rules=&#123;[&#123; required: true, message: &#x27;请输入文章内容&#x27; &#125;]&#125; &gt; &lt;ReactQuill className=&quot;publish-quill&quot; theme=&quot;snow&quot; placeholder=&quot;请输入文章内容&quot; /&gt; &lt;/Form.Item&gt; &lt;/Form&gt; )&#125; 刷新页面window.location.reload() 项目打包 npm run build serve -s build 路由懒加载12const Home = lazy(()=&gt;import(&quot;@/pages/Home&quot;))&lt;Suspense fallback=&#123;&#x27;加载中&#x27;&#125;&gt;&lt;Home/&gt;&lt;/Suspense&gt; 包体积可视化分析 npm i source-map-explore package.json中配置 1234567&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;craco start&quot;, &quot;build&quot;: &quot;craco build&quot;, &quot;test&quot;: &quot;craco test&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot;, &quot;analyze&quot;:&quot;source-map-explorer &#x27;build/static/js/*.js&#x27;&quot;&#125;, npm run analyze CDN优化 CDN是一种内容分发网络服务，当用户请求网站内容时，由离用户最近的服务器将缓存的资源内容传递给用户 体积较大的非业务js文件，比如react、react-dom可以放到CDN服务器 体积较大，需要利用CDN文件在浏览器的缓存特性，加快加载时间 非业务JS文件，不需要经常做变动，CDN不用频繁更新缓存 具体做法 把需要做CDN缓存的文件排除在打包之外 以CDN的方式重新引入资源 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//craco.config.js// 添加自定义对于webpack的配置const path = require(&#x27;path&#x27;)const &#123; whenProd, getPlugin, pluginByName &#125; = require(&#x27;@craco/craco&#x27;)module.exports = &#123; // webpack 配置 webpack: &#123; // 配置别名 alias: &#123; // 约定：使用 @ 表示 src 文件所在路径 &#x27;@&#x27;: path.resolve(__dirname, &#x27;src&#x27;) &#125;, // 配置webpack // 配置CDN configure: (webpackConfig) =&gt; &#123; let cdn whenProd(() =&gt; &#123; // key: 不参与打包的包(由dependencies依赖项中的key决定) // value: cdn文件中 挂载于全局的变量名称 为了替换之前在开发环境下 webpackConfig.externals = &#123; react: &#x27;React&#x27;, &#x27;react-dom&#x27;: &#x27;ReactDOM&#x27; &#125; // 配置现成的cdn资源地址 // 实际开发的时候 用公司自己花钱买的cdn服务器 cdn = &#123; js: [ &#x27;https://cdnjs.cloudflare.com/ajax/libs/react/18.1.0/umd/react.production.min.js&#x27;, &#x27;https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.1.0/umd/react-dom.production.min.js&#x27;, ] &#125; &#125;) // 通过 htmlWebpackPlugin插件 在public/index.html注入cdn资源url const &#123; isFound, match &#125; = getPlugin( webpackConfig, pluginByName(&#x27;HtmlWebpackPlugin&#x27;) ) if (isFound) &#123; // 找到了HtmlWebpackPlugin的插件 match.options.files = cdn &#125; return webpackConfig &#125; &#125;&#125; 12345678//index.html&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- 加载第三发包的 CDN 链接 --&gt; &lt;% htmlWebpackPlugin.options.files.js.forEach(cdnURL =&gt; &#123; %&gt; &lt;script src=&quot;&lt;%= cdnURL %&gt;&quot;&gt;&lt;/script&gt; &lt;% &#125;) %&gt;&lt;/body&gt;","categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"react","slug":"react","date":"2024-09-16T02:24:16.000Z","updated":"2024-10-17T09:28:31.658Z","comments":true,"path":"2024/09/16/react/","permalink":"http://example.com/2024/09/16/react/","excerpt":"","text":"跨域代理配置 npm install http-proxy-middleware –save npm install axios 新建setupProxy.js文件 123456789101112const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;); module.exports = function (app) &#123; app.use( &#x27;/api1&#x27;, createProxyMiddleware(&#123; target: &#x27;http://localhost:5000&#x27;, changeOrigin: true, pathRewrite:&#123;&#x27;^/api1&#x27;:&#x27;&#x27;&#125; &#125;) );&#125;; 发布订阅 npm install pubsub-js –save 123456import PubSub from &#x27;pubsub-js&#x27;//引入PubSub.publish(&#x27;atguigu&#x27;,&#123;isFirst:false,isLoading:true&#125;)//发布this.token = PubSub.subscribe(&#x27;atguigu&#x27;,(_,data)=&gt;&#123; this.setState(data); &#125;)//订阅PubSub.unsubscribe(this.token);//取消订阅 fetch123456789async()=&gt;&#123; try&#123; const response = await fetch(`/api1/search/user2?q=$&#123;KeyWord&#125;`); const data = await response.json(); console.log(data); &#125;catch(error)&#123; console.log(&#x27;请求出错&#x27;,error); &#125;&#125; lodash（排序）12import _ from &#x27;lodash&#x27;_.orderBy(list,&#x27;key&#x27;,&#x27;desc&#x27;); classNames（高亮切换）123import classNames from &#x27;classnames&#x27;&lt;className=&#123;classNames(&#x27;normal-style&#x27;,&#123;&#x27;active&#x27;:type===item.type&#125;)&#125;&gt;&lt;className=&#123;classNames(&#x27;normal-style&#x27;,type===item.type&amp;&amp;&#x27;active&#x27;)&#125;&gt; uuid12import &#123; v4 as uuidv4 &#125; from &#x27;uuid&#x27;;uuidv4(); dayjs12import dayjs from &#x27;dayjs&#x27;dayjs().format(); useRef123456789import &#123;useRef&#125; from &#x27;react&#x27;const inputRef = useRef(null);&lt;input type=&quot;text&quot; ref=&#123;inputRef&#125;/&gt;inputRef.current//拿到节点 跨级传递信息123456import &#123;createContext,useContext&#125;const MsgContext = createContext()&lt;MsgContext.Provider value=&#123;msg&#125;&gt; &lt;Component/&gt;&lt;/MsgContext.Provider&gt;const msg = useContext(MsgContext); useEffect 无参：初始和更新 空数组：初始 依赖项：初始和依赖项发生变化 返回的函数在组件销毁时调用 1234567891011121314151617import &#123;useEffect,useState&#125; from &#x27;react&#x27;const URL=&#x27;http://geek.itheima.net/v1_0/channels&#x27;const [list, setList] = useState([]); useEffect(()=&gt;&#123; async function getList() &#123; const res =await fetch(URL); const jsonRes =await res.json(); setList(jsonRes.data.channels); &#125; getList(); const timer = setInterval(()=&gt;&#123; console.log(&#x27;............&#x27;) &#125;,1000) return ()=&gt;&#123; clearInterval(timer) &#125; &#125;,[]); json-server npm install json-server 根目录下新建db.json 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&#123; &quot;posts&quot;: [ &#123; &quot;id&quot;: 1, &quot;title&quot;: &quot;json-server&quot;, &quot;author&quot;: &quot;typicode&quot; &#125; ], &quot;comments&quot;: [ &#123; &quot;id&quot;: 1, &quot;body&quot;: &quot;some comment&quot;, &quot;postId&quot;: 1 &#125; ], &quot;profile&quot;: &#123; &quot;name&quot;: &quot;typicode&quot; &#125;, &quot;list&quot;:[ &#123; &quot;rpid&quot;: 3, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;13258165&quot;, &quot;avatar&quot;: &quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.FY7sfLpXX6K8x4SfSxFA0gHaHa?w=200&amp;h=199&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;周杰伦&quot; &#125;, &quot;content&quot;: &quot;哎哟，不错哦&quot;, &quot;ctime&quot;: &quot;10-18 08:15&quot;, &quot;like&quot;: 99 &#125;, &#123; &quot;rpid&quot;: 2, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;36080105&quot;, &quot;avatar&quot;: &quot;https://tse4-mm.cn.bing.net/th/id/OIP-C.B7PjPsZql8BH1LLnLZawvgAAAA?w=195&amp;h=195&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;许嵩&quot; &#125;, &quot;content&quot;: &quot;我寻你千百度 日出到迟暮&quot;, &quot;ctime&quot;: &quot;11-13 11:29&quot;, &quot;like&quot;: 88 &#125;, &#123; &quot;rpid&quot;: 1, &quot;user&quot;: &#123; &quot;uid&quot;: &quot;30009257&quot;, &quot;avatar&quot;: &quot;https://tse3-mm.cn.bing.net/th/id/OIP-C.FY7sfLpXX6K8x4SfSxFA0gHaHa?w=200&amp;h=199&amp;c=7&amp;r=0&amp;o=5&amp;dpr=2&amp;pid=1.7&quot;, &quot;uname&quot;: &quot;黑马前端&quot; &#125;, &quot;content&quot;: &quot;学前端就来黑马&quot;, &quot;ctime&quot;: &quot;10-19 09:00&quot;, &quot;like&quot;: 66 &#125; ]&#125; package.json 配置 1&quot;serve&quot;: &quot;json-server db.json --port 3004&quot; npm run serve Redux npm i @reduxjs&#x2F;toolkit react-redux Store（仓库）： Store 是应用程序状态的中央存储库。它包含了整个应用程序的状态树，即一个 JavaScript 对象。Redux 规定了应用程序状态只能通过 Store 来管理和修改，确保了状态的单一数据源。通过 createStore 函数来创建 Store。 Action（动作）： Action 是描述发生了什么事件的普通 JavaScript 对象。它们是将数据从应用程序传递到 Store 的唯一方式。每个 Action 都必须包含一个 type 属性，表示动作的类型，以及可选的 payload 属性，用于传递数据。Action 只用于描述事件，不进行状态的修改。 Reducer（归纳器）： Reducer 是一个纯函数，用于定义应用程序状态的修改方式。Reducer 接收当前状态和一个 Action，根据 Action 的类型来返回一个新的状态。Redux 应用程序通常包含多个 Reducer，每个 Reducer 负责管理状态树的一部分。Reducer 应当保持纯净，不应该产生副作用。 Dispatch（分发）： Dispatch 是一个函数，用于将 Action 发送到 Store，以便触发状态的修改。当组件需要修改应用程序的状态时，它会创建一个 Action 并将其分发到 Store。Dispatch 将 Action 发送给 Reducer，Reducer 根据 Action 的类型来更新状态。 Middleware（中间件）： Middleware 是 Redux 的一个扩展点，用于在 Action 发送到 Reducer 之前或之后执行额外的逻辑。例如，可以使用 Middleware 来处理异步操作、记录日志、路由导航等。Redux 提供了一些内置的 Middleware，也可以编写自定义 Middleware。 Selectors（选择器）： 选择器是用于从应用程序状态中提取数据的函数。它们可以帮助组件获取所需的状态，同时封装了状态的结构和访问方式。Selectors 有助于减少组件对状态的直接依赖，提高代码的可维护性。 在modules文件夹下创建不同的store切片，每个store有自己的name、initialState和reducers，reducers有管理状态的方法（与actions同名）。从store中解构出actions和reducer并导出 在index.js中导入reducer，配置store中的reducer &lt;Provider store=&#123;store&#125;&gt;包裹根节点 在App.js中用useSelector取出数据，用useDispatch产生dispatch函数，导入actions，需要时调用dispatch（action) antd-mobile npm install antd-mobile Ant Design Mobile useReducer123456789101112131415161718192021222324252627282930313233343536// 定义reducerimport &#123; useReducer &#125; from &#x27;react&#x27;// 1. 根据不同的action返回不同的新状态function reducer(state, action) &#123; console.log(&#x27;reducer执行了&#x27;) switch (action.type) &#123; case &#x27;INC&#x27;: return state + 1 case &#x27;DEC&#x27;: return state - 1 case &#x27;UPDATE&#x27;: return state + action.payload default: return state &#125;&#125;function App() &#123; // 2. 使用useReducer分派action const [state, dispatch] = useReducer(reducer, 0) return ( &lt;&gt; &#123;/* 3. 调用dispatch函数传入action对象 触发reducer函数，分派action操作，使用新状态更新视图 */&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;DEC&#x27; &#125;)&#125;&gt;-&lt;/button&gt; &#123;state&#125; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;INC&#x27; &#125;)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: &#x27;UPDATE&#x27;, payload: 100 &#125;)&#125;&gt; update to 100 &lt;/button&gt; &lt;/&gt; )&#125;export default App useMemo使用场景：缓存性能消耗大的计算 1234567891011121314151617181920212223242526272829import &#123; useMemo, useState &#125; from &#x27;react&#x27;function fib (n) &#123; console.log(&#x27;计算函数执行了&#x27;) if (n &lt; 3) return 1 return fib(n - 2) + fib(n - 1)&#125;function App() &#123; const [count, setCount] = useState(0) // 计算斐波那契之和 // const sum = fib(count) // 通过useMemo缓存计算结果，只有count发生变化时才重新计算 const sum = useMemo(() =&gt; &#123; return fib(count) &#125;, [count]) const [num, setNum] = useState(0) return ( &lt;&gt; &#123;sum&#125; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+count:&#123;count&#125;&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt;+num:&#123;num&#125;&lt;/button&gt; &lt;/&gt; )&#125;export default App React.memo作用：允许组件在props没有改变的情况下跳过重新渲染 机制：只有props发生变化时才重新渲染下面的子组件通过 memo 进行包裹之后，返回一个新的组件MemoSon, 只有传给MemoSon的props参数发生变化时才会重新渲染 12345678910111213141516171819import React, &#123; useState &#125; from &#x27;react&#x27;const MemoSon = React.memo(function Son() &#123; console.log(&#x27;子组件被重新渲染了&#x27;) return &lt;div&gt;this is span&lt;/div&gt;&#125;)function App() &#123; const [, forceUpdate] = useState() console.log(&#x27;父组件重新渲染了&#x27;) return ( &lt;&gt; &lt;MemoSon /&gt; &lt;button onClick=&#123;() =&gt; forceUpdate(Math.random())&#125;&gt;update&lt;/button&gt; &lt;/&gt; )&#125;export default App props变化重新渲染1234567891011121314151617181920import React, &#123; useState &#125; from &#x27;react&#x27;const MemoSon = React.memo(function Son() &#123; console.log(&#x27;子组件被重新渲染了&#x27;) return &lt;div&gt;this is span&lt;/div&gt;&#125;)function App() &#123; console.log(&#x27;父组件重新渲染了&#x27;) const [count, setCount] = useState(0) return ( &lt;&gt; &lt;MemoSon count=&#123;count&#125; /&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&#123;count&#125;&lt;/button&gt; &lt;/&gt; )&#125;export default App 对于props的比较，进行的是‘浅比较’，底层使用 Object.is 进行比较，针对于对象数据类型，只会对比俩次的引用是否相等，如果不相等就会重新渲染，React并不关心对象中的具体属性 useCallback缓存函数 useCallback缓存之后的函数可以在组件渲染时保持引用稳定，也就是返回同一个引用 12345678910111213141516171819202122232425// useCallBackimport &#123; memo, useCallback, useState &#125; from &#x27;react&#x27;const MemoSon = memo(function Son() &#123; console.log(&#x27;Son组件渲染了&#x27;) return &lt;div&gt;this is son&lt;/div&gt;&#125;)function App() &#123; const [, forceUpate] = useState() console.log(&#x27;父组件重新渲染了&#x27;) const onGetSonMessage = useCallback((message) =&gt; &#123; console.log(message) &#125;, []) return ( &lt;div&gt; &lt;MemoSon onGetSonMessage=&#123;onGetSonMessage&#125; /&gt; &lt;button onClick=&#123;() =&gt; forceUpate(Math.random())&#125;&gt;update&lt;/button&gt; &lt;/div&gt; )&#125;export default App forwardRef作用：允许组件使用ref将一个DOM节点暴露给父组件 12345678910111213141516171819202122import &#123; forwardRef, useRef &#125; from &#x27;react&#x27;const MyInput = forwardRef(function Input(props, ref) &#123; return &lt;input &#123;...props&#125; type=&quot;text&quot; ref=&#123;ref&#125; /&gt;&#125;, [])function App() &#123; const ref = useRef(null) const focusHandle = () =&gt; &#123; console.log(ref.current.focus()) &#125; return ( &lt;div&gt; &lt;MyInput ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;focusHandle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default App useImperativeHandle作用：如果我们并不想暴露子组件中的DOM而是想暴露子组件内部的方法 12345678910111213141516171819202122232425262728293031import &#123; forwardRef, useImperativeHandle, useRef &#125; from &#x27;react&#x27;const MyInput = forwardRef(function Input(props, ref) &#123; // 实现内部的聚焦逻辑 const inputRef = useRef(null) const focus = () =&gt; inputRef.current.focus() // 暴露子组件内部的聚焦方法 useImperativeHandle(ref, () =&gt; &#123; return &#123; focus, &#125; &#125;) return &lt;input &#123;...props&#125; ref=&#123;inputRef&#125; type=&quot;text&quot; /&gt;&#125;)function App() &#123; const ref = useRef(null) const focusHandle = () =&gt; ref.current.focus() return ( &lt;div&gt; &lt;MyInput ref=&#123;ref&#125; /&gt; &lt;button onClick=&#123;focusHandle&#125;&gt;focus&lt;/button&gt; &lt;/div&gt; )&#125;export default App ZustandZustand Documentation store&#x2F;index.js - 创建store1234567891011121314import &#123; create &#125; from &#x27;zustand&#x27;//1. 使用create方法创建store//2. 函数参数必须返回一个对象，包含状态数据和方法//3. set是用来修改数据的专门方法const useStore = create((set) =&gt; &#123; return &#123; count: 0, inc: () =&gt; &#123; set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125; &#125;&#125;)export default useStore app.js - 绑定组件12345678import useStore from &#x27;./store/useCounterStore.js&#x27;function App() &#123; const &#123; count, inc &#125; = useStore() return &lt;button onClick=&#123;inc&#125;&gt;&#123;count&#125;&lt;/button&gt;&#125;export default App 异步支持对于异步操作的支持不需要特殊的操作，直接在函数中编写异步逻辑，最后把接口的数据放到set函数中返回即可 store&#x2F;index.js - 创建store1234567891011121314151617181920import &#123; create &#125; from &#x27;zustand&#x27;const URL = &#x27;http://geek.itheima.net/v1_0/channels&#x27;const useStore = create((set) =&gt; &#123; return &#123; count: 0, ins: () =&gt; &#123; return set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125;, channelList: [], fetchChannelList: async () =&gt; &#123; const res = await fetch(URL) const jsonData = await res.json() set(&#123;channelList: jsonData.data.channels&#125;) &#125; &#125;&#125;)export default useStore app.js - 绑定组件1234567891011121314151617181920import &#123; useEffect &#125; from &#x27;react&#x27;import useChannelStore from &#x27;./store/channelStore&#x27;function App() &#123; const &#123; channelList, fetchChannelList &#125; = useChannelStore() useEffect(() =&gt; &#123; fetchChannelList() &#125;, [fetchChannelList]) return ( &lt;ul&gt; &#123;channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; )&#125;export default App 切片模式场景：当我们单个store比较大的时候，可以采用一种切片模式进行模块拆分再组合 拆分并组合切片1234567891011121314151617181920212223242526272829import &#123; create &#125; from &#x27;zustand&#x27;// 创建counter相关切片const createCounterStore = (set) =&gt; &#123; return &#123; count: 0, setCount: () =&gt; &#123; set(state =&gt; (&#123; count: state.count + 1 &#125;)) &#125; &#125;&#125;// 创建channel相关切片const createChannelStore = (set) =&gt; &#123; return &#123; channelList: [], fetchGetList: async () =&gt; &#123; const res = await fetch(URL) const jsonData = await res.json() set(&#123; channelList: jsonData.data.channels &#125;) &#125; &#125;&#125;// 组合切片const useStore = create((...a) =&gt; (&#123; ...createCounterStore(...a), ...createChannelStore(...a)&#125;)) 组件使用123456789101112131415function App() &#123; const &#123;count, inc, channelList, fetchChannelList &#125; = useStore() return ( &lt;&gt; &lt;button onClick=&#123;inc&#125;&gt;&#123;count&#125;&lt;/button&gt; &lt;ul&gt; &#123;channelList.map((item) =&gt; ( &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;/&gt; )&#125;export default App 对接DevTools 简单的调试我们可以安装一个 名称为 simple-zustand-devtools 的调试工具 安装调试包1npm i simple-zustand-devtools -D 配置调试工具123456789101112131415import create from &#x27;zustand&#x27;// 导入核心方法import &#123; mountStoreDevtool &#125; from &#x27;simple-zustand-devtools&#x27;// 省略部分代码...// 开发环境开启调试if (process.env.NODE_ENV === &#x27;development&#x27;) &#123; mountStoreDevtool(&#x27;channelStore&#x27;, useChannelStore)&#125;export default useChannelStore","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"}]},{"title":"landscape","slug":"landscape","date":"2024-09-15T13:50:48.000Z","updated":"2024-09-16T02:32:03.725Z","comments":true,"path":"2024/09/15/landscape/","permalink":"http://example.com/2024/09/15/landscape/","excerpt":"","text":"","categories":[{"name":"照片","slug":"照片","permalink":"http://example.com/categories/%E7%85%A7%E7%89%87/"}],"tags":[{"name":"风景","slug":"风景","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF/"}]},{"title":"我的第一篇博客","slug":"myFirstBlog","date":"2024-09-14T16:00:00.000Z","updated":"2024-09-15T10:22:39.218Z","comments":true,"path":"2024/09/15/myFirstBlog/","permalink":"http://example.com/2024/09/15/myFirstBlog/","excerpt":"","text":"2024.9.15,重新搭建博客网站，用来记录日常和学习笔记。。。","categories":[{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"项目","slug":"项目","permalink":"http://example.com/categories/%E9%A1%B9%E7%9B%AE/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://example.com/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"随笔","slug":"随笔","permalink":"http://example.com/categories/%E9%9A%8F%E7%AC%94/"},{"name":"文摘","slug":"文摘","permalink":"http://example.com/categories/%E6%96%87%E6%91%98/"},{"name":"照片","slug":"照片","permalink":"http://example.com/categories/%E7%85%A7%E7%89%87/"}],"tags":[{"name":"Hadoop","slug":"Hadoop","permalink":"http://example.com/tags/Hadoop/"},{"name":"node.js","slug":"node-js","permalink":"http://example.com/tags/node-js/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"面试八股","slug":"面试八股","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"vue3","slug":"vue3","permalink":"http://example.com/tags/vue3/"},{"name":"vue","slug":"vue","permalink":"http://example.com/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"css","slug":"css","permalink":"http://example.com/tags/css/"},{"name":"git","slug":"git","permalink":"http://example.com/tags/git/"},{"name":"react","slug":"react","permalink":"http://example.com/tags/react/"},{"name":"《我与地坛》","slug":"《我与地坛》","permalink":"http://example.com/tags/%E3%80%8A%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B%E3%80%8B/"},{"name":"风景","slug":"风景","permalink":"http://example.com/tags/%E9%A3%8E%E6%99%AF/"}]}